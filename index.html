
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Joey's Blog</title>
  <meta name="author" content="joey">

  
  <meta name="description" content="今天闲着没事，又上我们的ncuopen上面看了一下，发现小组现在活动极其不频繁，首页和wiki都没有怎么更新，然后上irc上看了一下，发现也没有人在线。 一个开源社区最大的悲哀就是没有活跃的用户，没有一个持续贡献的志愿者团队。 加入小组这么久了都没有做什么贡献真是惭愧， &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://xcaptain.github.io">
  <link href="/favicon.ico" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="/atom.xml" rel="alternate" title="Joey's Blog" type="application/atom+xml">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
  <script>!window.jQuery && document.write(unescape('%3Cscript src="./javascripts/libs/jquery.min.js"%3E%3C/script%3E'))</script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="//fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="//fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Joey's Blog</a></h1>
  
    <h2>Trying To Be A Hacker.</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div class="blog-index">
  
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/20/how-to-use-emacs/">How-to-use-emacs</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-12-20T11:44:35+00:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>20</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>11:44 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天闲着没事，又上我们的<a href="https://github.com/ncuopen">ncuopen</a>上面看了一下，发现小组现在活动极其不频繁，首页和wiki都没有怎么更新，然后上irc上看了一下，发现也没有人在线。</p>

<blockquote><p>一个开源社区最大的悲哀就是没有活跃的用户，没有一个持续贡献的志愿者团队。</p></blockquote>

<p>加入小组这么久了都没有做什么贡献真是惭愧，今天想了一下我可以整理一下我对于emacs使用的一点小小的心得。以下将会简单的说说我平时使用emacs来干什么。</p>

<ol>
<li>写代码，这是最基本的功能。</li>
<li>上网，在emacs24之前的版本必须使用一个叫做<code>emacs-w3m</code>的第三方扩展才能在emacs里面上网，但是现在emacs自己做了一个基于elisp写的文本浏览器<code>eww</code>，使用方式也很简单，直接<code>M-x eww</code>然后输入要搜索的内容或者是要打开的url就行，现在<code>eww</code>默认的搜索引擎是<code>duckduckgo</code>。</li>
<li>聊天，今天上<code>#ncuopen</code>上看了一下，发现聊天室里面没人在，突然比较一下那些比较火的聊天室，如<code>ubuntu</code>, <code>debian</code>每天上去都会有一大堆人在线，随便说一句话就会被别人刷屏，差距真的很大。如果要在emacs里面使用irc聊天，可以使用<code>erc</code>来连接服务器。</li>
<li>看pdf，emacs内建是可以打开pdf文件的，如果习惯了emacs的快捷键，而且不喜欢在<code>evince</code>，<code>okular</code>下面必须使用鼠标的操作，那么可以试试用emacs看pdf。</li>
<li>写博客，我自己也在github上面搭了一个octopress的博客，在本地就是用emacs编辑的博客，因为emacs支持<code>markdown</code>语法，编辑的时候可以直接看到语法高亮，保存后可以在本地预览。</li>
<li>执行shell命令，要么是使用<code>M-x shell</code>来打开一个shell或者是<code>M-x eshell</code>来使用emacs自带的终端模拟器，我喜欢用后者，然后就可以运行任何的shell命令了。不过我用eshell用得少，平时都是在<code>urxvt</code>里面执行命令的。</li>
<li>执行解释器，很动语言都内建了一个elpa的解释器，如ruby, python, php, haskell，sml等，如果想尝试一下某个表达式或者是某个代码段又不想写一个测试文件，那么在解释器里运行是最方便的了，执行<code>M-x run-python</code>, <code>M-x run-haskell</code>，会打开对应语言的解释器，就像在终端执行一样。如果想获得更多语言的支持，可以去<a href="http://elpa.gnu.org/packages/">elpa</a>或者是<a href="http://melpa.org/">melpa</a>上面找找。</li>
<li>使用git，emacs有个扩展叫做<code>magit</code>，用它来提交代码，查看差异，查看版本比在终端使用git命令方便。</li>
</ol>

</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/12/07/learn-beautifulsoup/">又是一个采集</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-12-07T22:25:45+00:00'><span class='date'><span class='date-month'>Dec</span> <span class='date-day'>7</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>10:25 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>前几天看到有个同事在采集<a href="https://yande.re">这个</a>站，要把上面的图片都搞下来。看他很得意的样子，似乎采集是个什么很复杂东西，其实简单得很，没什么技术含量在里面。他用的是一个叫做scrapy的采集框架，这个框架我没用过，但是自己写采集也简单。</p>

<p>之前采集过多玩和178的一些文章，需求还比较复杂，需要把ajax的接口也给搞定掉，还得把所有图片都本地化，那时候用的是urllib2+beautifulsoup这个东西采集的。</p>

<p>今天闲着没事，打算再来搞个采集玩玩，<a href="https://yande.re">yande</a>上面的图片质量还是比较高的。还是使用老一套，不过这回我不打算使用urllib2了，这东西太弱了，编码问题总是会出现，搞得我莫名其妙的，实在是打算放弃urllib2了，上网搜一下，找到了一个叫做<code>requests</code>的网络库，这个东西目前开发还是蛮活跃的，而且口气比较大，直接在官网说urllib2的api很混乱，那就是它了。页面分析的库还是用回beautifulsoup，这么久了仍然是很不喜欢写正则，所以拿这个库来解析html还是比较顺手。至于信息入库，我用的是<code>MySQLdb</code>这个库来驱动mysql，似乎这个库也比较弱，反正我是遇到很多很简单的sql语句都报错的情况了，在网上搜了一下，发现别的第三方的mysql库也很多，但是还没有下定决心换。</p>

<p>代码的思路很简单，和以前写的采集脚本差不多，都是先采集列表页，获得文章页的url，然后在文章页中采集想要的信息。信息采集完了就是入库，到这里采集过程就结束了。</p>

<p>代码很简单，已经提交到<a href="https://github.com/xcaptain/yande">github</a>了，和之前写的脚本比起来，多增加了一些东西：
1. 模糊匹配，比如说<code>soup.find(href=re.compile('user\/show'))</code>这样的东西。
2. 断点续踩，程序在跑的时候如果按下<code>Ctrl-C</code>来终止它的话，会把当前采集到的页码写入到一个叫做<code>config.py</code>的文件。
3. 异常处理，以前写的几个采集使用了很多if语句，很多嵌套的判断，就是为了人为规避异常，尽量让程序跑的时候都不遇到异常，这种写法真是太折磨人了，看到三四层嵌套判断我的头都要大了。这回尝试了一下直接在<code>try</code>里面执行代码段，如果遇到可能会有的异常就直接<code>except</code>上处理了它，真是省了很多心呀。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/23/got-an-old-pc/">入手一台二手PC</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-23T21:09:30+00:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>23</span><span class='date-suffix'>rd</span>, <span class='date-year'>2014</span></span> <span class='time'>9:09 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天下午在58上面看到一条消息，说的是190出售双核电脑，立即就心动了。作为一个linux，总是忍不住手痒想重装系统，或者是自定义系统，但是因为现在自己手头上只有一台笔记本，实在是不敢轻举妄动，不然把这电脑弄崩溃了，或者是丢失数据了那就损失惨重了。如果有一台空闲的机器那就好了，我可以随便在那台机器上面装系统，可以随意定制。而且有一台局域网内部的PC当作服务器，拿来当测试机很不错，在这里测试过代码之后再上传到线上vps上去。</p>

<p>说干就干，反正190也不贵，现在出去随便找个饭店吃个稍微好点的饭都不止190.给卖家打了电话先问了一下基本的情况，大致确定了消息的真实性，然后就是出发去验货了。那个卖家在东城区，好远啊，看了一下时间都已经3点半了，赶紧出发。又是转公交又是转地铁，终于到了东四北大街，来到了卖家的家里。太震惊了，卖家竟然是一个50多岁的老头，家里很简陋，胡同里很老的房子，但是里面堆满了电脑主机，估计有2,3百台。我要买的那台电脑正开着呢，装着win7系统，正在通过pptv看视频呢。cpu是amd的，1.9GHZ，ddr2内存1G大，网卡是100M的螃蟹卡，这种网卡对于*unix来说几乎都是免驱动的了，使用的太广泛了。剩下的就没什么说了，反正是打算拿来当服务器的，对于显卡没什么要求。</p>

<p>成交之后就抱着这主机又穿过了大半个北京回到了住的地方，累死我了。</p>

<p>回来之后打算装系统，问了一下群里的几个朋友，他们都说要装系统的话必须要有显示器才行。伤心，我还以为有一键安装系统的脚本呢，看来系统是得下周拿到公司去装了。真搞不懂，如果服务器装机也像普通桌面电脑一样的话，那些大公司的运维该多惨，几百台机器得装。</p>

<p>接下来就是得好好想想服务器装什么系统好了，现在vps上跑的是freebsd10,已经连续运行3个多月了，稳定性还可以。但是我自己桌面装的是archlinux，相对来说arch的用法还是比freebsd要简单得多。说到这里又想到这几天debian多位核心开发者离职，好像就是因为debian8要采用systemd的原因。arch很早就用了systemd来管理系统启动进程，导致现在用arch几乎都是傻瓜式了，开启某个软件，安装某个软件，检测某个进程运行状态，都可以通过systemctl来实现。对于*inux的哲学来说还是一个软件只干一件事，对于这种想把什么事都干掉的软件，freebsd是很抵制的。</p>

<p>真搞不懂到底哪种才是对的。</p>

<p>昨天在公司加班终于把zeze的代码部署到git上了。</p>

<p>之前用的版本管理是svn，但是我不太喜欢svn，因为emacs不支持它。我喜欢git，因为emacs对git的支持很好，通过magit我可以很轻松的看到每个版本之间的改动，可以任意提交代码。其实我也不是很熟悉git，但是得慢慢来学，以后git肯定是会取代svn的。</p>

<p>我把svn里面的代码复制到内网测试机之后，<code>git init</code>了这个目录，然后执行初始化提交，然后在本地执行<code>git clone user@host:/project/ ./project</code>把代码拷到了本地，打算在本地改了之后up到服务器上。但是后来我发现我想多了，git不是svn，用svn的这种思路是行不通的，线上的代码和本地的代码是毫无关系的2个分支，本地改了之后提交执行<code>git push</code>是会报错的。</p>

<p>那么什么才是正确的git方式呢？查看了一下git的文档，发现上面说git有一个版本库，克隆这个版本库就能获得最新的版本。</p>

<ol>
<li>先把代码复制到本地，<code>scp -r online_code local_code</code></li>
<li>把本地代码初始化成一个git仓库，<code>git init</code></li>
<li>把本地代码都加入到git版本中，<code>git add .</code></li>
<li>第一次提交代码，<code>git commit -m 'init commit'</code></li>
<li>把本地仓库推送到远程服务器上，<code>git remote add gituser@gitserver:/local_code.git</code>，在执行这步的时候必须确保git服务器上面已经存在local_code.git这个目录，如果不存在的话就得<code>mkdir local_code.git</code></li>
<li>把本地仓库保存的版本都推送到服务器上，<code>git push origin master</code></li>
<li>ssh上git服务器看看，找到local_code.git这个目录，发现里面的文件竟然和本地代码里面<code>local_code/.git/</code>下的内容一模一样</li>
<li>把仓库里的代码克隆到对外访问的环境，因为我是在本地做的测试，所以代码仓库和web服务器是在同一台机器上的，直接执行<code>git clone local_code.git /srv/http/online_code</code>就把版本库里面记录的代码复制出来放到服务器目录了。</li>
</ol>


<p>之前我直接在服务器上写代码，提交代码的时候真是落后，得通过命令行来提交代码，magit没法判断远程服务器上的代码的版本。现在这样就好了，我可以用magit随时commit,随时push，然后只要到<code>/srv/http/online_code/</code>下面<code>git pull</code>就行了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/09/my-first-machanical-keyboard/">我的第一块机械键盘</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-09T17:25:52+00:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>9</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>5:25 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>考虑良久，今天终于入手了一块机械键盘。对机械键盘发烧得从上周开始说起，看到一个同事用机械键盘，感觉太爽了，顿时自己也想买一个，然后就是在网上搜相关的信息。</p>

<h3>在网上了解到了很多机械键盘相关的信息，突然发现小小的键盘里面竟然有这么多内幕。</h3>

<ul>
<li><p>对于程序员来说HHKB当然是首选，但是高昂的价格让人望而生畏。</p></li>
<li><p>然后就是传说中的<a href="http://codekeyboards.com/">codekeyboard</a>，不过，这款键盘国内没得卖，而且在国外估计也是小众，还是以后再考虑吧。</p></li>
<li><p>还有一个很牛的键盘叫做<a href="http://www.daskeyboard.com/">daskeyboard</a>，这款键盘的创造者也是一个程序员大牛，具体的来源可以参考一下<a href="http://en.wikipedia.org/wiki/Das_Keyboard">wikipedia</a>，不过我不喜欢104键的键盘，而且价格也不便宜。</p></li>
<li><p>接下来就是一些很普通的键盘了，网上说机械键盘最重要的就是轴(switch)，最好的轴当然是德国樱桃(cherry)的原厂轴了。现在主要的樱桃轴是按照颜色来分的，有红轴(red switch)，黑轴(black switch)，青轴(blue switch)，茶轴(brown switch)，以及一些不太起眼的轴。在这四大主力轴中，黑轴公认的玩游戏最爽，红轴声音小，直上直下，青轴最吵，不过打字最爽。茶轴介于青轴和红轴之间，是新出的一款轴。</p></li>
</ul>


<p>我的这款poker 2是kbc产的，一个国产品牌，但是不得不说做工很不错，小巧紧凑，该有的功能都有了，以后估计可以纯键盘办公了。87和104一个很大的区别就是没有小键盘，所以要按方向键，翻页键都得通过FN组合来实现。对我来说有点不方便，因为我的urxvt的设定是<code>shift+downarrow</code>来实现新建标签的，已经习惯这种快捷键了。现在得按<code>shift+fn+s</code>才能打开一个新的urxvt标签，在考虑是改改urxvt的设置还是改改键盘映射。</p>

<p>底下的win键倒是很符合我的需要。现在用的是xmonad的窗口管理器，我之前设置的快捷键是<code>mod1mask+[1..9]</code>来切换窗口的，现在不需要怎么改就能直接用win键。</p>

<p>打开火狐浏览器的时候突然发现没有上下方向键不好滚动页面了，而且没有了左方向键回到前一页也不方便了。不过发现了一个解决办法。要滚动页面可以考虑<code>fn+[s,w]</code>，或者是<code>[fn+space]然后[w,s]</code>。因为[fn+space]会把asdw变成方向键。要回到前一个页面就不太方便了，我想了一下可以把<code>[backspace]</code>设置为回到前一页的快捷键。不过这个得改firefox的快捷键设置。在地址栏输入<code>about:config</code>，然后找到<code>browser.backspace_action</code>，我这里默认的是2,也就是说shift加左箭头可以回到前一页，不过我想把这个值设置为0,这样就是<code>backspace</code>来回到前一页了。</p>

<p>几个大按键不太好，声音和普通按键不同，有点滞胀感。问了卖家，他说这是正常情况，因为大的shift用了一个平衡杆来感应按键，虽然很不爽，但是还是忍忍吧，以后有钱了买个好的键盘，现在这个就先拿来练练手。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/02/redis-crash/">Redis崩溃</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-02T00:36:37+00:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>2</span><span class='date-suffix'>nd</span>, <span class='date-year'>2014</span></span> <span class='time'>12:36 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>星期五上班的时候运维报告说有一台redis服务器的流量出现异常，接收到的流量非常高，主要是来自另外一台服务器的。然后又给出了这台服务器上<code>netstat -nt | grep -i 'time_wait'</code>的结果，发现1000多个time_wait的进程，太恐怖了，连接的丢包率这么高，是不是说明redis性能很低了呢？</p>

<p>telnet上redis服务器去查看了一下，也就10万+的key，按理来说不应该这么慢。后来事故达到高峰期了，好几个站出现502了，这时候运维报告redis服务器网卡io达到峰值，太恐怖了，服务器使用的是1000Mbps的网卡，每秒钟redis读写超过1G了，怎么会这样？这时候看来就好理解之前netstat的结果了，既然网卡达到上限了，肯定服务器就不能即使返回请求。</p>

<p>redis读写过高我们分析可能原因是写入了很巨大的key，在redis里面monitor了一下最近的读写状况，发现大部分都是get一些很小的key，一般都是一些比较小的数组，既没有缓存文件，也没有缓存大段的页面，那么为什么会出现流量过高呢？我觉得很大的原因是redis真的出现性能问题了，如果性能下降了的话，而请求数又没变，也是会导致time_wait的。其实我早就发现我们现在编码很不规范，redis有5种数据结构，但是在大部分业务中都只用到了1种数据结构，也就是字符串。不得不说这是一个很傻的设计。在10几万的key中get一个key得有多慢，如果设计一些hash表，把不同的key存到hash里面，那么可以大大的提高redis的性能，毕竟redis的key大大的减少了，而在hash表里面查询某个key的值还是比较快的。肯定比在redis库里查询快。不过知道问题所在不意味着我们会去改，现在开发人员本来就少，但是新的项目一个接一个。目前简单测试了一下没问题就上线了，根本没有考虑过代码的性能问题，没有人审核代码，没有人压力测试代码，在开发的时候怎么省事怎么来，之前别人写的方法copy过来直接用，也不管之前的代码和现在的代码处理的问题有多不同，只要能用那就可以。</p>

<p>这也是没办法的办法，可以做的不多，后来他们把一些代码的缓存时间缩短了，这样就不会有太多的key留在内存中，减少key的数量之后大概能加快一点查询效率。而且他们还审查了一部分代码，我看了他们找的一个文件，有个程序会一次性请求7个接口获得一大堆数据，但是真正有用的只是其中一部分，后来他们优化了一下，在取数据之前加了一些判断来觉得到底去取哪个数据。看起来效果挺明显的，至少这个文件的请求就少了7倍。</p>

<p>顺便再来总结一下netstat(network statistics)的用法吧，用它来监控网络状况挺好的。
1. 直接执行<code>netstat</code>，会输出当前所有的连接。
2. <code>netstat -a</code>，输出所有的连接，和<code>netstat</code>的结果一样。
3. <code>netstat -t</code>，列出所有的tcp连接。
4. <code>netstat -i</code>，列出当前所有的网络接口，比如说我的笔记本有3个接口，一块以太网卡，一块无线网卡，一个回环接口。
5. <code>netstat -s</code>，列出当前所有协议的统计状态，包括tcp, ip, udp, icmp等。
6. <code>netstat -p</code>，列出进程名以及对应的pid。
7. <code>netstat -r</code>，列出当前的路由表。</p>

<p>主要得分析一下<code>netstat -a</code>的输出，这个连接状态太多了，得好好研究一下。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/11/01/debug-discuz-1/">调试discuz（一）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-11-01T23:40:57+00:00'><span class='date'><span class='date-month'>Nov</span> <span class='date-day'>1</span><span class='date-suffix'>st</span>, <span class='date-year'>2014</span></span> <span class='time'>11:40 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>现在他们在做一个论坛，因为人手不够，所以最后决定使用discuz来快速搭建一个论坛。我是很反感这种做法的，大公司怎么会用discuz来搭建自己的社区呢？太丢脸了，这不是告诉别人你没有研发能力吗？不过现在我们这边的研发能力确实很弱，公司不是研发型的，太悲哀了。</p>

<p>我以前从没有接触过discuz，第一次碰到感觉压力很大，什么数据字典，缓存结构，插件机制，模板机制我都不懂，最初他们只叫我做了一点简单的部署问题，比如改个nginx的rewrite规则，改个简单的模板样式，不过渐渐的麻烦的任务也来了。</p>

<p>首先是说他们买了一个模板（真够丢人的），但是这个模板是被加密了的，现在要稍微二次开发一下，比如说改一些url的规则，使得url更加seo友好。其实模板上的url还是很好改的，模板改了之后再加点rewrite到nginx就好了。但是在分页上的url就不好改了，需要去看插件是如何获得数据，输出数据的，结果可恨的是这个插件的开发者把取数据，传数据的过程都给加密了，让人非常郁闷。到最后甚至一度想要把这些加密的方法破解了，不过到底不可能花太多时间去破解，干活才是最重要的。</p>

<p>调了一晚上，终于发现了插件在实现分页的时候调用到了一个discuz的分页函数，在<code>source/function/</code>里面执行<code>grep 'multi' -R *</code>在<code>function_core.php</code>这个文件里找到了multi这个函数，然后发现这个函数调用了<code>helper_page::multi</code>这个函数，继续找这个函数。首先找<code>helper_page</code>这个类，那就去<code>source/class/</code>里面找，<code>grep 'multi' -R *</code>在<code>helper/helper_page.php</code>里面找到了multi这个静态方法。接下来就是改造这个方法了。大致看了一下，这个函数接受一个url，一个当前页码，以及一些不太重要的东西作为参数，最后输出一段分页代码。在生成html的时候调用到了一个叫做<code>mpurl</code>的方法，这个函数会决定使用什么形式的分隔符来输出url。到这里形势大概就很明朗了，我不必要去改分页函数的逻辑，我只要改<code>mpurl</code>这个函数就好了，如果是这个插件的url，我就让这个函数特殊照顾一下这个插件。</p>

<p>那么现在问题来了，我是该怎么去改造这个函数呢？在它里面加判断？外面加判断？重写一个自定义的函数？我的想法是加入一个自定义的分页函数，<code>multi</code>在调用<code>mpurl</code>的时候会判断一下是调用它还是调用我写的自定义的函数。我想要通过函数名复制来实现，但是我不知道在php里怎么做，所以我就去<a href="http://stackoverflow.com/questions/26657161/can-i-assign-a-function-in-php">stackoverflow</a>上问了一下，有个家伙说可以通过变量来保存函数名，比如说<code>$func = 'add';</code>，那么<code>$func(1,2);</code>就等同于<code>add(1,2);</code>了。这个方法有点函数式编程的意思了，不过还是不够，本质上不属于函数名赋值，而且对于调用类里的方法不起作用，我尝试着<code>$func = 'self::add'</code>，然后发现总是会报错。后来采用了另一个家伙的方法，写一个帮助函数，在这个帮助函数里面会判断到底是使用dz原生的<code>mpurl</code>还是使用我的<code>my_mpurl</code>，这个方法挺好，我照着做了，终于把分页搞定了。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/26/learn-haskell-2/">学习haskell（二）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-10-26T17:13:53+00:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>26</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>5:13 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天发现一件很有趣的事，我在ghci下输入<code>:i zip</code>来查看zip这个函数的用法的时候得到的结果是<code>zip :: [a] -&gt; [b] -&gt; [(a, b)]   -- Defined in ‘GHC.List’</code>，zip明明是接收2个列表作为参数，然后一个元组的列表，但是根据这个输出，感觉zip是先处理列表[a]，然后再处理列表[b]，最后得到一个得到一个列表[(a, b)]。</p>

<p>为了验证我的猜想，先试<code>zip [1,2,3] [3,2,1]</code> 得到 <code>[(1,3),(2,2),(3,1)]</code>。这是意料之中的，zip的作用就是这个。</p>

<p>然后再试验：<code>(zip [1,2,3]) [3,2,1]</code> 得到 <code>[(1,3),(2,2),(3,1)]</code>，在这个函数调用中，我用括号把前一部分括起来了，也就是说先处理一个列表，然后返回一个函数再处理另一个列表。很奇怪，在实际函数调用中使用的是什么顺序来求值的呢？</p>

<p>在<a href="http://stackoverflow.com/questions/26571897/haskell-function-invoke-order">stackoverflow</a>上面问了一下这个问题，原来这种现象有一个专业术语叫作<a href="http://en.wikipedia.org/wiki/Currying">currying</a>，也就是说函数如何处理多个参数。没有看到后面就问问题还是比较尴尬的，在haskell里面大名鼎鼎的术语都不知道，太丢人了。</p>

<p>后来我在搜索curry的时候还发现了<a href="http://www-history.mcs.st-andrews.ac.uk/Biographies/Curry.html">Haskell Brooks Curry</a>这个人，haskell就是以他的名字命名的，真是牛得不行的一个家伙，16岁上哈佛，先是学医，后来又转学数学，后来有修了一个物理学的硕士，博士又开始搞数学，开始是打算写偏微分方面的论文的，到最后发现兴趣在逻辑学上，就转而研究逻辑去了。在40岁的时候成为了世界上最有名的逻辑学家。haskell的爱好者看起来都有很强的数理逻辑的背景啊，对于写过程式的代码也许真会越写越傻，因为思维到最后都变成机器的思维了。</p>

<p>还有一件很有意思的事就是惰性求值，在别的语言里可真是不多见。所谓的惰性求值就是如果这个变量没有被用到那就不会去求值。比如说<code>let a = 1</code>，在这里定义了一个变量a，但是其实这时候a还没有求值，只有在我们调用a的时候才会打印它的值。再比如说<code>let a = cycle [1,2,3]</code>，这会一直循环[1,2,3]这个列表，但是如果我们不去调用a就没关系，反正不调用就没有值。或者我们<code>take 10 a</code>，就会得到返回列表的前10个值，在这里调用了a，但是在求值的时候只用到了前10个，所以a没有一直循环下去。别的语言有这种定义无限个元素的列表的能力吗？别的语言有惰性求值的能力吗？</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/25/learn-haskell-1/">学习haskell（一）</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-10-25T22:15:29+00:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>25</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>10:15 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>上周去国图还书的时候无意中看到了一本讲haskell的书，就顺手借回来了。想想第一次听说haskell这个名字还是从王垠的博客里看到的，那时候听他在博客里讲惰性求值，列表解析，lambda函数啊，什么的，根本听不懂。不过到现在为止，深入学习了python，对于列表解析，lambda函数还算是有一个浅浅的了解。而且已经学习过scheme和sml了，虽然都没有花太多时间去学习它们，但是至少对函数式编程了解了一个大概。</p>

<p>以我目前对于函数式编程的理解来说，主要就是一切都是函数，数据是函数，函数也是函数。一个变量只有一个值，不能通过赋值来改变一个变量的值，只能让它重新绑定到另外一个值，所以变量的状态不会改变，不会出现副作用。这些都是一些很粗浅的理解，毕竟没有正儿八经的研究过函数式编程。主要有一个原因就是现在用函数式语言来开发的项目不多，我们学习编程主要还是用来解决实际问题，如果这门语言现实中没什么人用，或者是没法用到，那么学习它的激情就不会太高，虽然说学习过之后可能会提升编程思维。目前我了解的比较有名的函数式语言开发的项目有emacs，这个是用elisp语言来开发的一个编辑器，很强大。texmacs，一个所见即所得的tex编辑器，用的是scheme开发的。guile，gnu世界中的一个lisp编译器，能把lisp代码编译为c语言代码。chicken scheme，又一个scheme的编译器，按照官网说的它编译机器码的效率也是很高的，而且好像第三方库也比较多。lisp族就这些了，而sml族就没有听说过什么大的项目，不得不说很令人沮丧。相比现在流行的c/c++,java,perl/python/php等语言，函数式语言处于一个很小众的地位。为什么这种语言这么强大但是却没什么发展呢？真是搞不懂。</p>

<p>后面开始去搜索haskell的相关信息，发现在80年代的时候一伙科学家发现函数式语言类别太多了，各种lisp变种太多，都有自己的优点，于是这伙人就想要一统函数式语言的天下，他们组建了一个小团体来研究未来的函数式语言。不得不说，开发这事就是得有很多人参与，没什么人参与的项目肯定不会发展的太好，linux的发展是这样，python是这样，都是有一个很大的志愿者团体来维护的，而像freebsd和scheme这样的东西则是在各个很牛逼的大学小范围流传。</p>

<p>haskell算是一个严格类型的语言，也就是说每个变量都有一个类型，数字和字符串之间不能直接操作。目前python和php代码写多了导致我不是很喜欢这个特性，每个变量都有一个类型，多麻烦，数字和字符串之间不能强制转换，不能比较，不能拼接，诸多不便。即使是scheme也不是强类型的，把一个数字添加到一个列表后面在scheme里面是很正常的。sml在这点和haskell差不多，不过sml比haskell更加严格，在定义函数的时候得写明函数接收哪些类型的参数。</p>

<p>不过强类型语言也有一个优点就是执行效率高，在编译过程中执行类型检测，发现问题直接报告异常然后退出，而不是在运行时报告异常。而且强类型语言生成的代码跑起来的时候需要更少的内存。</p>

<p>haskell有自己的编译器，似乎种类有好几种，我在archlinux上用的是ghc，这个编辑器自带了一个解释器叫做ghci，安装好之后在终端输入ghci就能进入解释器，一行一行的执行输入的表达式了。python，php，ruby，scheme，sml都有自己的解释器，能够对每一个表达式求值，真方便。我最讨厌要编译机器码的语言了。</p>

<p>haskell有多种内置的类型，我现在接触了数字，字符串，列表，元组这4个类型。要定义一个变量也很简单，直接<code>let a = 1</code>这样就定义了一个变量a，它绑定了一个数字1,当然我们也可以理解为这行代码定义了一个函数，当执行这个函数的时候会返回一个数字1,在这里函数也变成普通变量了。</p>

<p>字符串是用双引号引起来的，<code>let s = "hello"</code> 就生成了一个字符串变量s，是把它当作函数还是当作普通变量就看个人喜好了。如果要获得某个字符串中间的一个字符，可以使用<code>!!</code>操作符，比如说<code>"hello" !! 2</code> 会返回一个&#8217;l&#8217;，看惯了c数组风格的字符串索引再来看haskell的形式，真是不习惯。</p>

<p>列表是函数式语言的最重要的数据结构，从50年代麦卡锡发明的表处理语言开始，在各个函数式语言里都可以看到列表的各种表现形式。scheme的car和cdr，sml的hd和tl，而在haskell里面则是head和tail。定义一个列表<code>let l = [1,2,3,4]</code>，<code>head l</code>返回列表第一个元素，<code>tail l</code>返回列表除了第一个元素外剩下的元素，<code>init l</code>返回列表除了最后一个元素外的所有元素，<code>last l</code>返回最后一个元素。剩下的还有maximum, minimum, reverse, length, null, take, drop, sum, product, elem等方法，看得眼花缭乱啊，至于为一个这么基本的数据结构写这么多方法吗？ 对于列表还有一个很重要的特性就是可以生成一个列表范围，如果一个集合的元素是可以用很清晰的语言枚举出来的话那么这个集合可以用列表表示出来，比如说如果要生成1到100的所有整数，那么只要<code>[1 .. 100]</code>就可以了，如果要确定步长的话只要枚举前2个元素就好了<code>[1, 3 .. 100]</code>这样就生成了1到100的所有奇数。那么能不能生成[1,2,4,8 &hellip;]这样的变步长的列表呢？很遗憾，haskell没有把这种列表写入最基本的列表方法里面，也很好理解，对于变步长的列表给出了前几个元素不是很好推测下一个元素，如果不清楚它那么就不能实现它，写程序的至理名言。</p>

<p>接下来就涉及到列表解析了，它对应数学里面一个很重要的概念&ndash;集合，<code>{x | x &lt; 10，x是正整数}</code>这是一个很简单的集合，在haskell里面就是<code>[1 .. 9]</code>。如果集合是<code>{x | x &lt; 10，x是偶数}</code>，在haskell里面就是<code>[x | x &lt;- [1 .. 9], x `mod` 2 == 0]</code>，这就是很简单的列表解析了。</p>

<p>元组和列表差不多，不过限制比较松散，列表要求所有的元素都是同一个类型的，而元组没有这个限制<code>(1, 2, "hello")</code>这样就建立了一个三个元素的元组，</p>

<p>haskell是一门很有前景的语言，得好好学学，希望能够坚持每天学点haskell，每天积累一点新知识。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/10/18/emergency-case-1/">再来记录一次紧急情况</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-10-18T11:48:41+00:00'><span class='date'><span class='date-month'>Oct</span> <span class='date-day'>18</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>11:48 am</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>昨晚12点多的时候突然被从被窝里拉出来了，虽然不再睡觉，但是这种感觉也是很不爽的，就因为我负责的一个网站首页出现500错误，提示数据库不能连接了。
妈呀，这么大的事，怎么还能安心玩手机，赶紧起来查找原因。</p>

<p>目前我这个站是搭建在2台服务器上的，用这2台机器来做负载均衡，跑了3个多月了，一点事都没有， 怎么会突然连不上数据库呢。查看了一下配置，这个站连接着
2个mysql，不是主从，而是业务分开的2个数据库，因为要把2块不太相关的内容整合在一起，通过vpn连接上公司的内网，ssh上服务器尝试连接数据库，第一个数据库
连接正常，但是尝试连接第二个数据库的时候就出现连接错误了，服务器拒绝连接了。很显然，要么这个数据库所在的服务器宕机了，要么就是这个数据库的请求数太多了，
为了避免宕机，数据库自动进入一种保护机制，拒绝所有后来的连接。</p>

<p>尝试这ping了一下服务器，没有宕机，还好，看来就是一个db出问题了，这个db之前也出过问题，当时运维是更改了配置，增加了数据库的最大连接数上限，不过这么晚的时候
找运维也不好找，人家也不愿意大半夜从床上跑起来给你改服务器配置。那么没办法了，只能改代码了。只能把所有涉及到第二个数据库的代码都删了，这样还有一线生机。</p>

<p>因为我的站点结构比较简单，内容只包括视频和文章，视频来自一个数据库，文章来自另一个数据库，只要把文章都干掉就ok，还好文章也不多，而且在页面上结构挺分离的，
还算比较好弄，在配置里面删除第二个数据库的配置，在控制器里删除调用了第二个数据库的方法，在页面上删除文章所在的div，然后刷新页面，ok好了。</p>

<p>真是惊险刺激啊，要是我没有vpn的话这个站就得挂一晚上，要是文章和视频的耦合度太高的话我也束手无策，要是前端设计的页面太复杂的话也会给我的改动带来很多麻烦。还好
这些假设都不存在。感谢Yii框架，大爱。</p>
</div>
  
  


    </article>
  
  
    <article>
      
  <header>
    
      <h1 class="entry-title"><a href="/blog/2014/09/28/connect-to-vpn/">Connect-to-vpn</a></h1>
    
    
      <p class="meta">
        




<time class='entry-date' datetime='2014-09-28T16:02:00+00:00'><span class='date'><span class='date-month'>Sep</span> <span class='date-day'>28</span><span class='date-suffix'>th</span>, <span class='date-year'>2014</span></span> <span class='time'>4:02 pm</span></time>
        
      </p>
    
  </header>


  <div class="entry-content"><p>今天拿到vpn了，真是兴奋啊，早在实习结束的时候就要求了vpn，结果5个月后才拿到手，真是的。
拿到了vpn意味着以后可以早点下班，有事情在家里远程办公还是无休止的工作，休息即工作呢？
希望我不会把工作和生活混乱了。</p>

<p>拿到的vpn就3条信息，一个服务器ip，帐号，密码。也不说一下vpn服务器是用什么软件部署的，这让我怎么
挑客户端软件来连接呢？万一服务器和客户端所用的协议不一样我不是浪费时间吗。算了，都已经这么晚了
还是先随便试一个吧，如果有问题明天到了公司再说。</p>

<p>首先试的是pptp的客户端，因为这是使用最广泛的vpn协议了，虽然之前好像看到过这种通信的加密很弱，但是
没关系，又不发表反动言论。</p>

<p>首先要安装pptp的客户端，很简单，<code>sudo pacman -S pptpclient</code>。</p>

<p>然后需要配置一下vpn连接的参数，比如说服务器ip多少，帐号密码多少。最麻烦的方法莫过于手动改写配置文件了，但是
还好pptp自带了一个setup的功能，一条命令就可以创建vpn连接。
<code>pptpsetup --create my_tunnel --server vpn.example.com --username alice --password foo --encrypt</code>
把my_tunnel替换成一个隧道别名，以后就可以使用这个别名来连接指定的vpn服务器了。
在&ndash;server参数后改为需要连接的ip地址，作为公司内部访问才不会为vpn服务配置一个域名呢，又不是给外人开放使用，没必要好记。
在&ndash;username参数后面输入分配的用户名
然后回车执行这条命令就会提示输入密码，输入密码，ok如果没问题的话现在已经创建好了一个vpn连接，接下来需要做的就是启用这个连接。</p>

<p>直接<code>pon my_tunnel</code>就可以开启这个vpn连接了，然后输入<code>ifconfig</code>查看一下，如果出现了ppp0这个接口那就说明连接建立成功。</p>

<p>这时候试图访问公司内网，可是还是连接不上去，因为没有配置路由规则，默认情况下流量都走wlp3s0这个接口了，这是我的无线网卡的接口。
稍微配置一下公司服务器网段就行了，内部测试机是192.168.10.0/24的网段，所以在命令行输入<code>ip route add 192.168.10.0/24 dev ppp0</code>
然后就可以在本地通过ssh连接这个网段的机器了。</p>

<p>昨晚遇到一个紧急情况，又用了一下vpn，不知道为什么可以连接，也可以执行一些简单的命令，比如cd，ls，svn之类的，就是不能执行vim, cat这类命令，一查看某个文件
连接就会卡死，不得不在本地kill掉这个ssh会话，kill掉之后ppp0这个接口也自动关闭了，又得重新开一遍。不知道是什么原因。</p>
</div>
  
  


    </article>
  
  <div class="pagination">
    
      <a class="prev" href="/posts/2">&larr; Older</a>
    
    <a href="/blog/archives">Blog Archives</a>
    
  </div>
</div>
<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2014/12/20/how-to-use-emacs/">How-to-use-emacs</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/12/07/learn-beautifulsoup/">又是一个采集</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/23/got-an-old-pc/">入手一台二手PC</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/09/my-first-machanical-keyboard/">我的第一块机械键盘</a>
      </li>
    
      <li class="post">
        <a href="/blog/2014/11/02/redis-crash/">Redis崩溃</a>
      </li>
    
  </ul>
</section>





  
</aside>

    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 - joey -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
