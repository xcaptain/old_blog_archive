<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Web | Joey's Blog]]></title>
  <link href="http://xcaptain.github.io/blog/categories/web/atom.xml" rel="self"/>
  <link href="http://xcaptain.github.io/"/>
  <updated>2015-01-01T11:53:58+00:00</updated>
  <id>http://xcaptain.github.io/</id>
  <author>
    <name><![CDATA[joey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[尝试hhvm]]></title>
    <link href="http://xcaptain.github.io/blog/2014/12/31/try-hhvm/"/>
    <updated>2014-12-31T16:10:28+00:00</updated>
    <id>http://xcaptain.github.io/blog/2014/12/31/try-hhvm</id>
    <content type="html"><![CDATA[<p>今天听到一个新闻说维基百科把他的php引擎由zend全面转到hhvm了，详情见<a href="https://www.mediawiki.org/wiki/HHVM">这里</a>。其实之前对于这东西是闻所未闻的，太不关注php的发展了，后来详细搜了一下，才稍微了解了一点php代码的执行过程。</p>

<p>对于动态语言来说，都是首先通过代码解析来生成字节码，然后通过解释器来执行这些字节码，php用的解释器叫作zend。看来和python差不多，程序在执行的时候也会先生成字节码，然后用python解释器去执行这些字节码。不过解释器的使用也导致了程序运行缓慢。所以现在facebook就做了一个叫作hhvm的东西，当通过hhvm来执行php程序的时候，会先生成一种中间码(intermediat byte code)也叫作HHBC(hhvm byte code)，然后hhvm会通过一种即时编译(just in time)的技术，将这种中间码编译为本地可执行的x86-64机器码，最后执行代码的时候等于是本地执行一个可执行程序，效率自然比解释器高了很多。不知道有没有什么方式能够把hhvm的这些步骤分离出来分析，真想看看php的字节码长什么样，生成的二进制程序长什么样。</p>

<p>我在本地立刻部署了一下HHVM的环境，很简单<code>sudo pacman -S hhvm</code>直接就安装hhvm了，测试一下效果，随便写一个php文件，然后<code>hhvm test.php</code>如果安装成功的话就可以得到像执行<code>php test.php</code>一样的效果，现在还没想好写个怎样的测试用例来比较hhvm和原生php的速度。</p>

<p>hhvm装好了之后当然不能只是用它来执行脚本，最重要的还是在服务器端编程上，当nginx接收到了一个请求的文件之后，并且把这个请求交个php的fastcgi处理后，在这里就不能用原生的php来执行文件里的php了，必须通过hhvm来执行，简单，就是不要启动php-fpm嘛，我看了一下安装hhvm的时候竟然自动连systemd的配置文件也生成了，所以我只要执行<code>sudo systemctl start hhvm.service</code>就能开启hhvm的监听程序了，类似php-fpm，hhvm服务器的配置文件存在<code>/etc/hhvm/server.ini</code>，在我这里配置文件写的是监听9000端口，那么<code>netstat -naltp | grep 9000</code>真的看到了一个监听的进程。然后就是确保nginx的配置文件中<code>fastcgi_pass</code>的值是<code>127.0.0.1:9000</code>，这样所有进入9000端口的数据都会被hhvm所处理。随便写了一个简单的数据库查询示例，暂时没发现hhvm和原生php的性能区别，也许是测试代码写得不好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[再来记录一次紧急情况]]></title>
    <link href="http://xcaptain.github.io/blog/2014/10/18/emergency-case-1/"/>
    <updated>2014-10-18T11:48:41+00:00</updated>
    <id>http://xcaptain.github.io/blog/2014/10/18/emergency-case-1</id>
    <content type="html"><![CDATA[<p>昨晚12点多的时候突然被从被窝里拉出来了，虽然不再睡觉，但是这种感觉也是很不爽的，就因为我负责的一个网站首页出现500错误，提示数据库不能连接了。
妈呀，这么大的事，怎么还能安心玩手机，赶紧起来查找原因。</p>

<p>目前我这个站是搭建在2台服务器上的，用这2台机器来做负载均衡，跑了3个多月了，一点事都没有， 怎么会突然连不上数据库呢。查看了一下配置，这个站连接着
2个mysql，不是主从，而是业务分开的2个数据库，因为要把2块不太相关的内容整合在一起，通过vpn连接上公司的内网，ssh上服务器尝试连接数据库，第一个数据库
连接正常，但是尝试连接第二个数据库的时候就出现连接错误了，服务器拒绝连接了。很显然，要么这个数据库所在的服务器宕机了，要么就是这个数据库的请求数太多了，
为了避免宕机，数据库自动进入一种保护机制，拒绝所有后来的连接。</p>

<p>尝试这ping了一下服务器，没有宕机，还好，看来就是一个db出问题了，这个db之前也出过问题，当时运维是更改了配置，增加了数据库的最大连接数上限，不过这么晚的时候
找运维也不好找，人家也不愿意大半夜从床上跑起来给你改服务器配置。那么没办法了，只能改代码了。只能把所有涉及到第二个数据库的代码都删了，这样还有一线生机。</p>

<p>因为我的站点结构比较简单，内容只包括视频和文章，视频来自一个数据库，文章来自另一个数据库，只要把文章都干掉就ok，还好文章也不多，而且在页面上结构挺分离的，
还算比较好弄，在配置里面删除第二个数据库的配置，在控制器里删除调用了第二个数据库的方法，在页面上删除文章所在的div，然后刷新页面，ok好了。</p>

<p>真是惊险刺激啊，要是我没有vpn的话这个站就得挂一晚上，要是文章和视频的耦合度太高的话我也束手无策，要是前端设计的页面太复杂的话也会给我的改动带来很多麻烦。还好
这些假设都不存在。感谢Yii框架，大爱。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Jsonp的一点简单看法]]></title>
    <link href="http://xcaptain.github.io/blog/2014/08/12/jsonp-some-thought/"/>
    <updated>2014-08-12T14:28:53+00:00</updated>
    <id>http://xcaptain.github.io/blog/2014/08/12/jsonp-some-thought</id>
    <content type="html"><![CDATA[<h3>jsonp是ajax的异域传输技术</h3>

<p>因为我不懂javascript，更不用说jquery了，所以现在在做的一个需要后台请求的页面只能让前端去做。
昨晚在公司加班和前端对接口，但是到了9点也没有解决掉bug，太失望了，不过今天来了之后和一个大牛
说了一下，他立刻就指出了问题所在。</p>

<p>先简单描述一下我做的这个项目吧。</p>

<p>项目不麻烦，后端用php+yii框架处理好页面间数据流逻辑，前端使用css和js做一些特效。我这边的工作
都做得差不多了，但是有一个分类页涉及到多级选择的问题，最初的设计是一次性从后台取几百个数据出来
但是评估了一下发现这种方法可行性不好，一次加载太多内容对用户的体验不好，而且不能充分读取数据库
的内容。后面和前端商量了一下采用ajax请求的方式，打开一个页面之后只加载进当前页面的内容，剩下
的内容等用户点击相应的链接触发相应的js事件之后以jsonp的方式给服务器发请求，然后服务器把要显示的
内容取出来。</p>

<p>在我看来jsonp就是一个站给出接口，另一个站通过js获得这个接口给的数据。这样就是异域了，最大的好处就是
后端的压力减轻了，之前如果所有的页面都在一个站上，那么所有相关的信息都得后端开发人员想办法从数据库
中取，也就是俗话说的套页面。我是很反感套页面这种工作的，没有一点技术含量，枯燥无聊，但是不可否认，
在phpweb开发中很大一部分时间花在这里了。现在如果php程序员只要给出接口，前端写js获得这个接口的数据，
他们来渲染页面，这样真是大大减轻了后端的压力，节省下来的时间可以上g+上看看新闻，在博客上发发文章，
怎么说前端对于html要比后端熟悉。</p>

<p>前端给出的接口也有要求，最主要的内容就是回调。
<code>
echo $callback . “(“ . $data . “)”;
</code>
在php的代码里加上这个语句，<code>$callback</code>是jquery的回调函数，<code>$data</code>是要传出去的接口数据，一般是一个
json数组的形式。我这个站的$data是由4个参数共同生成的，前端访问接口的时候是通过<code>http://www.example.com/api/?callback=Jquery_function&amp;arg1=1&amp;arg2=2&amp;arg3=3&amp;arg4=4</code>
既然明白请求的形式了，那么很好知道这个接口文件的写法了。</p>

<pre>
$callback = $_GET[‘callback’]; //获得回调函数
$arg1     = $_GET[‘arg1’];
$arg2     = $_GET[‘arg2’];
$arg3     = $_GET[‘arg3’];
$arg4     = $_GET[‘arg4’]; //获得剩下的4个参数
$data     = some_func($arg1, $arg2, $arg3, $arg4); //通过某些函数获得要返回的数据
</pre>


<p>很神奇吧，当你点击一个网页的时候，这个页面不是立刻向后台请求数据，而是通过js从另一个接口文件里拿数据。</p>

<p>我的经验还是很不丰富啊，以后要多学习，不然遇到一点比较新的技术就搞半天太丢脸了。</p>
]]></content>
  </entry>
  
</feed>
