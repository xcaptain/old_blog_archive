<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Sql,mysql,postgresql | Joey's Blog]]></title>
  <link href="http://blog.iyue.club/blog/categories/sql-mysql-postgresql/atom.xml" rel="self"/>
  <link href="http://blog.iyue.club/"/>
  <updated>2015-05-04T13:18:39+08:00</updated>
  <id>http://blog.iyue.club/</id>
  <author>
    <name><![CDATA[joey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mysql基础]]></title>
    <link href="http://blog.iyue.club/blog/2015/05/03/mysql-basics-1/"/>
    <updated>2015-05-03T02:34:28+08:00</updated>
    <id>http://blog.iyue.club/blog/2015/05/03/mysql-basics-1</id>
    <content type="html"><![CDATA[<p>五一第二天泡国图看了一下午关于sql的书，小有所获，才发现以前工作中用到的只是mysql中的一个很小的子集，该好好整理一下了基础知识了，当然对于很基本，已经用得很熟练的知识就不提了。</p>

<h3>什么是sql语言</h3>

<p>sql语言包括：
    DDL（数据定义语言）：创建数据库，创建表，创建视图，创建索引等。
    DML（数据操作语言）：也就是增删改查操作。
    DCL（数据控制语言）：COMMIT，ROLLBACK，GRANT等。</p>

<h3>聚合查询</h3>

<p>聚合查询指的是把一张表的内容分组，相关操作包括<code>count</code>, <code>sum</code>, <code>min</code>, <code>max</code>, <code>avg</code>, <code>group by</code>, <code>having</code>，前面5个是聚合函数，从一大串结果中取出我们要的属性。
后面2个是分组的。<code>group by</code>的语法为:</p>

<pre><code class="sql">select &lt;col1&gt;, &lt;col2&gt;, &lt;col3&gt;
    from &lt;table_name&gt;
[where ...]
group by &lt;col1&gt;, &lt;col2&gt;, &lt;col3&gt;
[having ...]
</code></pre>

<p>有一条限制说的是select子句中的每一个字段都必须出现在group by的子句中，但是我在mysql和postgresql中执行的时候结果确不一样，pgsql有这个限制，而mysql则松散得多。在我看来必须得严格才行，不然在有1对多关系的表中，group by之后的结果可能会让人莫名其妙，难怪很多人都说postgresql比mysql要严谨。</p>

<h3>事务</h3>

<p>事务指的是把一系列操作封装在一起来执行，要么同时执行这一些列操作，要么一个都不执行。这个以前工作也用到的不多，可能公司是以前写代码的人对于这个也不看中吧，基本上都是直接update，insert了。记得以前用python的<code>MySQLdb</code>的时候，如果有插入操作必须手动调用一下commit方法才能把数据写进数据库，那时候还不理解，感觉多了一步操作实在是太麻烦了，现在看来把所有操作都看作事务来执行，手动提交事务对于数据来说还是很安全的。</p>

<p>事务有4个特性：（ACID）</p>

<ol>
<li>原子性（Atomic）：事务是一个整体。</li>
<li>一致性（Consistency）：每个操作都必须满足对应列的约束条件。</li>
<li>隔离性（Isolation）：没一个事务中的数据对另一个事务都是不可见的，在提交操作之前，数据不在表里面。</li>
<li>持久性（Duration）：每个事务完成之后会有日志记录，方便从日志恢复数据。</li>
</ol>


<p>创建事务：</p>

<pre><code class="sql">start | begin transaction
sql1;
sql2;
...
commit
</code></pre>

<p>现在仔细想想原来看过好多同时更新多张表的代码没有走事务，那些业务真是太危险了，一张表的结构出错可能就导致整个业务逻辑崩溃。</p>

<h3>视图</h3>

<p>视图类似与一张表，但是区别是表里面存放着数据，但是视图里面没有数据。可以用</p>

<pre><code class="sql">create view &lt;视图名&gt; [&lt;col1&gt;, &lt;col2&gt;]
as
select &lt;col1&gt;, &lt;col2&gt; ...
    from
&lt;表名&gt;
</code></pre>

<p>来创建一个视图。视图主要是为调用很频繁的sql做的，省得每次都得写一大段sql，视图还可以层叠，也就是cascade，不过这功能又太偏了，单用view就已经很少了。不过不知道在view中执行查询有没有比直接在表中查询快，如果仅仅是为了sql简洁就发明视图这个概念出来那也太浪费了吧。</p>

<p>视图是子查询的基础，子查询可以看作是一个视图。</p>

<h3>表的集合操作</h3>

<p>表在关系代数中其实就是集合，所以可以交集，并集，查集。</p>

<h3>表连结</h3>

<p>以前大学的时候学离散数学，数据库原理都讲了关系代数，但是才刚刚毕业一年就几乎忘光了，到目前只知道内联接外联接，连用形式化语言来描述连接都做不到，实在是辜负大学四年了，不过现在做应用开发，基本的理论知识看起来又有点鸡肋。</p>

<p>连接分为内联接，外联接。
inner join &lt;=> join
left outer join &lt;=> left join
right outer join &lt;=> right join
尽量避免直接写outer join，这样会使语义模糊。</p>

<h3>基本查询惯例</h3>

<ol>
<li>建表的时候用<code>primary key(id)</code>来创建主键，以前我都是喜欢写在一个列的限制性约束条件后面。</li>
<li>在表明不相等关系的时候使用<code>&lt;&gt;</code>而不是<code>!=</code>，前者才是标准写法。</li>
<li><code>char</code>类型是按照字典顺序来排序的，一直以来我都以为是按照ascii的顺序来排的。</li>
<li>在建表的时候尽量避免使用NULL这个变量，因为在查询中空值比较不好处理，不好比较大小，不好做运算，不好count，我也不打算去研究NULL在各种情况下的意义。判断一个字段是否为NULL用<code>IS NULL</code>来判断。</li>
</ol>

]]></content>
  </entry>
  
</feed>
