<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Joey's Blog]]></title>
  <link href="http://xcaptain.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://xcaptain.github.io/"/>
  <updated>2015-01-13T13:17:00+00:00</updated>
  <id>http://xcaptain.github.io/</id>
  <author>
    <name><![CDATA[joey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[调试shadowsocks]]></title>
    <link href="http://xcaptain.github.io/blog/2015/01/03/debug-shadowsocks/"/>
    <updated>2015-01-03T23:16:58+00:00</updated>
    <id>http://xcaptain.github.io/blog/2015/01/03/debug-shadowsocks</id>
    <content type="html"><![CDATA[<p>昨天把在东京的虚拟机搬到加州去了，感觉这次搬家还是很值得的，传输稳定了很多，原来在东京的时候看个youtube经常卡，但是现在看youtube很流畅，不过每月多给2美元，让我帐号里的钱花得更快了。原来装的是freebsd10的系统，现在我把系统换成ubuntu14.04了，因为bsd的软件还是比较老的，而ubuntu就新多了，而且docker和container等都得在linux才能跑。</p>

<p>系统安装完之后肯定是要部署shadowsocks的，操作很简单就不多说了，一点问题都没有，但是今天早上起床开机就发现没法翻墙了，这时候问题就出现了，耽误我一整天时间。</p>

<p>笔记本没法翻墙是什么问题呢？试了一下手机，用fqrouter是没问题的，那就说明服务器端是没问题的，好吧，在客户端上找原因。</p>

<p>之前安装的客户端是nodejs版的，一直都这么用感觉没什么问题，现在我就打算换个客户端版本，试试python的。安装也很简单，但是就是上不了网，真是郁闷。没办法了，慢慢来调试找问题吧。我在服务器端和客户端都开启了-v参数，用来详细输出日志。</p>

<ol>
<li><p>用fqrouter访问的时候，服务器端输出：
 <pre>
 2015-01-03 08:48:07 INFO: accept a connection.
 2015-01-03 08:48:07 INFO: connect to: 106.162.216.94:443
 2015-01-03 08:48:07 INFO: asyncns resolved.
 2015-01-03 08:48:07 INFO: remote connected.
 </pre>
 看来这是正常连接，返回数据也正常。</p></li>
<li><p>本地用firefox访问google，服务器端输出：
 <pre>
 2015-01-03 08:49:56 INFO: accept a connection.
 2015-01-03 08:49:56 INFO: connect to: plus.google.com:443
 2015-01-03 08:50:16 INFO: asyncns resolved.
 2015-01-03 08:50:16 ERROR: getaddrinfo: Operation now in progress
 2015-01-03 08:50:16 INFO: current server connection: 2
 </pre>
 这就是失败的连接在服务器的日志了，只看到一行错误，搞不懂原因。</p></li>
<li><p>在服务器端执行<code>netstat -naltp | grep 8388</code>的输出：
 <pre>
 tcp        0      0 111.222.231.123:8388    0.0.0.0:*               LISTEN      1738/ss-server
 tcp        0      0 111.222.231.123:8388    152.42.49.117:29403     ESTABLISHED 1738/ss-server
 tcp        0      0 111.222.231.123:8388    152.42.49.117:29406     ESTABLISHED 1738/ss-server
 tcp        0      0 111.222.231.123:8388    152.42.49.117:29402     TIME_WAIT   -
 tcp        0      0 111.222.231.123:8388    152.42.49.117:29400     TIME_WAIT   -
 tcp        0      0 111.222.231.123:8388    152.42.49.117:29401     TIME_WAIT   -
 </pre>
 本地可以连接服务器的端口，那为什么没有数据返回呢？</p></li>
<li><p>在本地执行<code>netstat -naltp | grep 1080</code>的输出：
 <pre>
 tcp        0      0 127.0.0.1:1080          0.0.0.0:*               LISTEN      732/python
 tcp        0      0 127.0.0.1:45312         127.0.0.1:1080          ESTABLISHED 744/firefox
 tcp        0      0 127.0.0.1:1080          127.0.0.1:45312         ESTABLISHED 732/python
 tcp        0      0 127.0.0.1:1080          127.0.0.1:45307         TIME_WAIT   -
 tcp        0      0 127.0.0.1:1080          127.0.0.1:45309         TIME_WAIT   -
 </pre>
 看来浏览器和本地端口之间也是通的。</p></li>
</ol>


<p>本地应用可以连接本地的端口，本地的端口可以连接服务器，为什么就是没有数据呢？不会调试web程序，不会抓包，这时候只能乱猜原因，一下午都没有想通问题，就在我想要发帖求助的时候，想了一下为什么用fqrouter的时候服务器端接收到的是一个ip，而本地客户端连接服务器的时候就是一个域名，也许dns出问题了，试了一下<code>ping www.google.com</code>，果然不通，问题找到了，虚拟机提供商这个机房的dns昨晚出问题了，导致解析失败，添加一个第三方的dns，问题解决。</p>

<p><code>vi /etc/resolvconf/resolv.conf.d/base</code>添加下面2行</p>

<pre>
nameserver 8.8.8.8
nameserver 8.8.4.4
</pre>


<p>然后执行<code>resolvconf -u</code>刷新dns，这样就能使用google的dns了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[部署邮件服务]]></title>
    <link href="http://xcaptain.github.io/blog/2015/01/03/deploy-email-service/"/>
    <updated>2015-01-03T00:43:43+00:00</updated>
    <id>http://xcaptain.github.io/blog/2015/01/03/deploy-email-service</id>
    <content type="html"><![CDATA[<p>今天打算研究一下搭建自己的mail server用来收发邮件，不过后来发现在自己服务器上部署邮件服务太麻烦了，没有那么高性能的服务器，而且额外开放的服务可能会被黑客利用，那么就采用第三方的邮件服务吧。</p>

<h4>首先确定一下发件服务。</h4>

<p>根据网上的推荐，我用的是<a href="https://mandrillapp.com/">mandril</a>，这家公司为免费帐号提供每月发12000封邮件，对于个人玩来说足够了。接下来就是注册帐号，注册完成之后会有一个向导引导着去配置发件服务。填好之后配置都会出现在<a href="https://mandrillapp.com/settings">这里</a>，这些配置包括发件服务器的域名，端口，smtp用户名，以及密码，密码是网站生成的，要好好保存。</p>

<h4>然后就是配置收件服务</h4>

<p>同样也是根据网上的推荐，收件服务用的是国内一家公司的，叫做<a href="https://www.zoho.com/">zoho</a>，这家公司为每个免费帐号提供一个代收域名，15个免费邮箱，每个免费邮箱提供5G存储空间，对于个人玩来说也是足够了的，因为可以把邮件下载到本地，然后删除服务器上的邮件存档，所以这5G的空间可以永远也用不完。好像这家公司就在中关村，真想去参观一下。用zoho的原因是它提供邮件代收服务，我有一个域名<code>joxy.org</code>，我想注册一些邮箱以<code>@joxy.org</code>结尾，zoho就提供这种功能。过程也是很简单，需要先去注册帐号，注册帐号的时候要验证你是否对这个域名有所有权，所以还需要去<a href="https://mya.godaddy.com/">godaddy</a>上面验证一下，我是通过cname的形式来验证的。注册完成之后还得配置一下godaddy，因为在注册域名的时候默认设置了2个收件商，现在我不想用那2个厂商的收件服务了，所以要改改dns设置，找到mx这条配置，删掉额外的2个厂商的配置，然后加上一条mx记录，Host是@,表示joxy.org自身，Points to填mx2.zohomail.com，剩下的随便填就行了。这样当有人往<code>user@joxy.org</code>发邮件的时候，发件服务器通过dns查询的时候就知道要发给zoho，zoho就可以帮忙代收。</p>

<h4>发件服务和收件服务都配置好了，接下来就是测试一下是否能收发邮件了。</h4>

<p>用thunderbird可以很方便的写邮件收邮件。把我刚刚创建的xiefei@joxy.org这个帐号创建了，手动配置好这个帐号发送邮件和接收邮件的设置，就可以开始测试了。在配置smtp发件的时候需要输入密码验证用户是否有权限来发邮件，所以一定要记得填smtp的密码。我测试了一下和我的gamil邮箱互发邮件，一点问题都没有，而且邮件也没有进入垃圾箱。这真是太好了，图形界面的客户端可以收发邮件，真想看看通过php,ruby脚本能不能发邮件。</p>

<p>以上的配置参考了youtube上的<a href="https://www.youtube.com/watch?v=ndIflJOGSww">一个视频</a>，真感谢作者分享这么好的东西，省去了我翻资料学习的过程。</p>

<p>刚刚测试discourse的时候已经把邮件功能加上了，可以发送，真是神奇啊。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[解决pacman依赖关系破裂问题]]></title>
    <link href="http://xcaptain.github.io/blog/2015/01/01/arch-pacman-broken/"/>
    <updated>2015-01-01T11:35:23+00:00</updated>
    <id>http://xcaptain.github.io/blog/2015/01/01/arch-pacman-broken</id>
    <content type="html"><![CDATA[<p>今天准备更新一下系统，执行<code>sudo pacman -Syu</code>的时候，竟然没法同步软件源了，报告说依赖错误。</p>

<pre>
packagekit: requires pacman<4.2.0
package-query: requires pacman<4.2.0
</pre>


<p>但是我查看了一下pacman的版本,<code>pacman --version</code>发现是4.1的满足需求啊，为什么会有这样的提示呢？我想用<code>sudo pacman -S pacman</code>重装pacman也不行，真是费解，这么重要的软件可千万不能出错啊。后来上网搜了一下，发现有人也遇到这种情况，都是直接<code>sudo pacman -R packagekit python-packagekit yaourt package-query</code>，然后再<code>sudo pacman-db-upgrade</code>升级一下数据库，然后再<code>sudo pacman -Syu</code>，ok问题解决。</p>

<p>还有一点是关于virtualbox的，今天我又用了一下vagrant，发现每次<code>vagrant up</code>都会提示：</p>

<pre>
VirtualBox is complaining that the kernel module is not loaded. Please
run `VBoxManage --version` or open the VirtualBox GUI to see the error
message which should contain instructions on how to fix this error.
</pre>


<p>用最简单的方法<code>sudo modprobe vboxdrv</code>然后<code>lsmod | grep vbox</code>发现加载进了</p>

<pre>
vboxdrv               348377  3 vboxnetadp,vboxnetflt,vboxpci`
</pre>


<p>但是这时候还是会报错说找不到网卡驱动，后来我执行<code>sudo vboxreload</code>显示：</p>

<pre>
vboxpci                23139  0
vboxnetflt             27412  0
vboxnetadp             25443  0
vboxdrv               348377  3 vboxnetadp,vboxnetflt,vboxpci
</pre>


<p>这时候才算是真正的把所有的驱动都加进来了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[尝试hhvm]]></title>
    <link href="http://xcaptain.github.io/blog/2014/12/31/try-hhvm/"/>
    <updated>2014-12-31T16:10:28+00:00</updated>
    <id>http://xcaptain.github.io/blog/2014/12/31/try-hhvm</id>
    <content type="html"><![CDATA[<p>今天听到一个新闻说维基百科把他的php引擎由zend全面转到hhvm了，详情见<a href="https://www.mediawiki.org/wiki/HHVM">这里</a>。其实之前对于这东西是闻所未闻的，太不关注php的发展了，后来详细搜了一下，才稍微了解了一点php代码的执行过程。</p>

<p>对于动态语言来说，都是首先通过代码解析来生成字节码，然后通过解释器来执行这些字节码，php用的解释器叫作zend。看来和python差不多，程序在执行的时候也会先生成字节码，然后用python解释器去执行这些字节码。不过解释器的使用也导致了程序运行缓慢。所以现在facebook就做了一个叫作hhvm的东西，当通过hhvm来执行php程序的时候，会先生成一种中间码(intermediat byte code)也叫作HHBC(hhvm byte code)，然后hhvm会通过一种即时编译(just in time)的技术，将这种中间码编译为本地可执行的x86-64机器码，最后执行代码的时候等于是本地执行一个可执行程序，效率自然比解释器高了很多。不知道有没有什么方式能够把hhvm的这些步骤分离出来分析，真想看看php的字节码长什么样，生成的二进制程序长什么样。</p>

<p>我在本地立刻部署了一下HHVM的环境，很简单<code>sudo pacman -S hhvm</code>直接就安装hhvm了，测试一下效果，随便写一个php文件，然后<code>hhvm test.php</code>如果安装成功的话就可以得到像执行<code>php test.php</code>一样的效果，现在还没想好写个怎样的测试用例来比较hhvm和原生php的速度。</p>

<p>hhvm装好了之后当然不能只是用它来执行脚本，最重要的还是在服务器端编程上，当nginx接收到了一个请求的文件之后，并且把这个请求交个php的fastcgi处理后，在这里就不能用原生的php来执行文件里的php了，必须通过hhvm来执行，简单，就是不要启动php-fpm嘛，我看了一下安装hhvm的时候竟然自动连systemd的配置文件也生成了，所以我只要执行<code>sudo systemctl start hhvm.service</code>就能开启hhvm的监听程序了，类似php-fpm，hhvm服务器的配置文件存在<code>/etc/hhvm/server.ini</code>，在我这里配置文件写的是监听9000端口，那么<code>netstat -naltp | grep 9000</code>真的看到了一个监听的进程。然后就是确保nginx的配置文件中<code>fastcgi_pass</code>的值是<code>127.0.0.1:9000</code>，这样所有进入9000端口的数据都会被hhvm所处理。随便写了一个简单的数据库查询示例，暂时没发现hhvm和原生php的性能区别，也许是测试代码写得不好。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Redis崩溃]]></title>
    <link href="http://xcaptain.github.io/blog/2014/11/02/redis-crash/"/>
    <updated>2014-11-02T00:36:37+00:00</updated>
    <id>http://xcaptain.github.io/blog/2014/11/02/redis-crash</id>
    <content type="html"><![CDATA[<p>星期五上班的时候运维报告说有一台redis服务器的流量出现异常，接收到的流量非常高，主要是来自另外一台服务器的。然后又给出了这台服务器上<code>netstat -nt | grep -i 'time_wait'</code>的结果，发现1000多个time_wait的进程，太恐怖了，连接的丢包率这么高，是不是说明redis性能很低了呢？</p>

<p>telnet上redis服务器去查看了一下，也就10万+的key，按理来说不应该这么慢。后来事故达到高峰期了，好几个站出现502了，这时候运维报告redis服务器网卡io达到峰值，太恐怖了，服务器使用的是1000Mbps的网卡，每秒钟redis读写超过1G了，怎么会这样？这时候看来就好理解之前netstat的结果了，既然网卡达到上限了，肯定服务器就不能即使返回请求。</p>

<p>redis读写过高我们分析可能原因是写入了很巨大的key，在redis里面monitor了一下最近的读写状况，发现大部分都是get一些很小的key，一般都是一些比较小的数组，既没有缓存文件，也没有缓存大段的页面，那么为什么会出现流量过高呢？我觉得很大的原因是redis真的出现性能问题了，如果性能下降了的话，而请求数又没变，也是会导致time_wait的。其实我早就发现我们现在编码很不规范，redis有5种数据结构，但是在大部分业务中都只用到了1种数据结构，也就是字符串。不得不说这是一个很傻的设计。在10几万的key中get一个key得有多慢，如果设计一些hash表，把不同的key存到hash里面，那么可以大大的提高redis的性能，毕竟redis的key大大的减少了，而在hash表里面查询某个key的值还是比较快的。肯定比在redis库里查询快。不过知道问题所在不意味着我们会去改，现在开发人员本来就少，但是新的项目一个接一个。目前简单测试了一下没问题就上线了，根本没有考虑过代码的性能问题，没有人审核代码，没有人压力测试代码，在开发的时候怎么省事怎么来，之前别人写的方法copy过来直接用，也不管之前的代码和现在的代码处理的问题有多不同，只要能用那就可以。</p>

<p>这也是没办法的办法，可以做的不多，后来他们把一些代码的缓存时间缩短了，这样就不会有太多的key留在内存中，减少key的数量之后大概能加快一点查询效率。而且他们还审查了一部分代码，我看了他们找的一个文件，有个程序会一次性请求7个接口获得一大堆数据，但是真正有用的只是其中一部分，后来他们优化了一下，在取数据之前加了一些判断来觉得到底去取哪个数据。看起来效果挺明显的，至少这个文件的请求就少了7倍。</p>

<p>顺便再来总结一下netstat(network statistics)的用法吧，用它来监控网络状况挺好的。
1. 直接执行<code>netstat</code>，会输出当前所有的连接。
2. <code>netstat -a</code>，输出所有的连接，和<code>netstat</code>的结果一样。
3. <code>netstat -t</code>，列出所有的tcp连接。
4. <code>netstat -i</code>，列出当前所有的网络接口，比如说我的笔记本有3个接口，一块以太网卡，一块无线网卡，一个回环接口。
5. <code>netstat -s</code>，列出当前所有协议的统计状态，包括tcp, ip, udp, icmp等。
6. <code>netstat -p</code>，列出进程名以及对应的pid。
7. <code>netstat -r</code>，列出当前的路由表。</p>

<p>主要得分析一下<code>netstat -a</code>的输出，这个连接状态太多了，得好好研究一下。</p>
]]></content>
  </entry>
  
</feed>
