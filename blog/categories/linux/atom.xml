<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Linux | Joey's Blog]]></title>
  <link href="http://xcaptain.github.io/blog/categories/linux/atom.xml" rel="self"/>
  <link href="http://xcaptain.github.io/"/>
  <updated>2014-12-27T13:08:21+00:00</updated>
  <id>http://xcaptain.github.io/</id>
  <author>
    <name><![CDATA[joey]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Redis崩溃]]></title>
    <link href="http://xcaptain.github.io/blog/2014/11/02/redis-crash/"/>
    <updated>2014-11-02T00:36:37+00:00</updated>
    <id>http://xcaptain.github.io/blog/2014/11/02/redis-crash</id>
    <content type="html"><![CDATA[<p>星期五上班的时候运维报告说有一台redis服务器的流量出现异常，接收到的流量非常高，主要是来自另外一台服务器的。然后又给出了这台服务器上<code>netstat -nt | grep -i 'time_wait'</code>的结果，发现1000多个time_wait的进程，太恐怖了，连接的丢包率这么高，是不是说明redis性能很低了呢？</p>

<p>telnet上redis服务器去查看了一下，也就10万+的key，按理来说不应该这么慢。后来事故达到高峰期了，好几个站出现502了，这时候运维报告redis服务器网卡io达到峰值，太恐怖了，服务器使用的是1000Mbps的网卡，每秒钟redis读写超过1G了，怎么会这样？这时候看来就好理解之前netstat的结果了，既然网卡达到上限了，肯定服务器就不能即使返回请求。</p>

<p>redis读写过高我们分析可能原因是写入了很巨大的key，在redis里面monitor了一下最近的读写状况，发现大部分都是get一些很小的key，一般都是一些比较小的数组，既没有缓存文件，也没有缓存大段的页面，那么为什么会出现流量过高呢？我觉得很大的原因是redis真的出现性能问题了，如果性能下降了的话，而请求数又没变，也是会导致time_wait的。其实我早就发现我们现在编码很不规范，redis有5种数据结构，但是在大部分业务中都只用到了1种数据结构，也就是字符串。不得不说这是一个很傻的设计。在10几万的key中get一个key得有多慢，如果设计一些hash表，把不同的key存到hash里面，那么可以大大的提高redis的性能，毕竟redis的key大大的减少了，而在hash表里面查询某个key的值还是比较快的。肯定比在redis库里查询快。不过知道问题所在不意味着我们会去改，现在开发人员本来就少，但是新的项目一个接一个。目前简单测试了一下没问题就上线了，根本没有考虑过代码的性能问题，没有人审核代码，没有人压力测试代码，在开发的时候怎么省事怎么来，之前别人写的方法copy过来直接用，也不管之前的代码和现在的代码处理的问题有多不同，只要能用那就可以。</p>

<p>这也是没办法的办法，可以做的不多，后来他们把一些代码的缓存时间缩短了，这样就不会有太多的key留在内存中，减少key的数量之后大概能加快一点查询效率。而且他们还审查了一部分代码，我看了他们找的一个文件，有个程序会一次性请求7个接口获得一大堆数据，但是真正有用的只是其中一部分，后来他们优化了一下，在取数据之前加了一些判断来觉得到底去取哪个数据。看起来效果挺明显的，至少这个文件的请求就少了7倍。</p>

<p>顺便再来总结一下netstat(network statistics)的用法吧，用它来监控网络状况挺好的。
1. 直接执行<code>netstat</code>，会输出当前所有的连接。
2. <code>netstat -a</code>，输出所有的连接，和<code>netstat</code>的结果一样。
3. <code>netstat -t</code>，列出所有的tcp连接。
4. <code>netstat -i</code>，列出当前所有的网络接口，比如说我的笔记本有3个接口，一块以太网卡，一块无线网卡，一个回环接口。
5. <code>netstat -s</code>，列出当前所有协议的统计状态，包括tcp, ip, udp, icmp等。
6. <code>netstat -p</code>，列出进程名以及对应的pid。
7. <code>netstat -r</code>，列出当前的路由表。</p>

<p>主要得分析一下<code>netstat -a</code>的输出，这个连接状态太多了，得好好研究一下。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Connect-to-vpn]]></title>
    <link href="http://xcaptain.github.io/blog/2014/09/28/connect-to-vpn/"/>
    <updated>2014-09-28T16:02:00+00:00</updated>
    <id>http://xcaptain.github.io/blog/2014/09/28/connect-to-vpn</id>
    <content type="html"><![CDATA[<p>今天拿到vpn了，真是兴奋啊，早在实习结束的时候就要求了vpn，结果5个月后才拿到手，真是的。
拿到了vpn意味着以后可以早点下班，有事情在家里远程办公还是无休止的工作，休息即工作呢？
希望我不会把工作和生活混乱了。</p>

<p>拿到的vpn就3条信息，一个服务器ip，帐号，密码。也不说一下vpn服务器是用什么软件部署的，这让我怎么
挑客户端软件来连接呢？万一服务器和客户端所用的协议不一样我不是浪费时间吗。算了，都已经这么晚了
还是先随便试一个吧，如果有问题明天到了公司再说。</p>

<p>首先试的是pptp的客户端，因为这是使用最广泛的vpn协议了，虽然之前好像看到过这种通信的加密很弱，但是
没关系，又不发表反动言论。</p>

<p>首先要安装pptp的客户端，很简单，<code>sudo pacman -S pptpclient</code>。</p>

<p>然后需要配置一下vpn连接的参数，比如说服务器ip多少，帐号密码多少。最麻烦的方法莫过于手动改写配置文件了，但是
还好pptp自带了一个setup的功能，一条命令就可以创建vpn连接。
<code>pptpsetup --create my_tunnel --server vpn.example.com --username alice --password foo --encrypt</code>
把my_tunnel替换成一个隧道别名，以后就可以使用这个别名来连接指定的vpn服务器了。
在&ndash;server参数后改为需要连接的ip地址，作为公司内部访问才不会为vpn服务配置一个域名呢，又不是给外人开放使用，没必要好记。
在&ndash;username参数后面输入分配的用户名
然后回车执行这条命令就会提示输入密码，输入密码，ok如果没问题的话现在已经创建好了一个vpn连接，接下来需要做的就是启用这个连接。</p>

<p>直接<code>pon my_tunnel</code>就可以开启这个vpn连接了，然后输入<code>ifconfig</code>查看一下，如果出现了ppp0这个接口那就说明连接建立成功。</p>

<p>这时候试图访问公司内网，可是还是连接不上去，因为没有配置路由规则，默认情况下流量都走wlp3s0这个接口了，这是我的无线网卡的接口。
稍微配置一下公司服务器网段就行了，内部测试机是192.168.10.0/24的网段，所以在命令行输入<code>ip route add 192.168.10.0/24 dev ppp0</code>
然后就可以在本地通过ssh连接这个网段的机器了。</p>

<p>昨晚遇到一个紧急情况，又用了一下vpn，不知道为什么可以连接，也可以执行一些简单的命令，比如cd，ls，svn之类的，就是不能执行vim, cat这类命令，一查看某个文件
连接就会卡死，不得不在本地kill掉这个ssh会话，kill掉之后ppp0这个接口也自动关闭了，又得重新开一遍。不知道是什么原因。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[我的xmonad配置]]></title>
    <link href="http://xcaptain.github.io/blog/2014/09/08/my-xmonad-config/"/>
    <updated>2014-09-08T04:12:48+00:00</updated>
    <id>http://xcaptain.github.io/blog/2014/09/08/my-xmonad-config</id>
    <content type="html"><![CDATA[<p>xmonad是用haskell写的一个窗口管理器。所谓的窗口管理器和桌面环境最大的区别大概就是轻量和重量的区别吧。
之前用过gnome3, unity, kde4, xfce4等桌面环境，感觉功能和配置都差不多，而且额外安装了太多不必要的东西，
而且还很耗费系统资源。上个月在tumblr看到了某个人的xmonad桌面截图，感觉特别cool，所以开始折腾xmonad，不过
刚开始接触这种窗口管理器还是比较费劲的。</p>

<p>首先得安装xmonad，我现在用的是archlinux64位版本。可以用<code>sudo pacman -S xmonad</code>，安装好了可以执行<code>xmonad --version</code>
看看版本，我的事0.11的版本。每次启动xmonad的时候都会从<code>~/.xmonad/</code>里面读取配置，所以安装完了之后还得检查一下
是否自动生成了这个目录，一般安装成功之后都会出现的。</p>

<p>然后就是配置桌面管理器了，因为我之前用的是gnome3的桌面环境，所以默认使用的桌面管理器是gdm，我如果要在登陆的时候
选择进入那个桌面环境就得把这个地方配置好。首先增加一条xmonad的入口配置：</p>

<pre>
[Desktop Entry]
Encoding=UTF-8
Type=Application
Name=Xmonad
Comment=Lightweight X11 tiled window manager written in Haskell
Exec=xmonad
Icon=xmonad
Terminal=false
StartupNotify=false
Categories=Application;
</pre>


<p>登出系统，然后在登陆界面就会出现xmonad的选项了。默认登陆进去应该是黑乎乎一片，因为就开启了一个wm，什么应用都没有
开。这时候可以输入<code>Alt Shift Return</code>，如果一切正常的话这个快捷键会打开一个终端。ok，有了终端一切都ok了，可以想做任何
在linux都可以执行的操作，比如说打开pidgin聊天，firefox上网，thunderbird读邮件啊。</p>

<p>不过默认的配置确实不好用，还是得上网搜点优化了的配置，</p>

<pre>
--
-- xmonad example config file.
--
-- A template showing all available configuration hooks,
-- and how to override the defaults in your own xmonad.hs conf file.
--
-- Normally, you'd only override those defaults you care about.
--

import XMonad
import XMonad.Util.Run(spawnPipe)
import Data.Monoid
import System.Exit

import qualified XMonad.StackSet as W
import qualified Data.Map        as M

-- The preferred terminal program, which is used in a binding below and by
-- certain contrib modules.
--
myTerminal      = "urxvt"
--myTerminal      = "gnome-terminal"

-- Whether focus follows the mouse pointer.
myFocusFollowsMouse :: Bool
myFocusFollowsMouse = True

-- Whether clicking on a window to focus also passes the click to the window
myClickJustFocuses :: Bool
myClickJustFocuses = False

-- Width of the window border in pixels.
--
myBorderWidth   = 1

-- modMask lets you specify which modkey you want to use. The default
-- is mod1Mask ("left alt").  You may also consider using mod3Mask
-- ("right alt"), which does not conflict with emacs keybindings. The
-- "windows key" is usually mod4Mask.
--
myModMask       = mod4Mask

-- The default number of workspaces (virtual screens) and their names.
-- By default we use numeric strings, but any string may be used as a
-- workspace name. The number of workspaces is determined by the length
-- of this list.
--
-- A tagging example:
--
-- > workspaces = ["web", "irc", "code" ] ++ map show [4..9]
--
myWorkspaces = ["1:term","2:code","3:web","4:media"] ++ map show [5..9]

-- Border colors for unfocused and focused windows, respectively.
--
myNormalBorderColor  = "#7c7c7c"
myFocusedBorderColor = "#ffb6b0"

------------------------------------------------------------------------
-- Key bindings. Add, modify or remove key bindings here.
--
myKeys conf@(XConfig {XMonad.modMask = modm}) = M.fromList $

    -- launch a terminal
    [ ((modm .|. shiftMask, xK_Return), spawn $ XMonad.terminal conf)

    -- launch dmenu
    --, ((modm               ,xK_p     ), spawn "dmenu-with-yeganesh")
    , ((modm                ,xK_p     ), spawn "dmenu_run -nb black")

    -- launch firefox
    , ((modm                ,xK_f     ), spawn "firefox")

    -- launch chromium
    , ((modm                ,xK_h     ), spawn "chromium")

    -- launch thunderbird
    , ((modm                ,xK_t     ), spawn "thunderbird")

    -- lock screen
    , ((modm .|. controlMask, xK_l), spawn "xscreensaver-command -lock")

    -- screenshoot
    , ((modm, xK_s), spawn "select-screenshoot")

    -- grab the whole screen
    , ((modm .|. controlMask, xK_p), spawn "screenshoot")

    -- Mute volume
    , ((modm .|. controlMask, xK_m), spawn "amixer -q set Master toggle")

    -- Decrease volume
    , ((modm .|. controlMask, xK_j), spawn "amixer -q set Master 10%-")

    -- Increase volume
    , ((modm .|. controlMask, xK_k), spawn "amixer -q set Master 10%+")

    -- close focused window
    , ((modm .|. shiftMask, xK_c     ), kill)

     -- Rotate through the available layout algorithms
    , ((modm,               xK_space ), sendMessage NextLayout)

    --  Reset the layouts on the current workspace to default
    , ((modm .|. shiftMask, xK_space ), setLayout $ XMonad.layoutHook conf)

    -- Resize viewed windows to the correct size
    , ((modm,               xK_n     ), refresh)

    -- Move focus to the next window
    , ((modm,               xK_Tab   ), windows W.focusDown)

    -- Move focus to the next window
    , ((modm,               xK_j     ), windows W.focusDown)

    -- Move focus to the previous window
    , ((modm,               xK_k     ), windows W.focusUp  )

    -- Move focus to the master window
    , ((modm,               xK_m     ), windows W.focusMaster  )

    -- Swap the focused window and the master window
    , ((modm,               xK_Return), windows W.swapMaster)

    -- Swap the focused window with the next window
    , ((modm .|. shiftMask, xK_j     ), windows W.swapDown  )

    -- Swap the focused window with the previous window
    , ((modm .|. shiftMask, xK_k     ), windows W.swapUp    )

    -- Shrink the master area
    , ((modm,               xK_h     ), sendMessage Shrink)

    -- Expand the master area
    , ((modm,               xK_l     ), sendMessage Expand)

    -- Push window back into tiling
    , ((modm,               xK_t     ), withFocused $ windows . W.sink)

    -- Increment the number of windows in the master area
    , ((modm              , xK_comma ), sendMessage (IncMasterN 1))

    -- Deincrement the number of windows in the master area
    , ((modm              , xK_period), sendMessage (IncMasterN (-1)))

    -- Toggle the status bar gap
    -- Use this binding with avoidStruts from Hooks.ManageDocks.
    -- See also the statusBar function from Hooks.DynamicLog.
    --
    -- , ((modm              , xK_b     ), sendMessage ToggleStruts)

    -- Quit xmonad
    , ((modm .|. shiftMask, xK_q     ), io (exitWith ExitSuccess))

    -- Restart xmonad
    , ((modm              , xK_q     ), spawn "xmonad --recompile; xmonad --restart")

    -- Run xmessage with a summary of the default keybindings (useful for beginners)
--    , ((modm .|. shiftMask, xK_slash ), spawn ("echo \"" ++ help ++ "\" | xmessage -file -"))
    ]
    ++

    --
    -- mod-[1..9], Switch to workspace N
    -- mod-shift-[1..9], Move client to workspace N
    --
    [((m .|. modm, k), windows $ f i)
        | (i, k) <- zip (XMonad.workspaces conf) [xK_1 .. xK_9]
        , (f, m) <- [(W.greedyView, 0), (W.shift, shiftMask)]]
    ++

    --
    -- mod-{w,e,r}, Switch to physical/Xinerama screens 1, 2, or 3
    -- mod-shift-{w,e,r}, Move client to screen 1, 2, or 3
    --
    [((m .|. modm, key), screenWorkspace sc >>= flip whenJust (windows . f))
        | (key, sc) <- zip [xK_w, xK_e, xK_r] [0..]
        , (f, m) <- [(W.view, 0), (W.shift, shiftMask)]]


------------------------------------------------------------------------
-- Mouse bindings: default actions bound to mouse events
--
myMouseBindings (XConfig {XMonad.modMask = modm}) = M.fromList $

    -- mod-button1, Set the window to floating mode and move by dragging
    [ ((modm, button1), (\w -> focus w >> mouseMoveWindow w
                                       >> windows W.shiftMaster))

    -- mod-button2, Raise the window to the top of the stack
    , ((modm, button2), (\w -> focus w >> windows W.shiftMaster))

    -- mod-button3, Set the window to floating mode and resize by dragging
    , ((modm, button3), (\w -> focus w >> mouseResizeWindow w
                                       >> windows W.shiftMaster))

    -- you may also bind events to the mouse scroll wheel (button4 and button5)
    ]

------------------------------------------------------------------------
-- Layouts:

-- You can specify and transform your layouts by modifying these values.
-- If you change layout bindings be sure to use 'mod-shift-space' after
-- restarting (with 'mod-q') to reset your layout state to the new
-- defaults, as xmonad preserves your old layout settings by default.
--
-- The available layouts.  Note that each layout is separated by |||,
-- which denotes layout choice.
--
myLayout = tiled ||| Mirror tiled ||| Full
  where
     -- default tiling algorithm partitions the screen into two panes
     tiled   = Tall nmaster delta ratio

     -- The default number of windows in the master pane
     nmaster = 1

     -- Default proportion of screen occupied by master pane
     ratio   = 1/2

     -- Percent of screen to increment by when resizing panes
     delta   = 3/100


------------------------------------------------------------------------
-- Window rules:

-- Execute arbitrary actions and WindowSet manipulations when managing
-- a new window. You can use this to, for example, always float a
-- particular program, or have a client always appear on a particular
-- workspace.
--
-- To find the property name associated with a program, use
-- > xprop | grep WM_CLASS
-- and click on the client you're interested in.
--
-- To match on the WM_NAME, you can use 'title' in the same way that
-- 'className' and 'resource' are used below.
--
myManageHook = composeAll
    [ className =? "Urxvt"          --> doShift "1:term"
    , className =? "Chromium"       --> doShift "3:web"
    , className =? "Google-chrome"  --> doShift "3:web"
    , className =? "Firefox"        --> doShift "3:web"
    , className =? "Emacs"          --> doShift "2:code"
    , className =? "Gvim"           --> doShift "2:code"
    , className =? "Vlc"            --> doShift "4:media"
    , className =? "Weechat"        --> doShift "4:media"
    , className =? "Pidgin"         --> doShift "4:media"
    , className =? "ThunderBird"    --> doShift "4:media"
    , resource  =? "desktop_window" --> doIgnore
    , className =? "Galculator"     --> doFloat
    , className =? "Steam"          --> doFloat
    , className =? "Gimp"           --> doFloat
    , resource  =? "gpicview"       --> doFloat
    , className =? "MPlayer"        --> doFloat
    , className =? "Xchat"          --> doShift "4:media"
    , className =? "stalonetray"    --> doIgnore]



------------------------------------------------------------------------
-- Event handling

-- * EwmhDesktops users should change this to ewmhDesktopsEventHook
--
-- Defines a custom handler function for X Events. The function should
-- return (All True) if the default handler is to be run afterwards. To
-- combine event hooks use mappend or mconcat from Data.Monoid.
--
myEventHook = mempty

------------------------------------------------------------------------
-- Status bars and logging

-- Perform an arbitrary action on each internal state change or X event.
-- See the 'XMonad.Hooks.DynamicLog' extension for examples.
--
myLogHook = return ()

------------------------------------------------------------------------
-- Startup hook

-- Perform an arbitrary action each time xmonad starts or is restarted
-- with mod-q.  Used by, e.g., XMonad.Layout.PerWorkspace to initialize
-- per-workspace layout choices.
--
-- By default, do nothing.
myStartupHook = return ()

------------------------------------------------------------------------
-- Now run xmonad with all the defaults we set up.

-- Run xmonad with the settings you specify. No need to modify this.
--
main = do
     xmproc <- spawnPipe "xmobar ~/.xmonad/xmobar.hs"
     xmproc <- spawnPipe "feh --bg-fill ~/.xmonad/colorNana.png"
     xmonad $ defaults

-- A structure containing your configuration settings, overriding
-- fields in the default config. Any you don't override, will
-- use the defaults defined in xmonad/XMonad/Config.hs
--
-- No need to modify this.
--
defaults = defaultConfig {
      -- simple stuff
        terminal           = myTerminal,
        focusFollowsMouse  = myFocusFollowsMouse,
        clickJustFocuses   = myClickJustFocuses,
        borderWidth        = myBorderWidth,
        modMask            = myModMask,
        workspaces         = myWorkspaces,
        normalBorderColor  = myNormalBorderColor,
        focusedBorderColor = myFocusedBorderColor,

      -- key bindings
        keys               = myKeys,
        mouseBindings      = myMouseBindings,

      -- hooks, layouts
        layoutHook         = myLayout,
        manageHook         = myManageHook,
        handleEventHook    = myEventHook,
        logHook            = myLogHook,
        startupHook        = myStartupHook
    }
</pre>


<p>今天(2014年10月26日)，修改了一下xmonad的配置，加入了快捷键控制音量，自定义了几个快捷键来截图，加入了背景图，加入了xmonar的配置。以前一直没设置背景图导致每次开机之后都是一片黑的背景，现在漂亮多了。xmobar是从arckwiki上面找来的配置，很不错的一个状态栏，包含了cpu使用率，内存使用率，网络使用率等。</p>

<p>不过还是有点缺陷的，不能给每个桌面分配一个背景图真是遗憾，不然这样就漂亮了，用图片来标识各个桌面的作用。haskell还在学习中，将来还有得改的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Customize Keyboard Layout]]></title>
    <link href="http://xcaptain.github.io/blog/2014/08/25/customize-keyboard-layout/"/>
    <updated>2014-08-25T15:32:42+00:00</updated>
    <id>http://xcaptain.github.io/blog/2014/08/25/customize-keyboard-layout</id>
    <content type="html"><![CDATA[<p>星期天膜拜了一位大牛，真是佩服他啊。</p>

<p>公司的一个统计功能出问题了，一直都没有把它修复，因为是历史遗留问题，找不到根源，所以
后来公司领导决定把原来这个功能的开发者找回来看看到底是出什么问题了。所以星期天我也来
公司看了一下大牛如何解决问题。</p>

<p>因为数据是前端通过访问一个php的接口写入redis得到的，所以大牛一直在调试redis。读取redis
数据的代码是用python写的。用emacs编辑这个python文件，在旁边开着1个终端使劲调。不得不说
他是我见过的emacs用得最好的一个了，我自己从大二开始接触linux开始就一直在vim和emacs之间
切换着写代码，对emacs也算不陌生，但是我就不能一只手写代码。而且使用emacs对我来说真是煎熬，
因为ctrl键太远了，要用小拇指按住这个键真是太吃力了。不过后来发现他时而使用左半部分手掌
压住ctrl键，时而使用右侧的ctrl键，所以都没有见到他的手大幅度移动但是就按出了很多键。</p>

<p>emacs是用来编辑查看代码的，要监控程序还得通过终端输入命令行来操作。大牛只登陆了一个终端，
但是确打开了很多个窗口，后来才发现他是用tmux来虚拟化多个窗口的，说道这个又伤心了一下，最初
刚来公司的时候我不会用xshell，所以用的是putty来远程登陆服务器写代码，那时候就曾经接触过
一段时间tmux，因为putty实在是不好新建窗口，太麻烦。如果那时候一直用着tmux到现在我说不定也
很熟练了，不过后来办公彻底有windows转移到linux之后就更没有去接触tmux了，因为在linux终端
新建一个连接更容易，ctrl+shift+t就行了。不得不说tmux真是个好东西，省去了多次登陆的麻烦，
虚拟多个窗口，可以按照你想要的方式排列窗口，对于监控某个程序来说真是再合适不过了，下面的
窗口运行程序，上面的窗口输出运行结果。</p>

<p>还发现一个很好用的工具，watch，这个命令是用来监控某个命令的输出的，如果某个程序持续输出
了内容，拿它来监控再合适不过了，不然就得反复输命令查看结果了。</p>

<p>被感染了，我也要学习使用emacs，也要学习使用tmux和各种命令行，不能止步于已经掌握的内容，今晚
折腾了一下emacs，改了一个键盘映射，把恼人的ctrl键和caplock键换了个位置。因为我现在用的系统
是archlinux+gnome3.12，所以直接调用一个系统设置改的，找到tweak tool然后在typing里面选择
swap ctrl and caplock,然后就ok了，新的键盘不是很习惯，慢慢来，现在ctrl靠近键盘中间了以后
使用emacs写代码应该是更方便了吧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[不用密码ssh登陆服务器]]></title>
    <link href="http://xcaptain.github.io/blog/2014/08/21/ssh-login-without-password/"/>
    <updated>2014-08-21T15:50:42+00:00</updated>
    <id>http://xcaptain.github.io/blog/2014/08/21/ssh-login-without-password</id>
    <content type="html"><![CDATA[<p>今天又拿到了一台服务器的权限，才来到这个公司没多久现在算一下已经拿到很多机器的权限了，本地测试机有3台，都拥有root权限，
线上服务器有5台，有部分root权限。刚开始用xshell登陆服务器还没什么觉得不方便的，但是现在我已经完全使用linux办公了，所以
只能用terminal来ssh连接服务器。手动输入密码太麻烦了，而且还是经常性的输密码。</p>

<p>今天又花了点时间看了一下公钥加密的过程这块，了解了一个ssh连接的基本流程。ssh登陆有2种方法：</p>

<ol>
<li>基于密码的验证。</li>
<li>基于公钥私钥的验证。</li>
</ol>


<p>基于密码的验证很好理解，当连接服务器的时候会提示你输入密码，等验证通过之后就能连接远程服务器了。这种方法很好理解，但是其实
局限性是很大的，首先麻烦，每次登陆都得输密码，而一个安全的密码又不是那么好记。其次密码被暴露的次数越多就越不安全，万一哪一次
在输入密码的时候被中间人给截获了这个密码，那么就没有丝毫秘密可言了。</p>

<p>而基于公钥私钥的验证相比起来就安全多了，在服务器中保存一份你自己的公钥，服务器就会知道你是授权了的用户，客户端连接服务器的时候
会检查这个用户的公钥是否在授权了的公钥列表中，如果在的话就放行，允许登陆。登陆之后加密的方法就很简单了，服务器用客户端的公钥加密信息
后传给客户端，客户端收到这个加密的信息之后用自己的私钥解密。然后客户端给服务器发送信息，用服务器的公钥加密，服务器收到之后拿自己的
私钥解密。</p>

<p>所以总的来说ssh连接就是2步，一步是验证身份，剩下的就是交换公钥的加密数据传输。</p>

<p>因为我现在都是使用运维给我分配的帐号密码来登陆服务器，每次连接都得输入密码很不方便，所以我还是改为通过公钥来验证身份好了。</p>

<p>首先给自己生成一个公钥私钥对，使用<code>ssh-keygen</code>生成公钥和私钥对，一般的命名规则是id_rsa和id_rsa.pub， 默认使用的加密方法是rsa，
默认使用2048字节的私钥。然后就是把自己的公钥添加到服务器上，保存在<code>~/.ssh/authorized_keys</code>里面。具体实现方法有很多，可以直接复制粘贴进去，
可以把公钥文件传到服务器上，也可以用一个简单的命令<code>ssh-copy-id</code>,这样就可以绕过手动输入密码了。</p>

<p>真是搞不懂，运维们有这么好的方法不用为什么要给一个账户创建密码呢，直接向我要一个公钥，然后加到服务器就行了嘛。</p>
]]></content>
  </entry>
  
</feed>
