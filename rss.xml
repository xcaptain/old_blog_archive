<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Joey's blog</title>
    <link href="http://blog.iyue.club/rss.xml" rel="self" />
    <link href="http://blog.iyue.club" />
    <id>http://blog.iyue.club/rss.xml</id>
    <author>
        <name>Joey Xie</name>
        <email>joey.xf@gmail.com</email>
    </author>
    <updated>2015-12-10T00:00:00Z</updated>
    <entry>
    <title>博客从octopress迁移到hakyll</title>
    <link href="http://blog.iyue.club/posts/2015-12-10-switch-to-hakyll.html" />
    <id>http://blog.iyue.club/posts/2015-12-10-switch-to-hakyll.html</id>
    <published>2015-12-10T00:00:00Z</published>
    <updated>2015-12-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="准备完全迁移到hakyll上面了">准备完全迁移到hakyll上面了</h3>
<p>之前的博客是使用octopress搭建的，这个静态站点生成器最大的好处就是简单，不需要自己额外的hack，装好octopress，简单设置好之后就能使用，而且提交，部署都有 现成的工具，主题也有很多，所以一用就用了一年多。从7月份开始就有点厌倦octopress了，因为不喜欢这么傻瓜式的东西，咱们的目标是to be a geeker，当然不能一直 不进步。hakyll算是非常极客的一个工具了，haskell写的，使用pandoc处理文本，而且配置文件完全是haskell代码，想着能用这么geek的语言，玩这么geek的软件，就 非常激动。</p>
<p>使用hakyll也非常简单，步骤是:</p>
<ol style="list-style-type: decimal">
<li><code>cabal install hakyll</code> 安装hakyll，这一步非常耗时，因为自己的笔记本CPU落伍了。</li>
<li><code>hakyll-init blog</code> 会在当前目录下创建一个叫作blog的目录。</li>
<li><code>cd blog</code> 进入这个目录，会发现有一系列文件，这是默认的博客站点。</li>
<li><code>cabal build</code> 默认会build这个haskell站点，生成站点可执行文件。</li>
<li><code>dist/build/site/site build</code> 会编译<code>posts/</code>下面的文件，生成html文件到<code>_site/posts/</code>下面。</li>
<li><code>dist/build/site/site watch</code> 会开启一个web服务器，默认访问地址是http://127.0.0.1:4000/ 点击访问，然后就你发现默认的首页了。</li>
<li>默认站点好了接下来就是迁移原博客的文章，从原来的git仓库中把所有的markdown文件复制到<code>posts/</code>下面。</li>
<li>再次试着build整个站点，这时候可能会有点问题，我这里因为有的文章元数据中categories:熟悉为空报了几个错，改完就好了。</li>
<li>配置博客站点，修改站点外观，添加rss和tag页，我用的是<a href="https://github.com/eakron/variadic.me">variadic</a>的配置，很简单，配置文件改动很小但是 却把我要的功能都实现了，真的很厉害。</li>
<li>再次build，并且watch新的项目，顺利跑通了之后，但是看不到标签，很奇怪，原来老的文章是使用categories作为标签名的，现在使用tags了，自然要改。 <code>sed -i 's/categories\:/tags\:/g'</code> 一行sed命令，批量替换，真不错。</li>
<li>博客在本地搭好了，并且预览过了，接下来就是部署到线上，还是用github-pages。那么我就需要2个分支，一个source分支用来存放静态站点的代码，包括站点 配置，原始markdown格式的博文，这样将来要换到别的机器上，直接clone source分支的代码下来build就行了。还有一个分支是master分支，这个分支存放build之后 的文件，也就是所有的静态文件，html, css, js, 图片等。因为我线上已经有一个博客站点了，所以只需要添加远程github仓库就行。 <code>cd blog</code>进入我的博客根目录，执行<code>git init .</code> 添加版本控制, <code>git add .</code>, <code>git commit -m 'first commit'</code>, <code>git checkout -b source</code>切换到 source分支，然后删掉master分支<code>git branch -d master</code>，因为代码只要保存在source，master只能放生成的静态文件。<code>git remote add origin git@github.com:xcaptain/xcaptain.github.io</code>添加我的远程仓库， 要注意编辑.gitignore文件，把_site, _tmp, _cache都忽略掉。然后是<code>git submodule add git@github.com:xcaptain/xcaptain.github.io.git _site/</code>把 线上的master分支作为我的一个模块，克隆到_site目录下。再执行一下<code>dist/build/site/site build</code>会生成新的静态文件写入_site/目录，当然那些老的文件不会被 删掉，比如说我之前的CNAME文件，favicon文件都还留着，这时候<code>cd _site/</code>然后再提交一下。本地所有的代码都干净之后就是推送部署了。在<code>blog/</code>目录下执行 <code>git push origin source</code>把当前分支推送到origin的source分支，然后再切换到<code>_site/</code>目录，执行<code>git push origin master</code>把生成的静态文件推送到线上的 master分支。访问<a href="http://blog.iyue.club" class="uri">http://blog.iyue.club</a>开测，真不错。</li>
</ol>
<p>虽然说没有了octopress那么多做好的功能，但是通过折腾hakyll学习到了很多知识，等以后优化这个部署流程的时候可以自己写脚本部署，省得总是自己多次写shell命令</p>]]></summary>
</entry>
<entry>
    <title>php使用rabbitmq队列处理数据推送</title>
    <link href="http://blog.iyue.club/posts/2015-09-14-php-use-rabbitmq.html" />
    <id>http://blog.iyue.club/posts/2015-09-14-php-use-rabbitmq.html</id>
    <published>2015-09-14T00:00:00Z</published>
    <updated>2015-09-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="使用rabbitmq作为消息队列软件">使用rabbitmq作为消息队列软件</h2>
<h3 id="为什么使用rabbitmq">为什么使用rabbitmq</h3>
<h3 id="可选的队列软件">可选的队列软件</h3>
<h3 id="安装及配置rabbitmq">安装及配置rabbitmq</h3>
<h2 id="使用eloquent来操作模型">使用Eloquent来操作模型</h2>
<h3 id="为什么使用eloquent">为什么使用Eloquent</h3>
<ol style="list-style-type: decimal">
<li><p>Propel</p></li>
<li><p>Doctrine2</p></li>
<li><p>eloquent</p></li>
</ol>
<h3 id="eloquent处理sharding">eloquent处理sharding</h3>
<h2 id="处理拉取逻辑">处理拉取逻辑</h2>
<h3 id="表结构设计">表结构设计</h3>
<h3 id="如何获得最新的信息流">如何获得最新的信息流</h3>]]></summary>
</entry>
<entry>
    <title>学习使用postgresql</title>
    <link href="http://blog.iyue.club/posts/2015-07-22-use-postgresql.html" />
    <id>http://blog.iyue.club/posts/2015-07-22-use-postgresql.html</id>
    <published>2015-07-22T00:00:00Z</published>
    <updated>2015-07-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>对mysql有点厌倦了，因为用的人多就会导致产品趋于平凡，就算是mariadb也是一样，所以有必要了解一下postgresql。</p>
<p>首先讲讲postgresql的安装配置吧，我是从<a href="https://wiki.debian.org/PostgreSql">debian官方</a>上面找到的wiki， 操作很简单，但是首先就感觉postgresql和mysql的设计哲学有点区别。要让一个用户能够访问pgsql的数据库，首先得在 操作系统上面创建对应的用户，然后用postgres这个默认的超级用户去连接默认的postgres数据库，连接上之后再在服务器 里面创建一个同名的用户，然后是创建一个数据库，然后是分配数据库访问权限，感觉这个过程很繁琐而且有点反人类。像 mysql是不需要在操作系统上面创建用户的，直接create user就可以，然后设置密码，分配数据库访问权限。</p>
<p>接下来就是具体如何操作postgresql了，这部分得慢慢来，毕竟我刚学着用。</p>]]></summary>
</entry>
<entry>
    <title>php编码规范</title>
    <link href="http://blog.iyue.club/posts/2015-07-14-php-coding-style.html" />
    <id>http://blog.iyue.club/posts/2015-07-14-php-coding-style.html</id>
    <published>2015-07-14T00:00:00Z</published>
    <updated>2015-07-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>之前写代码的时候一直不是很在意编码规范的问题，感觉只要把代码功能实现了就OK，但是看到越来越多的优秀开 源项目都给自己的项目制定了编码规范，提交PR必须要满足规范才能合并到主干，而且自己搞php开发也已经有1 年了，得开始走向规范化开发的道路。</p>
<p>首先得介绍一下psr2，目前<a href="http://laravel.com/">laravel</a>项目使用的就是这个风格标准，具体的规定 在<a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md">这里</a> 我以前的习惯大部分符合psr2的标准，但是因为渐渐的使用到了很多高级的php特性，比如说closure, trait, 抽象类等， 所以还是得纠正一点小的习惯。</p>
<p>除了psr2这个标准之外，各大公司也有自己内部使用的标准，比如说symfony, wordpress, squiz等，还是靠拢 国际标准吧，目前我的emacs里面的php-mode的设置就是psr2的标准，自动格式化代码省了点心。</p>
<p>代码写完了之后提交到github上却总是发现过不了持续集成(Continuous Integration)的审核，我自己目前几个个人 项目使用的是<a href="https://styleci.io/">styleci</a>这个在线审核的工具，功能很简单但是很强大，最初几次提交 总是会给我返回很多fail，导致严格要求自己按照编码规范来。</p>
<p>为了避免提交之后被styleci给鄙视，从网上找到了<a href="https://github.com/squizlabs/PHP_CodeSniffer">PHP_CodeSniffer</a>这个 小工具，叫做php嗅探器，它其实包括2个小部件，一个是phpcs(php coding style)，另一个是phpcbf(PHP Code Beautifier and Fixer)， 前者只检查代码的问题，后者还会帮忙纠正代码，如果信不过机器帮忙纠正代码，那么之前一定的记得提交代码。根据官方文档上的 说明修改配置，简单使用，效果很不错。后来我又找了一个叫做<a href="https://github.com/nishimaki10/emacs-phpcbf">emacs-phpcbf</a>的 小工具，这个是一个emacs的插件配置好之后可以集成到php-mode里面，稍加配置就可以在保存php文件的时候自动纠正错误。</p>
<p>后面发现通过phpcbf纠错的代码还是不能通过styleci，找了一下发现styleci用的是一个叫做<a href="https://github.com/FriendsOfPHP/PHP-CS-Fixer">php-cs-fixer</a> 的引擎来审核代码的，又对照着装了一个php-cs-fixer，和phpcbf的功能差不多，但是稍微严格一点，对于额外的空行也会删掉。</p>
<p>码农要往正规化方向走，现在养成一下编码规范的习惯，以后再来培养测试驱动的习惯。</p>]]></summary>
</entry>
<entry>
    <title>迁移一个discuz站点</title>
    <link href="http://blog.iyue.club/posts/2015-06-23-migrate-a-discuz-site.html" />
    <id>http://blog.iyue.club/posts/2015-06-23-migrate-a-discuz-site.html</id>
    <published>2015-06-23T00:00:00Z</published>
    <updated>2015-06-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>周五晚上帮同事迁移了一个网站，原来的<a href="http://www.huizu100.com">网站</a>是搭建在windows2003服务器上的，使用的是apache2 + php5.3 + mysql5.1 的架构，使用的是一个叫作PHPnow的一键安装包来管理服务器的，这种架构对于个人站长来说很方便，只要设置好了配置就可以自己搭建网站，但是扩展性特别差，简直就是没法维护，win2003本来就是老掉牙的技术了，这种服务器长期跑肯定是会有内存问题的，而用PHPnow搭建的网站，数据库，代码，数据都在一个目录里面，这样潜在的问题太大了，首先就是安全性问题，没有数据库本来应该单独放到一个专门的服务器上的。而且所有数据放在一起对于业务分离，备份也很不方便，一下备份一个几十G大的目录是很浪费资源的。</p>
<p>所以在我的建议下，周五晚上对这个网站做了一个迁移，新的架构是LNMP，ubuntu 15.04 server + nginx 1.6 + hhvm 3.7 + mariadb 10.0.20 + redis 3.0，当然因为服务器只有一台，所以没有做负载均衡，没有做数据库读写分离，也没有做hhvm的均衡，因为等我把环境搭建完的时候就已经很稳定了，所以暂时不打算那么做，下面简单的来说说迁移过程。</p>
<ol style="list-style-type: decimal">
<li><p>服务器安装 我给的建议是装ubuntu，因为将来环境稳定下来之后要把权限分给站长，让他自己上去查看管理一些进程，而ubuntu的桌面又是比较简单易用的。本来他们是打算安装ubuntu 15.04 desktop版的，但是因为这个版本没法驱动DELL r710服务器自带的硬Raid，所以最后换成server版了。</p></li>
<li><p>nginx，mariadb，hhvm，redis这些软件的安装都很简单，唯一一个比较特殊的功能就是用了hhvm来替换php，不过暂时没有感到太大的性能提升。LNMP环境搭建是很简单的，很快就完成了。</p></li>
<li><p>接下来是服务器配置 最大的问题就是调整分区结构，服务器上有一块300G的自带硬盘，这款盘其实是由2块一样的硬盘搭建的raid0，自带了数据备份功能，所以这块盘理论上来说是不该保存太多系统以外的东西的。然后是1块1T的绿盘，这块盘的年头比较老了，以前的网站就部署在这块盘上，我打算把这个盘拿来当备份盘，还有一块2T的黑盘，这块盘是一块最新最好的数据盘，所以我打算把网站和数据库都放在这块盘上。首先要把这块2T的盘里面的数据备份了，很重要的资料一定得保存，但是里面用PHPNow的工具全量备份了站点，一个备份40G，备份一周的数据，复制这些内容浪费了好多时间。数据备份完了之后就是给硬盘分区，先分区那块2T的盘，准备分4个区，按照300+300+600+600来分，虽然暂时没有想好具体怎么使用，用<code>fdisk /dev/sdb</code>开始分区，分区之后就是创建文件系统，只用ext4，所以<code>mkfs.ext4 /dev/sdbn</code>。</p></li>
<li><p>部署网站 这步就很简单了，直接复制代码，修改配置，修改权限，有一个比较大的问题是discuz的图片是存放在一个叫做<code>data/attachment</code>的目录下的，这些图片完全可以和代码分离，所以拿一块额外的分区来装就行，我是挂载的那个600G的分区到这个目录的。<code>mount /dev/sdb6 /pathtodata/attachment</code>。</p></li>
</ol>
<p>部署完成之后调试了一下网站就跑起来了，但是还有很多要做的事，discuz的代码结构比较混乱，不好改动，而且原来他的网站语言设置是GBK的，涉及到编码问题又更加复杂了，反正直到周日晚上才把问题全部解决，目前就是陆陆续续做一些服务器的小性能调优。</p>
<p>6月25日更新： 这几天陆陆续续发现了一些bug，有样式错误的，有插件报错的，有缓存不能及时清的等等，突然感觉压力好大，工作日只能下班之后有时间做自己的事，端午节3天假2天加一晚上都折腾那个网站去了，本以为是没什么事了，没想到后续的问题更多更麻烦，早知道就不轻易答应人家了，而且以后坚决不再折腾discuz，继续折腾这个东西只会浪费我更多时间。</p>]]></summary>
</entry>
<entry>
    <title>学习git</title>
    <link href="http://blog.iyue.club/posts/2015-06-01-learn-git.html" />
    <id>http://blog.iyue.club/posts/2015-06-01-learn-git.html</id>
    <published>2015-06-01T00:00:00Z</published>
    <updated>2015-06-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>继续学习git，把统计后台的代码从内部git服务器迁移到github上面了，用的是自己的私有仓库。</p>
<p>目前主要用到的功能有：</p>
<ol style="list-style-type: decimal">
<li><p>添加远程仓库 <code>git remote add origin https://github.com/xcaptain/simple-admin.git</code> 这样就能添加一个远程仓库了，等以后把代码push上去就行了，访问远程仓库的方式有2种，一种是ssh，一种是https，上面这种是https的仓库，也是github默认的访问仓库的方法， 因为ssh太不安全了，对于我们这种生活在封锁国度的老百姓来说，很容易被屏蔽。</p></li>
<li><p>往远程仓库里面提交代码 <code>git commit -m 'some comment'</code> 这样就可以提交代码，返回一个hash值标识的版本号，提交之后代码版本还在本地，如果要多方合作开发，那就得把改动保存到一个大家都可以访问的远程仓库， <code>git push origin master</code>，把本地版本推送到远程的master分支。</p></li>
<li><p>建立本地分支 <code>git branch dev</code> 这样就在本地创建了一个叫做dev的分支，并且会自动切换到这个dev分支，如果建了好多个分支，想查看当前自己在哪个分支，直接<code>git branch</code>就会列出，当然如果使用的是zsh或者是 fish这样的shell，一般都会有git的插件，可以显示当前所在分支。</p></li>
<li><p>把本地分支添加到远程仓库 <code>git checkout dev</code>切换到dev分支，然后<code>git push origin dev</code>就可以把代码推送到远程仓库的dev分支了。</p></li>
<li><p>打标签 <code>git tag</code>可以查看当前版本库的所有标签信息，如果要添加标签，那么就是<code>git tag -a v0.2 -m '优化流量统计代码，统一风格'</code>添加一个叫作v0.2的标签，并且提交。如果要把 本地的标签信息提交到远程仓库，那么就是<code>git push --tags</code>，然后去github上查看就能看到对应的v0.2版本了。</p></li>
<li><p>查看提交版本 <code>git log</code>, <code>git diff</code>，我一般喜欢用emacs的magit插件来查看diff和版本。</p></li>
<li><p>把未暂存的文件回滚 <code>git checkout file1</code>，这样会从版本库中检出上一个提交的file1的版本，覆盖掉当前这个未提交的版本。</p></li>
<li><p>回滚版本库 这个操作目前做得比较少，都是<code>git reset --hard HEAD~1</code>，来回到上一个版本的，对于这个操作还不熟悉，至少svn回滚已经是很熟悉的了。</p></li>
</ol>
<p>git的功能很强大也很复杂，但是一定是要掌握的，这样才能成为一个合格的项目经理，以后慢慢积累，有新的体会再来更新这篇博客。</p>]]></summary>
</entry>
<entry>
    <title>php的getter方法</title>
    <link href="http://blog.iyue.club/posts/2015-05-23-php-getter.html" />
    <id>http://blog.iyue.club/posts/2015-05-23-php-getter.html</id>
    <published>2015-05-23T00:00:00Z</published>
    <updated>2015-05-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>这几天做统计后台频繁用到一个叫做<a href="http://carbon.nesbot.com/">Carbon</a>的日期库，用多了发现这个库的接口设计得非常方便，方法非常自然，稍微用几次就知道用法了。比如说好多方法都是静态方法，省去了频繁构造对象的开销。最方便的还是里面的getter方法，<code>$dt-&gt;year</code>就返回了本年，这个year很明显是一个静态方法，因为$dt不是new出来的对象，但是我们看起来就好像是直接访问一个类的属性一样。</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> <span class="kw">A</span> {
    <span class="kw">public</span> <span class="kw">function</span> year<span class="ot">()</span> {
        <span class="kw">return</span> <span class="dv">2015</span><span class="ot">;</span>
    }
    <span class="kw">public</span> <span class="kw">static</span> <span class="kw">function</span> <span class="fu">__get</span><span class="ot">(</span><span class="kw">$var</span><span class="ot">)</span> {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;<span class="kw">$var</span><span class="ot">();</span>
    }
}
a = <span class="kw">new</span> <span class="kw">A</span><span class="ot">;</span>
<span class="fu">echo</span> a-&gt;year<span class="ot">;</span></code></pre></div>
<p>是getter的一种简单写法，挺不错的。</p>]]></summary>
</entry>
<entry>
    <title>mysql基础</title>
    <link href="http://blog.iyue.club/posts/2015-05-03-mysql-basics-1.html" />
    <id>http://blog.iyue.club/posts/2015-05-03-mysql-basics-1.html</id>
    <published>2015-05-03T00:00:00Z</published>
    <updated>2015-05-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>五一第二天泡国图看了一下午关于sql的书，小有所获，才发现以前工作中用到的只是mysql中的一个很小的子集，该好好整理一下了基础知识了，当然对于很基本，已经用得很熟练的知识就不提了。</p>
<h3 id="什么是sql语言">什么是sql语言</h3>
<p>sql语言包括： DDL（数据定义语言）：创建数据库，创建表，创建视图，创建索引等。 DML（数据操作语言）：也就是增删改查操作。 DCL（数据控制语言）：COMMIT，ROLLBACK，GRANT等。</p>
<h3 id="聚合查询">聚合查询</h3>
<p>聚合查询指的是把一张表的内容分组，相关操作包括<code>count</code>, <code>sum</code>, <code>min</code>, <code>max</code>, <code>avg</code>, <code>group by</code>, <code>having</code>，前面5个是聚合函数，从一大串结果中取出我们要的属性。 后面2个是分组的。<code>group by</code>的语法为:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> &lt;col1&gt;, &lt;col2&gt;, &lt;col3&gt;
    <span class="kw">from</span> &lt;table_name&gt;
[<span class="kw">where</span> ...]
<span class="kw">group</span> <span class="kw">by</span> &lt;col1&gt;, &lt;col2&gt;, &lt;col3&gt;
[<span class="kw">having</span> ...]</code></pre></div>
<p>有一条限制说的是select子句中的每一个字段都必须出现在group by的子句中，但是我在mysql和postgresql中执行的时候结果确不一样，pgsql有这个限制，而mysql则松散得多。在我看来必须得严格才行，不然在有1对多关系的表中，group by之后的结果可能会让人莫名其妙，难怪很多人都说postgresql比mysql要严谨。</p>
<h3 id="事务">事务</h3>
<p>事务指的是把一系列操作封装在一起来执行，要么同时执行这一些列操作，要么一个都不执行。这个以前工作也用到的不多，可能公司是以前写代码的人对于这个也不看中吧，基本上都是直接update，insert了。记得以前用python的<code>MySQLdb</code>的时候，如果有插入操作必须手动调用一下commit方法才能把数据写进数据库，那时候还不理解，感觉多了一步操作实在是太麻烦了，现在看来把所有操作都看作事务来执行，手动提交事务对于数据来说还是很安全的。</p>
<p>事务有4个特性：（ACID）</p>
<ol style="list-style-type: decimal">
<li>原子性（Atomic）：事务是一个整体。</li>
<li>一致性（Consistency）：每个操作都必须满足对应列的约束条件。</li>
<li>隔离性（Isolation）：没一个事务中的数据对另一个事务都是不可见的，在提交操作之前，数据不在表里面。</li>
<li>持久性（Duration）：每个事务完成之后会有日志记录，方便从日志恢复数据。</li>
</ol>
<p>创建事务：</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">start</span> | <span class="kw">begin</span> <span class="kw">transaction</span>
sql1;
sql2;
...
<span class="kw">commit</span></code></pre></div>
<p>现在仔细想想原来看过好多同时更新多张表的代码没有走事务，那些业务真是太危险了，一张表的结构出错可能就导致整个业务逻辑崩溃。</p>
<h3 id="视图">视图</h3>
<p>视图类似与一张表，但是区别是表里面存放着数据，但是视图里面没有数据。可以用</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">create</span> <span class="kw">view</span> &lt;视图名&gt; [&lt;col1&gt;, &lt;col2&gt;]
<span class="kw">as</span>
<span class="kw">select</span> &lt;col1&gt;, &lt;col2&gt; ...
    <span class="kw">from</span>
&lt;表名&gt;</code></pre></div>
<p>来创建一个视图。视图主要是为调用很频繁的sql做的，省得每次都得写一大段sql，视图还可以层叠，也就是cascade，不过这功能又太偏了，单用view就已经很少了。不过不知道在view中执行查询有没有比直接在表中查询快，如果仅仅是为了sql简洁就发明视图这个概念出来那也太浪费了吧。</p>
<p>视图是子查询的基础，子查询可以看作是一个视图。</p>
<h3 id="表的集合操作">表的集合操作</h3>
<p>表在关系代数中其实就是集合，所以可以交集，并集，查集。</p>
<h3 id="表连结">表连结</h3>
<p>以前大学的时候学离散数学，数据库原理都讲了关系代数，但是才刚刚毕业一年就几乎忘光了，到目前只知道内联接外联接，连用形式化语言来描述连接都做不到，实在是辜负大学四年了，不过现在做应用开发，基本的理论知识看起来又有点鸡肋。</p>
<p>连接分为内联接，外联接。 inner join &lt;=&gt; join left outer join &lt;=&gt; left join right outer join &lt;=&gt; right join 尽量避免直接写outer join，这样会使语义模糊。</p>
<h3 id="基本查询惯例">基本查询惯例</h3>
<ol style="list-style-type: decimal">
<li>建表的时候用<code>primary key(id)</code>来创建主键，以前我都是喜欢写在一个列的限制性约束条件后面。</li>
<li>在表明不相等关系的时候使用<code>&lt;&gt;</code>而不是<code>!=</code>，前者才是标准写法。</li>
<li><code>char</code>类型是按照字典顺序来排序的，一直以来我都以为是按照ascii的顺序来排的。</li>
<li>在建表的时候尽量避免使用NULL这个变量，因为在查询中空值比较不好处理，不好比较大小，不好做运算，不好count，我也不打算去研究NULL在各种情况下的意义。判断一个字段是否为NULL用<code>IS NULL</code>来判断。</li>
</ol>]]></summary>
</entry>
<entry>
    <title>一个简单的元编程的例子</title>
    <link href="http://blog.iyue.club/posts/2015-04-17-php-meta-programming-1.html" />
    <id>http://blog.iyue.club/posts/2015-04-17-php-meta-programming-1.html</id>
    <published>2015-04-17T00:00:00Z</published>
    <updated>2015-04-17T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>去年在学习ruby的时候就看到了很多元编程的例子，用一个方法来生成多个类似的方法，避免制造重复的代码，ruby用的是method_missing来实现的。</p>
<p>今天工作遇到一个小问题，需要写一个简单的脚本来统计某个时间段用户的发帖信息，需求很简单要实现也很简单。最初的设计见下面：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> UpdateUserRank {
<span class="kw">public</span> <span class="kw">function</span> <span class="fu">__construct</span><span class="ot">()</span> {}
<span class="kw">public</span> <span class="kw">function</span> getDayRank<span class="ot">(</span><span class="kw">$num</span><span class="ot">)</span> {}
<span class="kw">public</span> <span class="kw">function</span> getMonthRank<span class="ot">(</span><span class="kw">$num</span><span class="ot">)</span> {}
<span class="kw">public</span> <span class="kw">function</span> getAllRank<span class="ot">(</span><span class="kw">$num</span><span class="ot">)</span> {}

<span class="kw">public</span> <span class="kw">function</span> setDayRank<span class="ot">()</span> {}
<span class="kw">public</span> <span class="kw">function</span> setMonthRank<span class="ot">()</span> {}
<span class="kw">public</span> <span class="kw">function</span> setAllRank<span class="ot">()</span> {}
}</code></pre></div>
<p>需要写3个get方法，3个set方法，这种形式实在是太不方便维护了，每个函数的功能类似，而且函数名也类似，有没有什么办法能够不要写这么多函数呢？利用php的<code>__call</code>方法可以很简单的实现</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> UpdateUserRank {
<span class="kw">public</span> <span class="kw">function</span> <span class="fu">__construct</span><span class="ot">()</span> {
    <span class="kw">$this</span>-&gt;getMethods = <span class="fu">array</span><span class="ot">(</span><span class="st">&#39;getDayRank&#39;</span><span class="ot">,</span> <span class="st">&#39;getMonthRank&#39;</span><span class="ot">,</span> <span class="st">&#39;getAllRank&#39;</span><span class="ot">);</span>
    <span class="kw">$this</span>-&gt;setMethods = <span class="fu">array</span><span class="ot">(</span><span class="st">&#39;setDayRank&#39;</span><span class="ot">,</span> <span class="st">&#39;setMonthRank&#39;</span><span class="ot">,</span> <span class="st">&#39;setAllRank&#39;</span><span class="ot">);</span>
}
<span class="kw">public</span> <span class="kw">function</span> <span class="fu">__call</span><span class="ot">(</span><span class="kw">$name</span><span class="ot">,</span> <span class="kw">$args</span><span class="ot">)</span> {
    <span class="kw">if</span><span class="ot">(</span><span class="fu">in_array</span><span class="ot">(</span><span class="kw">$name</span><span class="ot">,</span> <span class="kw">$this</span>-&gt;getMethods<span class="ot">))</span> {
        <span class="kw">$num</span> = <span class="kw">$args</span><span class="ot">[</span><span class="dv">0</span><span class="ot">];</span>
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;redis-&gt;zrevrange<span class="ot">(</span><span class="kw">$this</span>-&gt;_key<span class="ot">(</span><span class="kw">$name</span><span class="ot">),</span> <span class="dv">0</span><span class="ot">,</span> <span class="kw">$num</span><span class="ot">,</span> <span class="kw">true</span><span class="ot">);</span>
    } <span class="kw">elseif</span><span class="ot">(</span><span class="fu">in_array</span><span class="ot">(</span><span class="kw">$name</span><span class="ot">,</span> <span class="kw">$this</span>-&gt;setMethods<span class="ot">))</span> {
        <span class="kw">$nowtime</span> = <span class="fu">time</span><span class="ot">();</span>
        <span class="kw">if</span><span class="ot">(</span><span class="kw">$name</span> == <span class="st">&#39;setDayRank&#39;</span><span class="ot">)</span> {
            <span class="kw">$ago</span> = <span class="kw">$nowtime</span> - <span class="dv">24</span> * <span class="dv">3600</span><span class="ot">;</span>
            <span class="kw">$key</span> = <span class="st">&#39;getDayRank&#39;</span><span class="ot">;</span>
        } <span class="kw">elseif</span><span class="ot">(</span><span class="kw">$name</span> == <span class="st">&#39;setMonthRank&#39;</span><span class="ot">)</span> {
            <span class="kw">$ago</span> = <span class="kw">$nowtime</span> - <span class="dv">24</span> * <span class="dv">3600</span> * <span class="dv">30</span><span class="ot">;</span>
            <span class="kw">$key</span> = <span class="st">&#39;getMonthRank&#39;</span><span class="ot">;</span>
        } <span class="kw">else</span> {
            <span class="kw">$ago</span> = <span class="dv">0</span><span class="ot">;</span>
            <span class="kw">$key</span> = <span class="st">&#39;getAllRank&#39;</span><span class="ot">;</span>
        }
        <span class="kw">$sql</span> = <span class="st">&quot;select authorid, count(authorid) as threadnum from dz_forum_thread where dateline between </span><span class="kw">$ago</span><span class="st"> and </span><span class="kw">$nowtime</span><span class="st"> group by authorid&quot;</span><span class="ot">;</span>
        <span class="kw">$sth</span> = <span class="kw">$this</span>-&gt;<span class="kw">pdo</span>-&gt;prepare<span class="ot">(</span><span class="kw">$sql</span><span class="ot">);</span>
        <span class="kw">$sth</span>-&gt;execute<span class="ot">();</span>
        <span class="kw">while</span><span class="ot">(</span><span class="kw">$row</span> = <span class="kw">$sth</span>-&gt;fetch<span class="ot">(</span><span class="kw">PDO</span>::<span class="kw">FETCH_ASSOC</span><span class="ot">))</span> {
            <span class="kw">$authorid</span> = <span class="kw">$row</span><span class="ot">[</span><span class="st">&#39;authorid&#39;</span><span class="ot">];</span>
            <span class="kw">$threadnum</span> = <span class="kw">$row</span><span class="ot">[</span><span class="st">&#39;threadnum&#39;</span><span class="ot">];</span>
            <span class="kw">$this</span>-&gt;redis-&gt;zAdd<span class="ot">(</span><span class="kw">$this</span>-&gt;_key<span class="ot">(</span><span class="kw">$key</span><span class="ot">),</span> <span class="kw">$threadnum</span><span class="ot">,</span> <span class="kw">$authorid</span><span class="ot">);</span>
        }
    } <span class="kw">else</span> {
        <span class="fu">echo</span> <span class="st">&quot;不合法的方法: &quot;</span> . <span class="kw">$name</span> . <span class="st">&quot;</span><span class="kw">\n</span><span class="st">&quot;</span><span class="ot">;</span>
        <span class="fu">exit</span><span class="ot">(</span><span class="dv">1</span><span class="ot">);</span>
    }
}
}</code></pre></div>
<p>调用一个类里面的方法时，如果在当前类没有找到这个方法就会逐层往父类查找，直到找到对应的方法，但是如果这个类或者是父类定义了<code>__call</code>方法，则能自动处理找不到的方法，接受2个参数，第一个是函数名，第二个是函数名传过来的参数，是一个数组。基本上可以说<code>__call</code>实现了<code>method not defined</code>这个异常的处理吧。</p>
<p>因为php的正则没有ruby简单，所以在这里我先定义了2个数组，对象调用的方法必须在这2个数组中才能执行，否则就报不合法的方法，然后退出，也许还可以通过<code>__get</code>, <code>__set</code>来实现，谁知道呢？</p>]]></summary>
</entry>
<entry>
    <title>btrfs损坏之后的一系列麻烦</title>
    <link href="http://blog.iyue.club/posts/2015-03-26-btrfs-crash.html" />
    <id>http://blog.iyue.club/posts/2015-03-26-btrfs-crash.html</id>
    <published>2015-03-26T00:00:00Z</published>
    <updated>2015-03-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>上周六晚上玩电脑的时候忘记插上电源了，直接导致笔记本意外断电关机，本来这只是一件小事，重启电脑即可，个人电脑一般没有多大的磁盘IO，数据基本都是在内存中读写的，但是等我重启电脑的时候却发现没法进系统了，一直卡在fsck那步，然后就是一直提示出现多少个<code>block error</code>，心立刻亮了半截，我用的arch没有做备份，如果硬盘损坏，里面的重要文件就都没了。于是重启进入win8下载了一个system-rescue-cd打算进入livecd修复分区，进去之后执行<code>btrfs check --repair /dev/sda3</code>，倒是检查出了一个块错误，但是没有修复，尝试重启电脑，结果出现<code>bad super block, unknown fs</code>，似乎问题加重了，上网搜了一下superblock损坏的话要找备份的superblock来替换，但是我没有定时做文件系统备份，行不通，后来尝试给<code>btrfs check</code>加上<code>--init-scum</code>参数，重启之后一大堆错误，死心，对数据不报期望了。</p>
<p>上一个系统用了1年多没换，好不容易有一次机会折腾可不能放过，先尝试安装funtoo，和以前无数次一样，都是到最后驱动不了我的博通无线网卡，后面尝试sabayon这个桌面系统，自带了桌面肯定自带了所有驱动。尝试安装，这回小心了，把<code>/boot</code>单独放到一个ext2的分区中去了，然后/用的是xfs，毕竟SGI的技术还是非常可以的。安装之后果然不需要手动装驱动，这种傻瓜式操作我最喜欢了，gnome中总是配置不好fcitx，而且ghc编译的时候总是会报错，也是莫名其妙的问题，supervisor的配置都得自己手动写，一大堆反人类的事情真是头疼，被arch的KISS哲学熏陶得simple且stupid之后，实在是受不了gentoo的diy思想。用<code>btrfs restore /mnt/arch /mnt/arch_bak</code>备份大部分数据之后，继续重装arch。</p>
<p>备份分区之后就多出了一个分区可以用来安装第三个系统，对于懒人来说肯定不愿意折腾文本安装界面，直接下载antergos的livecd开始图形化安装，一步一步做，选文件系统的时候还是不死心，不愿意放弃心爱的btrfs，又做死选了它。系统倒是很快就装好了，麻烦的地方是配置，不过默认的gnome3界面用得真心不习惯，所有应用窗口挤在一个桌面上，反复切换实在是太麻烦了。在安装fcitx输入法的时候不小心<code>systemctl stop dbus.service</code>，结果gnome桌面自动推出了，卡在一个黑乎乎的界面，对于一切操作都没有响应，强制关机之后发现又进不了硬盘了，满头黑线。</p>
<p>反正这个新安装的系统没有什么数据，重装即可，这回发誓在也不用btrfs了，试试ext4这个根正苗红的linux传人，果然一切OK，有线无线网卡自动激活，电源管理自带，安装xmonad没问题，安装fcitx一切顺利，安装dmenu用来管理菜单，安装urxvt，复制之前的Xresources文件，安装fish，安装vim，安装emacs，安装supervisor，安装shadowsocks，安装proxychains，github上面拷贝spf13的vim配置，prelude的emacs配置，oh-my-fish，一切都是这么简单，几乎不需要自己做额外的配置。进入熟悉的xmonad界面之后内心久久不能平静，我就喜欢这种一份配置一直使用的wm。最大的遗憾就是没能找回原来用的rsa密钥对，也就是说我的服务器连接都得重新来一遍，password-store也不能用了，几十个密码没法导出来。</p>
<p>从周日开始一知道今天（周四），花了太多时间，上班也用的是公司的电脑，太影响效率了，不过还好一切都解决了。总结一下这场事故中学到的东西吧：</p>
<ol style="list-style-type: decimal">
<li>数据无价，平时得定时做好数据备份工作。鉴于xfs和ext4都没有磁盘快照功能，所以只能备份文件了，btsync似乎是一个不错的选择。</li>
<li>不要把/boot和/放在一起，其实最好的分区规范应该是分为/boot, /usr, /这3块，这样就算/挂了，还能进入内核利用/usr里面的软件来修复自身。</li>
<li>btrfs最近2年都不会再去碰了，虽然有很多很新的特性，但是一个礼拜伤我2次，这份大仇2年内都不能忘记。</li>
<li>配置文件非常重要，最好是保存在网上，之前仅仅star了一下prelude的配置导致后面很多本地的自定义都没有提交到自己的仓库，分区崩溃之后自己写的代码都没了。</li>
<li>最后再赞美一下xmonad，这是我用过的最好的桌面了。</li>
</ol>]]></summary>
</entry>

</feed>
