<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Joey's blog</title>
    <link href="http://blog.iyue.club/rss.xml" rel="self" />
    <link href="http://blog.iyue.club" />
    <id>http://blog.iyue.club/rss.xml</id>
    <author>
        <name>Joey Xie</name>
        <email>joey.xf@gmail.com</email>
    </author>
    <updated>2016-08-11T00:00:00Z</updated>
    <entry>
    <title>如何不要脸与低三下四</title>
    <link href="http://blog.iyue.club/posts/2016-08-11-github-coupon.html" />
    <id>http://blog.iyue.club/posts/2016-08-11-github-coupon.html</id>
    <published>2016-08-11T00:00:00Z</published>
    <updated>2016-08-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>8月8号的时候github把我的教育网优惠资格给停用了，然后还给我发了一个邮件让我去绑定信用卡，这种事情真是不能忍，我3月底的时候收到一次邮件告诉我说我的教育网资格到期了，然后我就被自动降级为普通用户了，但是5月份之后我发现我还是可以继续用私有仓库的，说明我还是教育网用户，赶紧迁移了几个私有项目到github上面，结果问题就来了，周一又给我取消了，接下来就是连续的不要脸邮件对话，具体内容见下，我以为我踩中了他们系统的bug，要求他们给我补偿，但是他们却一口咬定我是8号正常到期，想我去绑定信用卡，就这样你来我往地回复了几封邮件，最后被额外送3个月优惠期，等于是用21美刀就把我打发了，我还以为至少能送我1年，挺郁闷的，不过github客服还是挺耐心的，到最后估计鄙视死我了哈哈。邮件对话见下，这么蹩脚的英文人家也能听懂，给自己点个赞。</p>
<pre>
Gmail	Joey Xie <joey.xf@gmail.com>
Re: I was an education pack user and now can't use private repository
6 messages
Andrew (GitHub Staff) <support@github.com>	Wed, Aug 10, 2016 at 6:03 PM
To: Joey <joey.xf@gmail.com>
Hey Joey,

Sorry for any confusion! Your account was upgraded to a paid plan when you applied for a coupon a couple of years ago. The coupon covered the whole cost of a Micro plan, but after two years, the coupon expired while the account stayed at the Micro level (now referred to as Unlimited Private Repositories due to a change in our pricing structure).

Our system tried to charge you for the next month of service at the Unlimited Private Repositories rate, but as our other email noted, you don't have a card on file. That email is sent automatically to users with expired coupons of all types (not just education discounts) to let you know you'll need to sort out your payment method.

If you still qualify for a coupon, you can reapply for another educational discount coupon here:

https://education.github.com/discount_requests/new

If you are no longer qualified, you can either add a valid payment method following the link in the earlier email, or downgrade the account to a Free plan following these steps:

https://help.github.com/articles/downgrading-a-user-account-to-free

Hope that clears things up, and please do let us know if you have any other questions.

All the best,
Andrew

Joey Xie <joey.xf@gmail.com>	Thu, Aug 11, 2016 at 1:58 AM
To: "Andrew (GitHub Staff)" <support@github.com>
Dear Andrew,

In Mar 21 2014 you ended my education account and down grade me to free user but after May 11 2016 https://github.com/blog/2164-introducing-unlimited-private-repositories I can again use private repositories, so I migrated several private project to github. Now again you told me that I have no access to my private repository. I feel bad, my personal projects use these repositories. I hope you can be a nice personal since Amazon pay for their wrong orders but not customers.
[Quoted text hidden]
Andrew (GitHub Staff) <support@github.com>	Thu, Aug 11, 2016 at 2:33 AM
To: Joey Xie <joey.xf@gmail.com>
Hey Joey,

The educational discount coupon expired on Mar 20 2016, at which point your account should have locked, and you would've been asked to either downgrade your plan to the free tier, or add a payment method to your account, in order to maintain access to your private repositories.

That process was delayed until this Monday, at which point your account was updated to reflect the expired coupon.

Our announcement regarding unlimited private repositories doesn't change anything in terms of the current situation, as (I'm sure you noted from reading the blog post) only paid accounts can benefit from unlimited private repositories.

I've unlocked your account temporarily, so you can access your private repositories for the time being. If you wish to benefit from another educational discount, you can submit an application here:

https://education.github.com/discount_requests/new

Alternatively, you can update your account with a payment method, as instructed in my last email.

If you have any further questions about this, just let me know - I'm happy to help!

All the best,
Andrew

Joey Xie <joey.xf@gmail.com>	Thu, Aug 11, 2016 at 10:11 AM
To: "Andrew (GitHub Staff)" <support@github.com>
Hi Andrew

I'm sure after Mar 20 I can't access my private repositories, but after this May I again can use private repository, So I think it's your fault that make me migrate my personal work to github, can you please make some compensate for me? I'm a poor programmer in China, I get a low salary have to work long hours everyday, can't afford a car or a house. You are so nice, can't you just give me a surprise thanks.
[Quoted text hidden]
Andrew (GitHub Staff) <support@github.com>	Thu, Aug 11, 2016 at 5:05 PM
To: Joey Xie <joey.xf@gmail.com>
Hi Joey,

The previous coupon you had gave you free private repositories from March 21 2014, right up until last Monday.

I have applied another coupon to your account, to cover the next three months, but after that time, you will need to downgrade to the free plan, or add a payment method to your account.

If you have any further questions, please let me know.

All the best,
Andrew

Joey Xie <joey.xf@gmail.com>	Thu, Aug 11, 2016 at 5:17 PM
To: "Andrew (GitHub Staff)" <support@github.com>
thanks Andrew, you saved me 21 bucks, I thought you would give me at lease another 1 year coupon, but again thanks.
[Quoted text hidden]
</pre>]]></summary>
</entry>
<entry>
    <title>递归地删除数组里面所有多余的空格</title>
    <link href="http://blog.iyue.club/posts/2016-08-07-recursive-remove-space.html" />
    <id>http://blog.iyue.club/posts/2016-08-07-recursive-remove-space.html</id>
    <published>2016-08-07T00:00:00Z</published>
    <updated>2016-08-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>在使用<a href="https://github.com/jdorn/json-editor">jsoneditor</a>的时候遇到一个问题就是总是会把多余的空格写入数据库，如：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$a</span> = <span class="ot">[</span><span class="st">&#39;a&#39;</span> =&gt; <span class="st">&#39; hello&#39;</span><span class="ot">,</span> <span class="st">&#39;b&#39;</span> =&gt; <span class="st">&#39;world &#39;</span><span class="ot">,</span> <span class="st">&#39;c&#39;</span> =&gt; <span class="st">&#39; he &#39;</span><span class="ot">];</span></code></pre></div>
<p>很多情况下我们都不需要开头结尾的空格，有时候空格甚至会带来麻烦，比如说图片地址后面加上空格之后就给前端操作带来麻烦，那么有什么好办法在写入数据库之前先过滤一遍呢？</p>
<p>对于上面这种对象数组处理方式很简单：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$a</span> = <span class="fu">array_map</span><span class="ot">(</span><span class="st">&#39;trim&#39;</span><span class="ot">,</span> <span class="kw">$a</span><span class="ot">);</span></code></pre></div>
<p>但是如果数组结构复杂，比如说是二维数组</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$a</span> = <span class="ot">[</span><span class="st">&#39;a&#39;</span> =&gt; <span class="st">&#39; hello&#39;</span><span class="ot">,</span> <span class="st">&#39;b&#39;</span> =&gt; <span class="st">&#39;world &#39;</span><span class="ot">,</span> <span class="st">&#39;c&#39;</span> =&gt; <span class="st">&#39; he &#39;</span><span class="ot">,</span> <span class="st">&#39;d&#39;</span> =&gt; <span class="ot">[</span><span class="st">&#39;a&#39;</span> =&gt; <span class="st">&#39; hello&#39;</span><span class="ot">,</span> <span class="st">&#39;b&#39;</span> =&gt; <span class="st">&#39;world &#39;</span><span class="ot">,</span> <span class="st">&#39;c&#39;</span> =&gt; <span class="st">&#39; he &#39;</span><span class="ot">]];</span></code></pre></div>
<p>这时候就要有一个机制能够递归的处理每隔元素内部的空格，思路就是递归，代码见下：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$myfunc</span> = <span class="kw">function</span> <span class="ot">(</span>&amp;<span class="kw">$value</span><span class="ot">,</span> <span class="kw">$key</span><span class="ot">)</span> <span class="kw">use</span> <span class="ot">(</span>&amp;<span class="kw">$myfunc</span><span class="ot">)</span> {
    <span class="kw">if</span> <span class="ot">(</span><span class="fu">is_array</span><span class="ot">(</span><span class="kw">$value</span><span class="ot">))</span> {
        <span class="fu">array_walk</span><span class="ot">(</span><span class="kw">$value</span><span class="ot">,</span> <span class="kw">$myfunc</span><span class="ot">);</span>
    } <span class="kw">else</span> {
        <span class="kw">$value</span> = <span class="fu">trim</span><span class="ot">(</span><span class="kw">$value</span><span class="ot">);</span>
    }
}<span class="ot">;</span>
<span class="fu">array_walk</span><span class="ot">(</span><span class="kw">$a</span><span class="ot">,</span> <span class="kw">$myfunc</span><span class="ot">);</span></code></pre></div>
<p>普通函数的递归很好写，但是匿名函数的递归就是第一次写来，竟然需要用use来把当前函数导入进闭包里面，而且必需以传引用的方式，php的语法也是丑得可以。</p>]]></summary>
</entry>
<entry>
    <title>eloquent高级用法</title>
    <link href="http://blog.iyue.club/posts/2016-07-18-delve-into-eloquent.html" />
    <id>http://blog.iyue.club/posts/2016-07-18-delve-into-eloquent.html</id>
    <published>2016-07-18T00:00:00Z</published>
    <updated>2016-07-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>常见的关系模型有1对1,1对多，多对多，在一个model中描述这些关系用<code>hasOne</code>, <code>hasMany</code>, <code>belongsTo</code>, <code>belongsToMany</code>就够了，但是最近遇到一个新的情况要用到更复杂的关系模型，就是polymorphic relation，按照<a href="https://en.wikipedia.org/wiki/Polymorphic_association">wikipedia</a> 的说法，这个概念是在ORM开发中提出来的，<a href="https://laravel.com/docs/5.2/eloquent-relationships">laravel</a>和<a href="http://guides.rubyonrails.org/association_basics.html">rails</a>中很好的实现了多态关系。第一次遇到这个问题的时候没见过，以为能用自带的1对多关系解决，但是在经过一番尝试之后没法优雅的解决我的问题，所以求助了<a href="https://stackoverflow.com/questions/38433109/eloquent-belongsto-determine-relation-table">stackoverflow</a>，很快就有网友提示了正确的思路，避免我在错误的道路上越走越远，今天就来总结一下我的问题吧。</p>
<p>在项目中有一些资源表，如games, news, songs，现在的需求要针对每种资源都能进行评论，所以还有一个评论表，但是在评论表中得区分是对什么资源的评论，所以用<code>commentable_id</code>和<code>commentable_type</code>来标识一个可被评论项实体。最初建表的时候是打算用<code>item_id</code>和<code>item_type</code>这2个字段的，但是按照laravel和ruby官方文档的建议，我还是改为以<code>able</code>结尾的单词了，我的model见下:</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> Game
{
    <span class="kw">public</span> <span class="kw">function</span> comment<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;morphMany<span class="ot">(</span>Comment::<span class="kw">class</span><span class="ot">,</span> <span class="st">&#39;commentable&#39;</span><span class="ot">);</span>
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> News
{
    <span class="kw">public</span> <span class="kw">function</span> comment<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;morphMany<span class="ot">(</span>Comment::<span class="kw">class</span><span class="ot">,</span> <span class="st">&#39;commentable&#39;</span><span class="ot">);</span>
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> Comment
{
    <span class="kw">public</span> <span class="kw">function</span> commentable<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;morphTo<span class="ot">();</span>
    }
    <span class="kw">public</span> <span class="kw">function</span> getCommentableTypeAttribute<span class="ot">(</span><span class="kw">$value</span><span class="ot">)</span>
    {
        <span class="kw">if</span> <span class="ot">(</span><span class="kw">$value</span> == <span class="st">&#39;App\Model\Game&#39;</span><span class="ot">)</span> {
            <span class="kw">return</span> <span class="st">&#39;game&#39;</span><span class="ot">;</span>
        } <span class="kw">else</span> {
            <span class="kw">return</span> <span class="st">&#39;news&#39;</span><span class="ot">;</span>
        }
    }
    <span class="kw">public</span> <span class="kw">function</span> author<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;belongsTo<span class="ot">(</span>User::<span class="kw">class</span><span class="ot">,</span> <span class="st">&#39;author_id&#39;</span><span class="ot">);</span>
    }
}</code></pre></div>
<p>在获取一个用户发布的所有评论时，可以使用</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$comments</span> = Comment::where<span class="ot">(</span><span class="st">&#39;author_id&#39;</span><span class="ot">,</span> <span class="st">&#39;=&#39;</span><span class="ot">,</span> <span class="kw">$id</span><span class="ot">)</span>
    -&gt;with<span class="ot">(</span><span class="st">&#39;commentable&#39;</span><span class="ot">)</span>
    -&gt;paginate<span class="ot">();</span></code></pre></div>
<p>通过打印这行的查询日志发现总共有4条查询语句:</p>
<ol style="list-style-type: decimal">
<li><p>查询用户的总评论数，分页时用到</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="fu">count</span>(*) <span class="kw">as</span> aggregate <span class="kw">from</span> `comments` <span class="kw">where</span> `author_id` = ?</code></pre></div></li>
<li><p>查询评论本身的信息</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> `comments` <span class="kw">where</span> `author_id` = ? <span class="kw">limit</span> <span class="dv">15</span> offset <span class="dv">0</span></code></pre></div></li>
<li><p>查询发布评论的人的信息</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> `users` <span class="kw">where</span> `users`.`id` <span class="kw">in</span> (?)</code></pre></div></li>
<li><p>查询被评论物的详细信息</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> `games` <span class="kw">where</span> `games`.`id` <span class="kw">in</span> (?) <span class="kw">and</span> `status` = ?</code></pre></div></li>
</ol>
<p>一行代码对应4条查询，使用eloquent的优点由此可见，省去了很多自己手写查询的精力。</p>
<p>另一个查询这种数据模型的思路是关联查询，</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> c.id <span class="kw">as</span> comment_id, c.commentable_id, g.name <span class="kw">as</span> title <span class="kw">from</span> comments <span class="kw">as</span> c <span class="kw">left</span> <span class="kw">join</span> games <span class="kw">as</span> g <span class="kw">on</span> c.commentable_id=g.id <span class="kw">where</span> c.commentable_type=<span class="st">&#39;App</span><span class="ch">\\</span><span class="st">Model</span><span class="ch">\\</span><span class="st">Game&#39;</span> <span class="kw">union</span> <span class="kw">select</span> c.id <span class="kw">as</span> comment_id, c.commentable_id, n.title <span class="kw">as</span> title <span class="kw">from</span> comments <span class="kw">as</span> c <span class="kw">left</span> <span class="kw">join</span> news <span class="kw">as</span> n <span class="kw">on</span> c.commentable_id=n.id <span class="kw">where</span> c.commentable_type=<span class="st">&#39;App</span><span class="ch">\\</span><span class="st">Model</span><span class="ch">\\</span><span class="st">News&#39;</span>;</code></pre></div>
<p>开始是打算动态选择如何管理资源表的，后来尝试之后发现只能用union合并2条查询的结果，手写查询还是不如eloquent优雅。</p>]]></summary>
</entry>
<entry>
    <title>laravel密码生成与校验机制</title>
    <link href="http://blog.iyue.club/posts/2016-07-08-laravel-password.html" />
    <id>http://blog.iyue.club/posts/2016-07-08-laravel-password.html</id>
    <published>2016-07-08T00:00:00Z</published>
    <updated>2016-07-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>在irc上听到有人说他们的应用改了.env中的APP_KEY之后就无法登录了，太奇怪了，在本地测试了几个例子都没有复现，决定详细看看这块</p>
<p>在注册的时候生成密码的密文，内置了一个叫做<a href="https://github.com/laravel/framework/blob/5.2/src/Illuminate/Foundation/helpers.php#L180">bcrypt</a>的函数来加密明文密码，实际密码生成是在<a href="https://github.com/laravel/framework/blob/5.2/src/Illuminate/Hashing/BcryptHasher.php#L26">BcryptHasher#make</a>中，使用blowfish算法来生成密文，不带参数使用的cost是10</p>
<p>再看看密码验证这部分 实际校验是在<a href="https://github.com/laravel/framework/blob/5.2/src/Illuminate/Auth/EloquentUserProvider.php#L114">EloquentUserProvider#validateCredentials</a>，调用BcryptHasher#check来校验，关于laravel和php的加密有<a href="https://mnshankar.wordpress.com/2014/03/29/laravel-hash-make-explained/">一篇很好的文章</a>讲述了blowfish这个算法的作用，盐和加密变换次数都存放在密码本身，所以密码的生成和校验完全和APP_KEY无关，别害怕使用<code>php artisan key:generate</code>，这个命令只会让session失效</p>]]></summary>
</entry>
<entry>
    <title>点赞收藏存储设计</title>
    <link href="http://blog.iyue.club/posts/2016-06-06-like-favorite-design.html" />
    <id>http://blog.iyue.club/posts/2016-06-06-like-favorite-design.html</id>
    <published>2016-06-06T00:00:00Z</published>
    <updated>2016-06-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>前段时间给自己的业余项目写代码的时候遇到了一个问题就是如何设计点赞，评论，收藏的存储结构。这3个功能是社交软件必不可少的组成部份，但是设计起来确一点都不简单。</p>
<p>先说评论</p>
<p>之前在7k做zeze社区的时候我就发现了评论的复杂性，最大的问题是数据量大，以前做社区的时候一个楼层下可以有几万个评论，一个贴子可以有几百个楼层，一个论坛可以有好多贴子，数据增长很快。但是现在app的评论系统都比较简洁，不会像网页那么复杂，如果不支持嵌套回复的话，那就简单多了，表结构设计如下：</p>
<pre class="plain"><code>id: 评论id，自增主键
item_id: 被评论项目的id，int
author_id: 作者id，int
comment: 评论内容，varchar</code></pre>
<p>这个模型没有解决大数据扩展的问题，但是已经算是非常简洁了，对于未来分表的设想是在中间加一张索引表，映射某一个范围的item_id,某个author_id的所有评论到一个分片中，这样按父id，和发布人id来索引评论的时候都简单。</p>
<p>其次是点赞</p>
<p>这个问题的难度在于用户可以反复点击，所以要求接口响应足够快，占用资源足够少，不然同时多个用户连续点赞取消赞就会给服务器带来很大的压力了。最初我的设想是把点赞设计为用户和帖子的一个关系，如果用户点赞了某一个帖子，用户就和这个贴子有关系，如果取消了点赞这个关系就断开了。那么点赞表就是一个多对多的关系表了，按帖子和用户查询都可以很快。这种实现的坏处是如果用户反复点击赞接口时，都会有一个查询去判断用户是否赞过这个帖子了，因为所有的产品都是要求用户 不能反复点赞同一个帖子，需要程序自己来维护点赞操作的幂等性，也就是每次写库之前先find一次，如果有就更新时间，如果没有就插入。毫无疑问这个接口会很慢而且占用很多资源，所以要找另一个更优化的方案。我后来决定使用redis的zset来存储点赞信息，以帖子id作为key，以点赞用户的uid作为value，score是点赞时间，由于集合自身是不允许出现重复的value的，所以每次都可以直接zadd把点赞用户更新进去，不需要人工维护数据唯一，太省事了，不过如果还要按用户索引被点赞过的帖子，那就得再新增一个key，以uid作为key，以帖子id作为value，不能支持多字段查询是redis的设计导致的，不过更新2个redis的key可比更新1行mysql快多了，最好使用multi保证原子操作。</p>
<p>取消赞，收藏，取消收藏我都是用同样的方式做的，只要确保redis服务器不挂，不丢数据就行。</p>]]></summary>
</entry>
<entry>
    <title>我的chromebook</title>
    <link href="http://blog.iyue.club/posts/2016-06-05-my-chromebook.html" />
    <id>http://blog.iyue.club/posts/2016-06-05-my-chromebook.html</id>
    <published>2016-06-05T00:00:00Z</published>
    <updated>2016-06-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>今年2月份附近入手的一台二手chromebook，到目前为止已经用了很长一段时间了，打算写一篇文章来总结一下使用体验。</p>
<p>先来看看我的屏幕截图，目前看起来还觉得挺geek的 <img src="../images/chromebook-htop.png" alt="终端" /> <img src="../images/chromebook-myadmin.png" alt="myadmin" /></p>
<p>终端模拟器是用的chrome的一个插件叫做crosh window</p>
<p>linux虚拟机是用crouton安装的ubuntu16.04 core,可惜是共享内核的，所以ubuntu的内核也是3.10.18的</p>
<p>一些常用工具包括：</p>
<ol style="list-style-type: decimal">
<li>fish，我最喜欢的shell</li>
<li>tmux，终端复用软件，可以开启多个会话</li>
<li>ss，用来上网的，开启之后chromebook也可以共享上网，真不错</li>
<li>emacs，我最爱的编辑器，之前crouton遇到最大的问题是中文输入法，有了emacs之后我可以用自带的pyim来输入中文了，没必要使用chromebook自带的输入法</li>
<li>开发环境，nginx, mysql, php7, python, rvm等等之类的</li>
<li>数据库连接是用一个叫做myadmin的chrome扩展实现的</li>
</ol>
<p>遇到的问题：</p>
<ol style="list-style-type: decimal">
<li><p>cpu性能太差劲，我的lenovon21用的cpu是intel n2840的，一款低功耗的arm架构双核cpu，在打开多个浏览器标签时资源使用率总是达到100%，我在编译代码的时候就更费劲了，昨晚编译hakyll花了1个多小时，用公司的thinkpad t440s编译大概10分钟能搞定</p></li>
<li><p>显示器太渣，现在应该没有720p的笔记本显示器了吧，看着觉得很糢糊</p></li>
<li><p>机身是黑色塑料的，看起来很廉价，没有chromebook pixel和mac book pro那么银光闪闪</p></li>
<li><p>还是cpu太差劲，平时敲代码打字都有明显的卡顿了</p></li>
</ol>
<p>总结一下：</p>
<ol style="list-style-type: decimal">
<li><p>google是一家非常伟大的公司，感谢他们发明了chromebook这么伟大的产品</p></li>
<li><p>联想是美帝良心企业，在国内就买不到chromebook，国内的thinkpad价格也要比美帝高出一截</p></li>
<li><p>n21还算是一款性价比非常好的本子，就是性能有点弱，17年再换一个16年出的二手chromebook玩玩</p></li>
</ol>]]></summary>
</entry>
<entry>
    <title>php使用guzzle发送http请求</title>
    <link href="http://blog.iyue.club/posts/2016-04-28-php-guzzle-http.html" />
    <id>http://blog.iyue.club/posts/2016-04-28-php-guzzle-http.html</id>
    <published>2016-04-28T00:00:00Z</published>
    <updated>2016-04-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>最原始的发送http请求的方法是调用原生的curl扩展，这就需要在php.ini中允许 <code>extension=curl.so</code>，使用方式也很简单，下面是几个发送基本GET, POST请求的例子。</p>
<ol style="list-style-type: decimal">
<li><p>curl 发送GET请求:</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$ch</span> = <span class="fu">curl_init</span><span class="ot">(</span><span class="kw">$url</span><span class="ot">)</span> <span class="ot">;</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_HEADER</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">);</span> <span class="co">// 不返回http头</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_RETURNTRANSFER</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">)</span> <span class="ot">;</span> <span class="co">// 按字符串返回而不是输出到屏幕上</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_TIMEOUT</span><span class="ot">,</span> <span class="dv">3</span><span class="ot">);</span> <span class="co">// 设置连接超时时间</span>
<span class="kw">$result</span> = <span class="fu">curl_exec</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">)</span> <span class="ot">;</span>
<span class="fu">curl_close</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">);</span></code></pre></div></li>
<li><p>curl 发送POST请求:</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$ch</span> = <span class="fu">curl_init</span><span class="ot">(</span><span class="kw">$url</span><span class="ot">);</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_POST</span><span class="ot">,</span><span class="dv">1</span><span class="ot">);</span> <span class="co">// 表明是发送post请求</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_POSTFIELDS</span><span class="ot">,</span> <span class="kw">$jsonString</span><span class="ot">);</span> <span class="co">// post的数据，支持json字符串和http_build_query之后的参数</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_RETURNTRANSFER</span><span class="ot">,</span> <span class="kw">true</span><span class="ot">);</span>
<span class="kw">$result</span> = <span class="fu">curl_exec</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">)</span> <span class="ot">;</span>
<span class="fu">curl_close</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">);</span></code></pre></div></li>
<li><p>curl上传文件: 也是一个post请求，例子见下面</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$ch</span> = <span class="fu">curl_init</span><span class="ot">(</span><span class="kw">$url</span><span class="ot">);</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_POST</span><span class="ot">,</span><span class="dv">1</span><span class="ot">);</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_POSTFIELDS</span><span class="ot">,</span> <span class="ot">[</span>
<span class="st">&#39;file&#39;</span> =&gt; <span class="kw">new</span> \CurlFile<span class="ot">(</span><span class="kw">$fullFileName</span><span class="ot">,</span> <span class="kw">$mimeType</span><span class="ot">,</span> <span class="kw">$filename</span><span class="ot">);</span>
<span class="st">&#39;param1&#39;</span> =&gt; <span class="kw">$value1</span><span class="ot">,</span>
<span class="st">&#39;param2&#39;</span> =&gt; <span class="kw">$value2</span><span class="ot">,</span>
<span class="ot">]);</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_RETURNTRANSFER</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">);</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_HTTPHEADER</span><span class="ot">,</span> <span class="ot">[</span>
<span class="st">&#39;Content-type: multipart/form-data;&#39;</span>
<span class="ot">]);</span>
<span class="kw">$result</span>=<span class="fu">curl_exec</span> <span class="ot">(</span><span class="kw">$ch</span><span class="ot">);</span>
<span class="fu">curl_close</span> <span class="ot">(</span><span class="kw">$ch</span><span class="ot">);</span></code></pre></div></li>
</ol>
<p>第一次使用curl上传文件的时候还遇到了一点小问题，网上大部分写法都是用<code>'file' =&gt; @&quot;$fullFileName&quot;</code>来加载文件的，我用这种写法反复测试了很久都不能获取到真是的文件，后来才发现<a href="https://secure.php.net/manual/en/class.curlfile.php">CurlFile</a>这个类，按照文档下面评论的说法，php发送multipart请求的时候会有问题，解决办法有2个，1：允许<code>CURLOPT_SAFE_UPLOAD</code>， 2：使用CURLFile 而不是 “@”</p>
<p>我偏好的http请求库 <a href="https://github.com/guzzle/guzzle">guzzle</a> 作为一个应用开发者而言，更多的封装往往是更好的，curl太原始了，接口太少，选项太多，如果要发一个post请求，得先去查一下如何设置数据，如何设置请求头，返回值说明什么意思，如何表示20x, 30x, 40x, 50x的状态码，但是作为一个http库选择就更少了，我们只要知道如何创建请求对象，如何发送请求，响应对象，异常是什么就够了，知道了这几个概念如果要发送一种特殊请求只需要修改请求对象就行了</p>
<p>请求对象:</p>
<p>一个简单的GET请求的对象</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$request</span> = <span class="kw">new</span> \GuzzleHttp\Psr7\Request<span class="ot">(</span><span class="st">&#39;GET&#39;</span><span class="ot">,</span> <span class="st">&#39;http://httpbin.org&#39;</span><span class="ot">);</span></code></pre></div>
<p>一个简单的POST请求的对象</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$request</span> = <span class="kw">new</span> \GuzzleHttp\Psr7\Request<span class="ot">(</span><span class="st">&#39;POST&#39;</span><span class="ot">,</span> <span class="st">&#39;http://httpbin.org&#39;</span><span class="ot">);</span></code></pre></div>
<p>一个简单的发送multipart/form-data请求上传文件的例子</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$r</span> = <span class="kw">$client</span>-&gt;request<span class="ot">(</span><span class="st">&#39;POST&#39;</span><span class="ot">,</span> <span class="kw">$url</span><span class="ot">,</span> <span class="ot">[</span>
    <span class="st">&#39;multipart&#39;</span> =&gt; <span class="ot">[</span>
        <span class="ot">[</span><span class="st">&#39;name&#39;</span> =&gt; <span class="st">&#39;file&#39;</span><span class="ot">,</span><span class="st">&#39;contents&#39;</span> =&gt; <span class="kw">$body</span><span class="ot">],</span>
        <span class="ot">[</span><span class="st">&#39;name&#39;</span> =&gt; <span class="st">&#39;user_id&#39;</span><span class="ot">,</span> <span class="st">&#39;contents&#39;</span> =&gt; <span class="dv">1</span><span class="ot">],</span>
    <span class="ot">],</span>
<span class="ot">]);</span></code></pre></div>
<p>发送请求： 首先要有一个客户端对象，这个对象能够发送一个请求对象，然后获得响应</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$client</span> = <span class="kw">new</span> Client<span class="ot">();</span></code></pre></div>
<p>发送请求：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$client</span>-&gt;send<span class="ot">(</span><span class="kw">$request</span><span class="ot">);</span></code></pre></div>
<p>在调试curl发请求的时候还发现了一个小技巧抓包，用<code>nc -l -p 8888</code>开启一个监听端口，然后把curl的请求地址设置为<code>http://127.0.0.1:8888</code>，这样就能抓到php发送http请求的数据了，总之guzzle比curl强大太多，能用就多用。</p>]]></summary>
</entry>
<entry>
    <title>从prelude切换到spacemacs</title>
    <link href="http://blog.iyue.club/posts/2015-12-26-switch-to-spacemacs.html" />
    <id>http://blog.iyue.club/posts/2015-12-26-switch-to-spacemacs.html</id>
    <published>2015-12-26T00:00:00Z</published>
    <updated>2015-12-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="最初的配置">最初的配置</h2>
<h3 id="基本的配置文件">基本的配置文件</h3>
<p>使用prelude作为基本配置文件，加上自定义的改动</p>
<h3 id="自定义配置文件">自定义配置文件</h3>
<ul>
<li>编辑personal/下面的文件，添加自定义配置</li>
<li>使用customize方法来自动生成配置</li>
</ul>
<h3 id="从elpa或者是melpa上面下载别人贡献的包">从elpa或者是melpa上面下载别人贡献的包</h3>
<h2 id="目前的配置">目前的配置</h2>
<h3 id="spacemacs">spacemacs</h3>
<p>所有配置都使用spacemacs的规则</p>
<h2 id="切换的原因">切换的原因</h2>
<h3 id="设计思想的不同">设计思想的不同</h3>
<p>spacemacs讲究配置文件分层，对于个人的配置文件设置有很严格的要求，便于大家交换配置文件</p>
<h3 id="界面不同">界面不同</h3>
<p>spacemacs的ui也很美观，下面的状态条非常漂亮</p>
<h3 id="社区活跃程度">社区活跃程度</h3>
<p>现在spacemacs社区很活跃，每天都有人提交代码，算是emacs社区目前最活跃的一个项目了</p>
<h3 id="纯粹喜新厌旧">纯粹喜新厌旧</h3>
<p>不折腾就不叫做极客</p>
<h2 id="切换之后的感受">切换之后的感受</h2>
<h3 id="每一次变更都是一个痛苦的经历">每一次变更都是一个痛苦的经历</h3>
<p>切换过来之后很多快捷键都不同了，导致有点痛苦，新的学习曲线</p>
<h3 id="习惯让生活更高效">习惯让生活更高效</h3>
<p>原来使用prelude的快捷键，基本按键都是遵循emacs默认的按键，比如说helm的快捷键也是， 按键设置没有规律，现在spacemacs的快捷键基本都统一格式了，我喜欢一致性</p>
<h3 id="养成一个好习惯很重要">养成一个好习惯很重要</h3>
<p>工具是有好坏之分的，如果不相信这句话而是一味的认为工具不重要，人才是最终要的，这样下去 就会让工作生活效率越来越低下</p>]]></summary>
</entry>
<entry>
    <title>创建自己的composer包</title>
    <link href="http://blog.iyue.club/posts/2015-12-15-create-composer-package.html" />
    <id>http://blog.iyue.club/posts/2015-12-15-create-composer-package.html</id>
    <published>2015-12-15T00:00:00Z</published>
    <updated>2015-12-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>最近在做服务重构与模块化的工作，以前的老代码太多复制粘贴的东西，需要整理一下，否则 将来项目就不可维护了</p>
<p>涉及到的服务有：</p>
<ol style="list-style-type: decimal">
<li>api 主要的接口模块，大部分客户端交互由这个接口完成</li>
<li>image 图片服务，图片上传下载压缩等操作</li>
<li>chat 聊天服务</li>
</ol>
<p>目前的架构就是这样的，等将来还可以继续拆分api接口，独立出更多小功能</p>
<p>在api和image中都会用到mq来与后端的java服务通信，原来的实现是自己封装的mq，同一个功能实现2次， 现在抽象出mq功能作为一个公共库，让这2个服务都能调用同一个mq的库。</p>
<p>主要涉及到的工具是composer，真是一个强大的武器。</p>
<ol style="list-style-type: decimal">
<li>创建库</li>
</ol>
<ul>
<li>新建一个目录，<code>mkdir mqpackage</code></li>
<li>切换进目录执行<code>composer init</code> 根据提示内容创建<code>composer.json</code>文件</li>
<li>按照要求自己编辑这个json文件，比较重要的就是require和autoload这块</li>
<li>然后就是敲代码了</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>提交package到git仓库</li>
</ol>
<ul>
<li>因为是在公司里开发的项目，不敢放到github上，推送到内部的git服务器了</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>配置项目的composer.json文件，引入刚刚新增的库</li>
</ol>
<ul>
<li>在项目的<code>composer.json</code>文件中的require区域加上上面的包要注意的就是要在repository里面加上这个包的地址，因为默认会从packgist上面拉</li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li>重新测试一遍原有的2个服务的功能</li>
</ol>
<ul>
<li>创建单元测试写测试是很重要的，尤其是写这种公共库，我也是对照这phpunit的文档一点一点的敲测试用例的</li>
</ul>]]></summary>
</entry>
<entry>
    <title>博客从octopress迁移到hakyll</title>
    <link href="http://blog.iyue.club/posts/2015-12-10-switch-to-hakyll.html" />
    <id>http://blog.iyue.club/posts/2015-12-10-switch-to-hakyll.html</id>
    <published>2015-12-10T00:00:00Z</published>
    <updated>2015-12-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="准备完全迁移到hakyll上面了">准备完全迁移到hakyll上面了</h3>
<p>之前的博客是使用octopress搭建的，这个静态站点生成器最大的好处就是简单，不需要自己额外的hack，装好octopress，简单设置好之后就能使用，而且提交，部署都有 现成的工具，主题也有很多，所以一用就用了一年多。从7月份开始就有点厌倦octopress了，因为不喜欢这么傻瓜式的东西，咱们的目标是to be a geeker，当然不能一直 不进步。hakyll算是非常极客的一个工具了，haskell写的，使用pandoc处理文本，而且配置文件完全是haskell代码，想着能用这么geek的语言，玩这么geek的软件，就 非常激动。</p>
<p>使用hakyll也非常简单，步骤是:</p>
<ol style="list-style-type: decimal">
<li><code>cabal install hakyll</code> 安装hakyll，这一步非常耗时，因为自己的笔记本CPU落伍了。</li>
<li><code>hakyll-init blog</code> 会在当前目录下创建一个叫作blog的目录。</li>
<li><code>cd blog</code> 进入这个目录，会发现有一系列文件，这是默认的博客站点。</li>
<li><code>cabal build</code> 默认会build这个haskell站点，生成站点可执行文件。</li>
<li><code>dist/build/site/site build</code> 会编译<code>posts/</code>下面的文件，生成html文件到<code>_site/posts/</code>下面。</li>
<li><code>dist/build/site/site watch</code> 会开启一个web服务器，默认访问地址是http://127.0.0.1:4000/ 点击访问，然后就你发现默认的首页了。</li>
<li>默认站点好了接下来就是迁移原博客的文章，从原来的git仓库中把所有的markdown文件复制到<code>posts/</code>下面。</li>
<li>再次试着build整个站点，这时候可能会有点问题，我这里因为有的文章元数据中categories:熟悉为空报了几个错，改完就好了。</li>
<li>配置博客站点，修改站点外观，添加rss和tag页，我用的是<a href="https://github.com/eakron/variadic.me">variadic</a>的配置，很简单，配置文件改动很小但是 却把我要的功能都实现了，真的很厉害。</li>
<li>再次build，并且watch新的项目，顺利跑通了之后，但是看不到标签，很奇怪，原来老的文章是使用categories作为标签名的，现在使用tags了，自然要改。 <code>sed -i 's/categories\:/tags\:/g'</code> 一行sed命令，批量替换，真不错。</li>
<li>博客在本地搭好了，并且预览过了，接下来就是部署到线上，还是用github-pages。那么我就需要2个分支，一个source分支用来存放静态站点的代码，包括站点 配置，原始markdown格式的博文，这样将来要换到别的机器上，直接clone source分支的代码下来build就行了。还有一个分支是master分支，这个分支存放build之后 的文件，也就是所有的静态文件，html, css, js, 图片等。因为我线上已经有一个博客站点了，所以只需要添加远程github仓库就行。 <code>cd blog</code>进入我的博客根目录，执行<code>git init .</code> 添加版本控制, <code>git add .</code>, <code>git commit -m 'first commit'</code>, <code>git checkout -b source</code>切换到 source分支，然后删掉master分支<code>git branch -d master</code>，因为代码只要保存在source，master只能放生成的静态文件。<code>git remote add origin git@github.com:xcaptain/xcaptain.github.io</code>添加我的远程仓库， 要注意编辑.gitignore文件，把_site, _tmp, _cache都忽略掉。然后是<code>git submodule add git@github.com:xcaptain/xcaptain.github.io.git _site/</code>把 线上的master分支作为我的一个模块，克隆到_site目录下。再执行一下<code>dist/build/site/site build</code>会生成新的静态文件写入_site/目录，当然那些老的文件不会被 删掉，比如说我之前的CNAME文件，favicon文件都还留着，这时候<code>cd _site/</code>然后再提交一下。本地所有的代码都干净之后就是推送部署了。在<code>blog/</code>目录下执行 <code>git push origin source</code>把当前分支推送到origin的source分支，然后再切换到<code>_site/</code>目录，执行<code>git push origin master</code>把生成的静态文件推送到线上的 master分支。访问<a href="http://blog.iyue.club" class="uri">http://blog.iyue.club</a>开测，真不错。</li>
</ol>
<p>虽然说没有了octopress那么多做好的功能，但是通过折腾hakyll学习到了很多知识，等以后优化这个部署流程的时候可以自己写脚本部署，省得总是自己多次写shell命令</p>]]></summary>
</entry>

</feed>
