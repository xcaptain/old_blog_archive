<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Joey's blog</title>
    <link href="http://blog.iyue.club/rss.xml" rel="self" />
    <link href="http://blog.iyue.club" />
    <id>http://blog.iyue.club/rss.xml</id>
    <author>
        <name>Joey Xie</name>
        <email>joey.xf@gmail.com</email>
    </author>
    <updated>2017-08-28T00:00:00Z</updated>
    <entry>
    <title>使用headless chromium来抓取网页</title>
    <link href="http://blog.iyue.club/posts/2017-08-28-headless-chrome.html" />
    <id>http://blog.iyue.club/posts/2017-08-28-headless-chrome.html</id>
    <published>2017-08-28T00:00:00Z</published>
    <updated>2017-08-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>在使用<a href="https://scrapy.org/">scrapy</a>编写爬虫的过程中遇到一些动态加载的内容不好抓取，所以研究了一下<a href="https://chromium.googlesource.com/chromium/src/+/lkgr/headless/README.md">headless chromium</a>，如果不用这种方式的话就得手动 破解ajax请求的接口，了解不同网站做的校验规则，使用浏览器解析dom然后分析页面结构是最简单快速的方法了。</p>
<h1 id="headless-chromium基本用法">headless chromium基本用法</h1>
<p>根据<a href="https://developers.google.com/web/updates/2017/04/headless-chrome">官方教程</a>说明，在chromium59版本之后的浏览器自带了无头模式，只要通过命令行执行</p>
<p><code>chromium --headless --disable-gpu</code></p>
<p>就能打开一个无头的浏览器了，如果我想打开某个网页，并且分析完全加载完成的dom结构，那么只要执行</p>
<p><code>chromium --headless --disable-gpu --dump-dom http://www.dianping.com/shop/14198848 &gt; /tmp/14198848.html</code></p>
<p>想要做后续的分析直接分析这个html文件就行了</p>
<h1 id="通过selenium来驱动headless-chromium">通过selenium来驱动headless chromium</h1>
<p>python有个叫selenium的包叫作，安装好之后就能操作浏览器了</p>
<h2 id="安装依赖">安装依赖</h2>
<p><code>sudo pip install selenium</code></p>
<h2 id="示例代码">示例代码</h2>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> selenium <span class="im">import</span> webdriver
<span class="im">from</span> selenium.webdriver.chrome.options <span class="im">import</span> Options

chrome_options <span class="op">=</span> Options()
chrome_options.add_argument(<span class="st">&quot;--headless&quot;</span>)
chrome_options.add_argument(<span class="st">&quot;--user-agent=some user-agent name&quot;</span>)

driver <span class="op">=</span> webdriver.Chrome(chrome_options<span class="op">=</span>chrome_options)
driver.get(<span class="st">&#39;http://www.dianping.com/shop/59473758&#39;</span>)

<span class="co"># 返回html</span>
html <span class="op">=</span> driver.execute_script(<span class="st">&quot;return document.documentElement.outerHTML&quot;</span>)

<span class="co"># 读取js全局变量</span>
shop_config <span class="op">=</span> driver.execute_script(<span class="st">&quot;return window.shop_config&quot;</span>)

<span class="bu">id</span> <span class="op">=</span> <span class="st">&#39;59474758&#39;</span>
<span class="cf">with</span> <span class="bu">open</span>(<span class="bu">id</span> <span class="op">+</span> <span class="st">&#39;.html&#39;</span>, <span class="st">&#39;wb&#39;</span>) <span class="im">as</span> f:
    f.write(<span class="bu">str</span>.encode(html))

driver.save_screenshot(<span class="bu">id</span> <span class="op">+</span> <span class="st">&#39;.png&#39;</span>)
driver.close()  <span class="co"># 关闭chrome进程</span>
driver.quit()  <span class="co"># 关闭chromewebdriver进程</span></code></pre></div>
<p>这段脚本的作用很明显，首先是创建一个headless chromium的浏览器对象，然后用它打开大众点评的一个网页，然后导出dom，写入到一个html文件 中，最后把当前网页截图保存为一个png文件，并且关闭浏览器。竟然还能读取到js的变量，真是太强大了</p>
<h1 id="在使用headless-chromium过程中遇到的问题">在使用headless chromium过程中遇到的问题</h1>
<h2 id="一些引用的资源加载超时导致整个页面超时">一些引用的资源加载超时，导致整个页面超时</h2>
<p>这个问题没有好的解决办法，看到文档上有设置页面ready的配置</p>
<ol>
<li><a href="https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagegotourl-options" class="uri">https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md#pagegotourl-options</a></li>
<li><a href="https://stackoverflow.com/questions/46160929/puppeteer-wait-for-all-images-to-load-then-take-screenshot" class="uri">https://stackoverflow.com/questions/46160929/puppeteer-wait-for-all-images-to-load-then-take-screenshot</a></li>
</ol>
<p>但是selenium webdriver没法提供扩展，目前我的解决办法是加了</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">driver.implicitly_wait(<span class="dv">10</span>)  <span class="co"># 资源10s没加载完就放弃</span>
driver.set_script_timeout(<span class="dv">10</span>)  <span class="co"># 资源10s没加载完就放弃</span>
driver.set_page_load_timeout(<span class="dv">30</span>)  <span class="co"># 请求30s没完成就放弃</span></code></pre></div>
<p>不是很好用，最好的办法是绕过这些有加载不了的资源的网页。</p>
<h2 id="python程序异常退出导致chrome进程变成僵尸进程">python程序异常退出导致chrome进程变成僵尸进程</h2>
<p>正确设置异常处理程序，在出现异常时记得close()和quit()</p>
<h1 id="scrapy操作字符串">scrapy操作字符串</h1>
<p>通过headless chromium导出的是纯字符串，如果要让它支持xpath解析，需要处理一下，比如：</p>
<ol>
<li><a href="https://stackoverflow.com/questions/27323740/scrapy-convert-html-string-to-htmlresponse-object">转成HtmlResponse对象</a></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> scrapy.http <span class="im">import</span> HtmlResponse

response <span class="op">=</span> HtmlResponse(url<span class="op">=</span><span class="st">&quot;my HTML string&quot;</span>, body<span class="op">=</span><span class="st">&#39;&lt;div id=&quot;test&quot;&gt;Test text&lt;/div&gt;&#39;</span>)
response.xpath(<span class="st">&#39;//div[@id=&quot;test&quot;]/text()&#39;</span>).extract()[<span class="dv">0</span>].strip()</code></pre></div>
<ol>
<li><a href="https://stackoverflow.com/questions/8711030/fetch-partial-string-matched-html-tag-using-xpath">转成lxml对象</a></li>
</ol>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> lxml

html <span class="op">=</span> <span class="st">&#39;&lt;div id=&quot;test&quot;&gt;Test text&lt;/div&gt;&#39;</span>
doc <span class="op">=</span> lxml.html.fromstring(html)</code></pre></div>
<h1 id="使用beautifulsoup操作html">使用BeautifulSoup操作html</h1>
<p>bs的api比lxml的易用多了，比如说要新建一个标签，并且添加到某个节点下，lxml就比较难实现了，毕竟html不是标准的xml，看了一下lxml的api感觉比较复杂 就选择了用bs</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> bs4 <span class="im">import</span> BeautifulSoup
<span class="im">import</span> json

soup <span class="op">=</span> BeautifulSoup(html, <span class="st">&#39;html5lib&#39;</span>)
<span class="co"># add script tag</span>
script_tag <span class="op">=</span> soup.new_tag(<span class="st">&#39;script&#39;</span>)
script_tag.append(<span class="st">&#39;window.globale_config=&#39;</span> <span class="op">+</span> json.dumps(global_config) <span class="op">+</span> <span class="st">&#39;;&#39;</span>)
soup.body.insert_before(script_tag)</code></pre></div>
<p>这段代码在body标签的前面新增了一个script标签，标签内部定义了一个全局变量，这样就可以把dom和脚本都保存到本地了</p>
<p>有了headless chromium之后写爬虫就方便多了，甚至现代的各种SPA应用也不用担心，happy hacking!</p>]]></summary>
</entry>
<entry>
    <title>使用rust创建websocket服务器</title>
    <link href="http://blog.iyue.club/posts/2017-08-15-rust-websocket-tutorial.html" />
    <id>http://blog.iyue.club/posts/2017-08-15-rust-websocket-tutorial.html</id>
    <published>2017-08-15T00:00:00Z</published>
    <updated>2017-08-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>最近需要做实时推送相关的应用，所以继续调研了一下websocket，在15年底的时候曾经使用过<a href="https://github.com/sumory/gru">Gru</a>来做聊天推送， 但是那时候没仔细研究过websocket的细节。现在趁机自己构思一下</p>
<h1 id="使用ws-rs构建websocket服务端">使用<a href="https://github.com/housleyjk/ws-rs">ws-rs</a>构建websocket服务端</h1>
<p>按照<a href="https://ws-rs.org/guide">Guide</a>搭建服务端应用，`cargo new ws-server1 –bin`</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> ws;

<span class="kw">use</span> ws::listen;

<span class="kw">fn</span> main() <span class="op">{</span>
    listen(<span class="st">&quot;127.0.0.1:3012&quot;</span>, |out| <span class="op">{</span>
        <span class="kw">move</span> |msg| <span class="op">{</span>
            <span class="pp">println!</span>(<span class="st">&quot;received msg: {}&quot;</span>, msg);
            out.broadcast(msg)
        <span class="op">}</span>
    <span class="op">}</span>).unwrap()
<span class="op">}</span></code></pre></div>
<p>cargo run 运行服务端</p>
<h1 id="服务端推送">服务端推送</h1>
<p>往socket里面推送消息 `cargo new ws-client1 –bin`</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">extern</span> <span class="kw">crate</span> ws;

<span class="kw">use</span> ws::<span class="op">{</span>connect, CloseCode<span class="op">}</span>;

<span class="kw">fn</span> main() <span class="op">{</span>
    connect(<span class="st">&quot;ws://127.0.0.1:3012&quot;</span>, |out| <span class="op">{</span>
        out.send(<span class="st">&quot;Hello WebSocket&quot;</span>).unwrap();

        <span class="kw">move</span> |msg| <span class="op">{</span>
            <span class="pp">println!</span>(<span class="st">&quot;Got message: {}&quot;</span>, msg);
            out.close(CloseCode::Normal)
        <span class="op">}</span>
    <span class="op">}</span>).unwrap()
<span class="op">}</span></code></pre></div>
<p>运行 cargo run，这时候会看到服务端输出`received msg: Hello WebSocket`，客户端输出`Got message: Hello WebSocket`</p>
<h1 id="客户端连接">客户端连接</h1>
<p>创建2个websocket客户端连接，打开2个chrome标签，分别在终端执行</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript">ws <span class="op">=</span> <span class="kw">new</span> <span class="at">WebSocket</span>(<span class="st">&#39;ws://127.0.0.1:3012&#39;</span>)<span class="op">;</span> <span class="co">// 创建连接</span>
<span class="va">ws</span>.<span class="at">addEventListener</span>(<span class="st">&#39;message&#39;</span><span class="op">,</span> <span class="kw">function</span> (event) <span class="op">{</span>
    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Message from server &#39;</span><span class="op">,</span> <span class="va">event</span>.<span class="at">data</span>)<span class="op">;</span>
<span class="op">}</span>)<span class="op">;</span> <span class="co">// 监听服务端</span>

<span class="va">ws</span>.<span class="at">send</span>(<span class="st">&#39;from browser&#39;</span>)<span class="op">;</span> <span class="co">// 可以在2个console中互相发消息玩</span></code></pre></div>
<p>能发现websocket会自动检测连接，如果连接断开会提示 <code>WebSocket is already in CLOSING or CLOSED state.</code> 这也省去了手动发送心跳包 检测连接的麻烦</p>]]></summary>
</entry>
<entry>
    <title>php陷阱与缺陷</title>
    <link href="http://blog.iyue.club/posts/2017-06-30-php-pitfalls.html" />
    <id>http://blog.iyue.club/posts/2017-06-30-php-pitfalls.html</id>
    <published>2017-06-30T00:00:00Z</published>
    <updated>2017-06-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>最近使用php时遇到一个很奇怪的问题，即</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="co">// php</span>
<span class="dv">0</span> == <span class="st">&#39;a&#39;</span><span class="ot">;</span> <span class="co">// true</span></code></pre></div>
<p>这个问题在web开发的时候可能会导致一些莫名其妙的问题，比较了一些其他语言之后发现大部分是不这么做的，先总结 0==‘a’ ==&gt; true的</p>
<div class="sourceCode"><pre class="sourceCode perl"><code class="sourceCode perl"><span class="co"># perl</span>
<span class="dv">0</span> == <span class="kw">&#39;</span><span class="st">a</span><span class="kw">&#39;</span> <span class="co"># 1</span>
<span class="dv">1</span> == <span class="kw">&#39;</span><span class="st">a</span><span class="kw">&#39;</span> <span class="co"># 0</span>
<span class="dv">0</span> == <span class="kw">&#39;</span><span class="st">0</span><span class="kw">&#39;</span> <span class="co"># 1</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="co">// php</span>
<span class="dv">0</span> == <span class="st">&#39;a&#39;</span> <span class="co">// ==&gt; true</span>
<span class="dv">0</span> === <span class="st">&#39;a&#39;</span> <span class="co">// false</span>
<span class="dv">1</span> == <span class="st">&#39;a&#39;</span> <span class="co">// ==&gt; false</span>
<span class="dv">0</span> == <span class="st">&#39;0&#39;</span> <span class="co">// true</span></code></pre></div>
<p>0==‘a’ ==&gt; False的：</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># python 3.6</span>
<span class="dv">0</span> <span class="op">==</span> <span class="st">&#39;a&#39;</span> <span class="co"># False</span>
<span class="dv">0</span> <span class="op">==</span> <span class="st">&#39;0&#39;</span> <span class="co"># False</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode ruby"><code class="sourceCode ruby"><span class="co"># ruby 2.4</span>
<span class="dv">0</span> == <span class="ch">&#39;a&#39;</span> <span class="co"># false</span>
<span class="dv">0</span> == <span class="ch">&#39;0&#39;</span> <span class="co"># false</span></code></pre></div>
<pre class="elisp"><code>; elisp
(= 0 &quot;a&quot;) ;; error
</code></pre>
<div class="sourceCode"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span class="co">(* ocaml 4.04.1 *)</span>
<span class="dv">0</span> == <span class="ch">&#39;0&#39;</span>;; <span class="co">(* error *)</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- ghci 8.0.2</span>
<span class="dv">0</span> <span class="fu">==</span> <span class="ch">&#39;0&#39;</span> <span class="co">-- error</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode erlang"><code class="sourceCode erlang"><span class="co">% erlang otp 20</span>
<span class="dv">0</span> <span class="op">==</span> <span class="ch">&#39;0&#39;</span><span class="fu">.</span> <span class="co">% false</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode c"><code class="sourceCode c"><span class="co">// C</span>
<span class="pp">#include </span><span class="im">&lt;stdio.h&gt;</span>

<span class="dt">int</span> main(<span class="dt">void</span>) {
  <span class="dt">char</span> a = <span class="ch">&#39;a&#39;</span>;
  printf(<span class="st">&quot;%d</span><span class="sc">\n</span><span class="st">&quot;</span>, (<span class="dv">0</span> == a)); <span class="co">// 0</span>

  <span class="cf">return</span> <span class="dv">0</span>;
}</code></pre></div>
<p>其他更加现代的语言，如rust,typescript,idris等就不说了，强大的type inference导致这样的代码根本不能通过编译器。 按照这样对照看来和php行为类似的只有perl，其他语言比较0==’a’要么报错，要么返回false。不管是返回true还是false，我还是更喜欢在编译时报错，这样可以及时发现代码中的问题。</p>]]></summary>
</entry>
<entry>
    <title>学习idris</title>
    <link href="http://blog.iyue.club/posts/2017-06-06-learning-idris.html" />
    <id>http://blog.iyue.club/posts/2017-06-06-learning-idris.html</id>
    <published>2017-06-06T00:00:00Z</published>
    <updated>2017-06-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>在工作中一直写的是php，偶尔写点javascript, python，动态语言写多了之后发现很多语言本身的问题，导致要通过很多人为的规范来让程序变得可维护。</p>
<p>目前对php语言的一些感受：</p>
<ol>
<li>无类型推导(<a href="https://en.wikipedia.org/wiki/Type_inference">Type inference</a>)</li>
<li>无确定性异常捕获(<a href="https://stackoverflow.com/questions/6115896/java-checked-vs-unchecked-exception-explanation">checked exception</a>)</li>
</ol>
<p>目前在php7中加入了强类型开关，如果启用了能做部分类型推导，但是目前公司大部分代码还是php5的语法，而且线上环境还未切换到7。其实就算完全用php7 的严格模式开发，要想充分利用到类型推导带来的好处似乎也不太简单，php的创始人做的<a href="https://github.com/etsy/phan">phan</a> 项目还没有发布v1.0版本，再说到处使用array, stdclass 这样的类型来存储变量，phan要实现这种代码的静态分析应该也很吃力，因为php7还不支持 <a href="https://en.wikipedia.org/wiki/Dependent_type">dependent type</a>。看php相关的新闻，最近开发组的工作重心 似乎在jit以及性能优化上，要想做一个完整的类型系统估计还要很久，在这之前能加上一个好用的debugger我就知足了。</p>
<p>为什么类型推导这么重要呢，举个例子吧。 领导有个需求让实现一个字符串截取功能，你很快就写出来了</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="co">/**</span>
<span class="co"> * 一个很简单的字符串截取函数</span>
<span class="co"> *</span>
<span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">string</span><span class="co"> $str 待处理的字符串</span>
<span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">int</span><span class="co"> $start 开始点</span>
<span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">int</span><span class="co"> $length 截取长度</span>
<span class="co"> * </span><span class="an">@return</span><span class="co"> string</span>
<span class="co"> */</span>
<span class="kw">function</span> cut_str<span class="ot">(</span><span class="kw">$str</span><span class="ot">,</span> <span class="kw">$start</span><span class="ot">,</span> <span class="kw">$length</span><span class="ot">)</span>
{
    <span class="kw">return</span> <span class="fu">substr</span><span class="ot">(</span><span class="kw">$str</span><span class="ot">,</span> <span class="kw">$start</span><span class="ot">,</span> <span class="kw">$length</span><span class="ot">);</span>
}</code></pre></div>
<p>你还特意给这个简单得不能再简单的方法添加了注释文档，但是有一天你在查看程序的日志时发现以下内容:</p>
<div class="sourceCode"><pre class="sourceCode markdown"><code class="sourceCode markdown">PHP warning:  substr() expects parameter 1 to be string, array given on line 1
PHP error:  Undefined variable: a on line 1</code></pre></div>
<p>如果公司做了错误日志收集监控，并且和kpi挂钩的话，那你就惨了，郁闷的你仔细查了一下代码，发现某个队友在调用你的cut_str方法时没有按照你给的注释来 传字符串参数而是传了一个数组过来，你可能会去和那个同事理论，告诉他你的文档里写得很清楚这个方法第一个参数是字符串不能传数组过来，他可能会埋怨你 这个方法写得不严谨没有做好脏数据的异常处理，互相扯皮几句之后还得回去老老实实修改代码，思考了一下之后你可能改成如下的样子:</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="co">/**</span>
<span class="co"> * 一个很简单的字符串截取函数</span>
<span class="co"> *</span>
<span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">string</span><span class="co"> $str 待处理的字符串</span>
<span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">int</span><span class="co"> $start 开始点</span>
<span class="co"> * </span><span class="an">@param</span><span class="co"> </span><span class="cv">int</span><span class="co"> $length 截取长度</span>
<span class="co"> * </span><span class="an">@return</span><span class="co"> string</span>
<span class="co"> */</span>
<span class="kw">function</span> cut_str<span class="ot">(</span><span class="kw">$str</span><span class="ot">,</span> <span class="kw">$start</span><span class="ot">,</span> <span class="kw">$length</span><span class="ot">)</span>
{
    <span class="kw">if</span> <span class="ot">(</span>! <span class="fu">is_string</span><span class="ot">(</span><span class="kw">$str</span><span class="ot">))</span> {
        <span class="co">// do some log</span>
        <span class="kw">return</span> <span class="st">&#39;&#39;</span><span class="ot">;</span>
    }
    <span class="kw">if</span> <span class="ot">(</span><span class="kw">$start</span> &lt; <span class="dv">0</span><span class="ot">)</span> {
        <span class="co">// do some log</span>
        <span class="kw">return</span> <span class="st">&#39;&#39;</span><span class="ot">;</span>
    }
    <span class="kw">if</span> <span class="ot">(</span><span class="kw">$start</span> &gt;= str_len<span class="ot">(</span><span class="kw">$str</span><span class="ot">))</span> {
        <span class="co">// do some log</span>
        <span class="kw">return</span> <span class="st">&#39;&#39;</span><span class="ot">;</span>
    }
    <span class="kw">if</span> <span class="ot">(</span><span class="kw">$length</span> &lt; <span class="dv">0</span><span class="ot">)</span> {
        <span class="co">// do some log</span>
        <span class="kw">return</span> <span class="st">&#39;&#39;</span><span class="ot">;</span>
    }
    <span class="kw">return</span> <span class="fu">substr</span><span class="ot">(</span><span class="kw">$str</span><span class="ot">,</span> <span class="kw">$start</span><span class="ot">,</span> <span class="kw">$length</span><span class="ot">);</span>
}</code></pre></div>
<p>写完之后你志得意满，新的方法太健壮了，不管猪队友传任何参数过来这个方法都能容错不会挂，而且可以默默的记录一些日志提醒自己有人传了乱七八糟的参数过来， 但是这个方法真的写得好吗？原来一行能搞定的问题被硬生生扩展到了15行，大部分都是冗余的校验，而且把校验，记日志，返回结果这3个职责混在一起做了，违反 了单一职责原则。在这里我们没有考虑抛异常把异常抛给上层去处理，因为这是上面checked exception相关的内容了。</p>
<p>说了这么多就是想引出idris这们语言，按照官网的介绍：</p>
<div class="sourceCode"><pre class="sourceCode markdown"><code class="sourceCode markdown">Idris is a general purpose pure functional programming language with dependent types. Dependent types allow types to be predicated on values, meaning that some aspects of a program’s behaviour can be specified precisely in the type. It is compiled, with eager evaluation. Its features are influenced by Haskell and ML</code></pre></div>
<p>简单说就是idris实现了一个很强大的类型系统，在编译时能能检测出大部分程序潜在的问题，真正做到once it compiles, it runs.</p>
<p>用idris重写一下上面那个cut_str方法</p>
<div class="sourceCode"><pre class="sourceCode idris"><code class="sourceCode idris"><span class="fu">cut_str</span> <span class="ot">:</span> (index <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> (len <span class="ot">:</span> <span class="dt">Nat</span>) <span class="ot">-&gt;</span> (subject <span class="ot">:</span> <span class="dt">String</span>) <span class="ot">-&gt;</span> <span class="dt">String</span>
cut_str <span class="fu">=</span> substr</code></pre></div>
<p>这时候谁要是写 cut_str 0 2 [“hello”] 这样的代码，编译器直接会报错，没机会走到runtime</p>
<div class="sourceCode"><pre class="sourceCode markdown"><code class="sourceCode markdown">When checking argument subject to function Main.cut_str:
<span class="bn">        Can&#39;t disambiguate since no name has a suitable type:</span>
<span class="bn">                Prelude.List.::, Prelude.Stream.::</span></code></pre></div>
<p>这种形式的代码我非常喜欢，方法的参数定义得很明确，功能定义也很明确，如果谁乱调用，那么就将自食其果。</p>
<p>之前关注过的强类型的语言还有:</p>
<ol>
<li><a href="https://www.rust-lang.org">rust</a></li>
<li><a href="http://www.typescriptlang.org/">typescript</a></li>
</ol>
<p>今后每天抽出一点时间学习这些语言背后的思想</p>]]></summary>
</entry>
<entry>
    <title>laravel路由与请求处理</title>
    <link href="http://blog.iyue.club/posts/2017-05-01-larave-router-and-requests.html" />
    <id>http://blog.iyue.club/posts/2017-05-01-larave-router-and-requests.html</id>
    <published>2017-05-01T00:00:00Z</published>
    <updated>2017-05-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>把手上的几个项目都从laravel 5.3升级到5.4了，说说在升级过程中遇到的问题。</p>
<h2 id="dingo-api不兼容问题的解决">dingo api不兼容问题的解决</h2>
<p>dingo使用了自己的route service，在最开始的配置中和laravel5.4是不兼容的</p>
<h2 id="jwt-auth的配置以及和dingo的配合使用">jwt-auth的配置以及和dingo的配合使用</h2>
<p>通过配置jwt使得在代码中能够获取到当前登录用户信息，在middleware中能检验登录</p>
<h2 id="通过middleware来记录request和response的log">通过middleware来记录request和response的log</h2>
<p>terminate middleware</p>]]></summary>
</entry>
<entry>
    <title>新入手xps13 9360的体验</title>
    <link href="http://blog.iyue.club/posts/2016-11-19-xps13-9360-first-eye.html" />
    <id>http://blog.iyue.club/posts/2016-11-19-xps13-9360-first-eye.html</id>
    <published>2016-11-19T00:00:00Z</published>
    <updated>2016-11-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>双11的时候亚马逊入手了一台xps13 9360，机器配置是i7-7500u，8GB内存，带1920x1080的ips屏。决定删掉默认的win10，全盘安装喜爱的linux</p>
<ol style="list-style-type: decimal">
<li><p>安装系统</p></li>
<li><p>安装软件</p></li>
<li><p>配置软件</p></li>
<li><p>同步数据</p></li>
</ol>]]></summary>
</entry>
<entry>
    <title>php的猴子补丁</title>
    <link href="http://blog.iyue.club/posts/2016-09-30-php-monkey-patch.html" />
    <id>http://blog.iyue.club/posts/2016-09-30-php-monkey-patch.html</id>
    <published>2016-09-30T00:00:00Z</published>
    <updated>2016-09-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>ruby和python都有<a href="https://en.wikipedia.org/wiki/Monkey_patch">monkey patch</a>，也就是可以在运行时修改某个对象或类的方法</p>
<p>在过去php是没有这种特性的，如果要给一个对象添加方法只有继承</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">&lt;?php</span>

<span class="kw">class</span> <span class="kw">A</span>
{
    <span class="kw">public</span> <span class="kw">function</span> foo<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="st">&#39;foo&#39;</span><span class="ot">;</span>
    }
}
<span class="kw">$obj</span> = <span class="kw">new</span> <span class="kw">A</span><span class="ot">();</span></code></pre></div>
<p>如果在某个情况下，我们要给<code>$obj</code>对象添加一个方法，这时候该怎么办呢？</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">&lt;?php</span>

<span class="kw">class</span> <span class="kw">B</span> <span class="kw">extends</span> <span class="kw">A</span>
{
    <span class="kw">public</span> <span class="kw">function</span> bar<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="st">&#39;bar&#39;</span><span class="ot">;</span>
    }
}
<span class="kw">$obj</span> = <span class="kw">new</span> <span class="kw">B</span><span class="ot">();</span></code></pre></div>
<p>这样obj对象就有了<code>bar</code>方法，但是这种办法很傻，得新建一个子类，而且这个子类可能很难被用上，如果在另外的情况下要用到另一个新的方法<code>bar2</code>，这时候又该怎么办呢，是再写一个继承？继承A还是B呢？</p>
<p>php7提供了一个新的语法叫做<a href="http://php.net/manual/en/language.oop5.anonymous.php">匿名类</a> 在上面的例子中，要给类A的实例添加方法就不需要新建一个类文件然后去继承，直接</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">&lt;?php</span>

<span class="kw">$obj</span> = <span class="kw">new</span> <span class="kw">class</span> <span class="kw">extends</span> <span class="kw">A</span>
{
    <span class="kw">public</span> <span class="kw">function</span> bar<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="st">&#39;bar&#39;</span><span class="ot">;</span>
    }
}<span class="ot">;</span></code></pre></div>
<p>这样obj也有<code>bar</code>方法，但是却没有创建额外的类文件，毕竟目的只是作为临时补丁修复一下，如果能够确定这个方法会被很多地方用到，那么就得考虑是否把这个方法添加到基类中，还是放到单独的子类。</p>
<p>在测试中这特性非常有用，测试<code>protected</code>方法，构造<code>mock</code>对象而不用改原有代码，第一次在真实场景中见到是在<a href="https://github.com/spatie/laravel-activitylog">activity-log</a>这个项目中<a href="https://github.com/spatie/laravel-activitylog/blob/master/tests/DetectsChangesTest.php" class="uri">https://github.com/spatie/laravel-activitylog/blob/master/tests/DetectsChangesTest.php</a>这里就构造了仅仅用于测试的model对象而没有改写原有的model</p>]]></summary>
</entry>
<entry>
    <title>php多进程处理大任务</title>
    <link href="http://blog.iyue.club/posts/2016-09-09-php-multi-process-task.html" />
    <id>http://blog.iyue.club/posts/2016-09-09-php-multi-process-task.html</id>
    <published>2016-09-09T00:00:00Z</published>
    <updated>2016-09-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>在写php脚本的过程中经常会遇到要并行处理大量数据的问题，比如说批量从数据库中处理几万行数据，调用第三方接口处理大数据等等，如果仅仅是循环去处理会导致非常低效，PHP本身是支持多进程的，如果让多个进程同时处理这部分数据就会让性能快很多。</p>
<p>在工作中遇到了一个这样的问题，把它抽象一下作为一个典型的例子记录，方便下次察看。</p>
<h3 id="多进程生成csv文件的php脚本">多进程生成csv文件的PHP脚本</h3>
<p>代码见<a href="https://gist.github.com/xcaptain/57aa46eaf52a1e0233f04caef1f1df66">gist</a></p>
<p>简单的说明：</p>
<ol style="list-style-type: decimal">
<li><p>通过<code>generateData</code>方法生成测试数据，目标是把这部分测试数据写入到一个csv文件中</p></li>
<li><p>通过<code>devideWork</code>方法来分割任务，在初始化过程中定义了工作进程数量，生成每个工作进程的任务量也就是pageSize的值</p></li>
<li><p>在主进程中把csv头部写入文件</p></li>
<li><p>多进程的核心部分是<code>runProcess</code>方法，<code>pcntl_fork</code>生成子进程，让子进程执行写csv的操作<code>writeCsv</code>，<code>pcntl_wexitstatus</code>回收子进程。</p></li>
</ol>
<p><code>writeCsv</code>是很慢的操作，但是<code>pcntl_fork</code>是很快的，如果一个进程一直等待着执行<code>writeCsv</code>就造成了低效，但是均分任务之后就飞快了。</p>
<h3 id="什么任务可以多进程执行">什么任务可以多进程执行</h3>
<p>自己简单总结一下可以分为:</p>
<ol style="list-style-type: decimal">
<li><p>任务可以明确分割，如果任务有很复杂的依赖关系，有严格的执行顺序要求，肯定没法并行</p></li>
<li><p>每一部分任务的结果可以很好的合并，在这里是追加到文件</p></li>
</ol>
<h3 id="对于php多进程模型的一些推测">对于PHP多进程模型的一些推测</h3>
<ol style="list-style-type: decimal">
<li><p><code>pcntl_fork</code>生成的子进程是对父进程的深度拷贝，子进程拥有了父进程中的整个对象，每个对象都复制了一份<code>data</code>属性</p></li>
<li><p>子进程无法改变父进程中的变量，在<code>writeCsv</code>方法中子进程的<code>$this-&gt;counter</code>自增了，但是父进程中的<code>$this-&gt;counter</code>没有变化</p></li>
<li><p>子进程和父进程无法直接通信，必须借助类似文件句柄这样的东西才能共享数据，难怪在unix/linux的设计哲学中文件如此重要</p></li>
</ol>
<h3 id="几个文件相关的实用小命令">几个文件相关的实用小命令</h3>
<ol style="list-style-type: decimal">
<li><p>显示重复行 <code>sort FILE | uniq -cd</code></p></li>
<li><p>删除重复行 <code>awk '!seen[$0]++' filename</code></p></li>
<li><p>删除长度更短的行 <code>awk 'length($0)&gt;3' filename</code></p></li>
</ol>]]></summary>
</entry>
<entry>
    <title>安装和配置elasticsearch</title>
    <link href="http://blog.iyue.club/posts/2016-09-03-install-and-use-elasticsearch.html" />
    <id>http://blog.iyue.club/posts/2016-09-03-install-and-use-elasticsearch.html</id>
    <published>2016-09-03T00:00:00Z</published>
    <updated>2016-09-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://www.elastic.co/products/elasticsearch">elasticsearch</a>是一个非常优秀的搜索工具，比数据库的搜索功能好太多了，以下介绍elasticsearch的配置与应用，以下操作在ubuntu 16.04下进行</p>
<h3 id="安装">安装</h3>
<p>ubuntu 16.04中默认已经使用elasticsearch 5.x的源了，jdk最好使用java8 1. <code>apt install default-jre default-jdk</code> 2. <code>apt install elasticsearch</code></p>
<h3 id="启动">启动</h3>
<p><code>systemctl start elasticsearch.service</code> 如果一切顺利，执行<code>curl 'http://localhost:9200'</code>的时候就可以正常返回一个json</p>
<h3 id="安装中文分词插件ik">安装中文分词插件<a href="https://github.com/medcl/elasticsearch-analysis-ik">ik</a></h3>
<ol style="list-style-type: decimal">
<li>安装mvn <code>apt install maven</code></li>
<li>按照github说明安装插件(elasticsearch对插件版本要求比较严格，有时候要自己改插件编译配置)</li>
<li>把编译好的zip文件复制到<code>/usr/local/share/elasticsearch/plugins/ik</code>中，删除目录中原有的代码，解压zip包，重启es</li>
<li>重启之后要监控es的日志，避免因为更新插件导致启动失败</li>
</ol>
<h3 id="实际应用">实际应用</h3>
<p>在laravel 5.4中已经集成了<a href="https://laravel.com/docs/5.4/scout">laravel-scout</a>，所以就不需要像以前那样使用第三方的包了，不过令人伤心的是在<a href="https://github.com/laravel/scout/tree/2.0">scout v2.0</a>之后，es的支持就被剥离出核心项目了，当然如果想继续使用scout+es，可以使用<a href="https://github.com/ErickTamayo/laravel-scout-elastic">laravel-scout-elastic</a>，这个库代码很少，包含了基本的api，使用很方便。</p>]]></summary>
</entry>
<entry>
    <title>php从mysql中获取真实字段类型</title>
    <link href="http://blog.iyue.club/posts/2016-08-22-php-pdo-results.html" />
    <id>http://blog.iyue.club/posts/2016-08-22-php-pdo-results.html</id>
    <published>2016-08-22T00:00:00Z</published>
    <updated>2016-08-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>刚接触新公司代码不熟悉框架，发现Model层返回的数据都是字符串类型的,这可不能忍，在restapi中字段类型是要固定的，不然接口文档不明确，客户端调用时可能也会出问题。</p>
<p>追查了一下发现这边低层连接mysql是用mysqli扩展连接的，主要查询操作是</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$result</span> = <span class="fu">mysqli_query</span><span class="ot">(</span><span class="kw">$handle</span><span class="ot">,</span> <span class="kw">$sql</span><span class="ot">);</span>
<span class="kw">$row</span> = <span class="fu">mysqli_fetch_assoc</span><span class="ot">(</span><span class="kw">$result</span><span class="ot">);</span>
<span class="fu">mysqli_free_result</span><span class="ot">(</span><span class="kw">$result</span><span class="ot">);</span></code></pre></div>
<p>在这个地方打印 $row变量就是字符串了，导致后续的数据全部都是字符串类型。在php内部使用倒是没什么问题，毕竟php本身是弱类型的语言，字符串数字和纯数字基本没什么区别，但是在接口开发方面就会有很大问题，一个restapi首要就是文档清晰，如果连每个返回值的类型都不能正确给出那么在调用的时候就容易出现不可预测的事情。</p>
<p>在老的代码中总是看到类似<code>$fieldType</code>这样的变量用来存放一个表的名称类型映射，但是这样做比较傻，涉及到数据库字段类型变更的时候还得改model。在pdo-mysql驱动中，底层的mysql驱动是mysqlnd，这个比mysqli先进，能够查询出每一行的元数据(metadata)，由一个PDO选项<code>PDO::ATTR_EMULATE_PREPARES</code>来控制是否返回真实的类型，具体见下面的例子：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$servername</span> = <span class="st">&quot;localhost&quot;</span><span class="ot">;</span>
<span class="kw">$username</span> = <span class="st">&quot;root&quot;</span><span class="ot">;</span>
<span class="kw">$password</span> = <span class="st">&quot;123456&quot;</span><span class="ot">;</span>
<span class="kw">$conn</span> = <span class="kw">new</span> <span class="kw">PDO</span><span class="ot">(</span><span class="st">&quot;mysql:host=</span><span class="kw">$servername</span><span class="st">;dbname=testdb&quot;</span><span class="ot">,</span> <span class="kw">$username</span><span class="ot">,</span> <span class="kw">$password</span><span class="ot">);</span>
<span class="kw">$conn</span>-&gt;setAttribute<span class="ot">(</span><span class="kw">PDO</span>::<span class="kw">ATTR_EMULATE_PREPARES</span><span class="ot">,</span> <span class="kw">false</span><span class="ot">);</span>
<span class="kw">$sql</span> = <span class="st">&quot;select * from test_table where id=1&quot;</span><span class="ot">;</span>
<span class="kw">$sth</span> = <span class="kw">$conn</span>-&gt;prepare<span class="ot">(</span><span class="kw">$sql</span><span class="ot">);</span>
<span class="kw">$sth</span>-&gt;execute<span class="ot">();</span>
<span class="kw">$row</span> = <span class="kw">$sth</span>-&gt;fetch<span class="ot">();</span></code></pre></div>
<p>如果不加<code>$conn-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);</code>这一行，返回值都是字符串类型，加了之后就能正确返回类型了。</p>
<p>laravel的eloquent ORM很强大，看了一下底层连接db的代码，在<a href="https://github.com/laravel/framework/blob/5.3/src/Illuminate/Database/Connectors/Connector.php">framework/src/Illuminate/Database/Connectors/Connector.php</a>设置好的默认选项中就有这个，果然是自己写的代码越少，犯错的机会就越少，框架和软件的设计思想都应该把易用性和可配置性放到第一位，而且要做到把默认值设置为普遍最佳方案，这样开发者才能有更多精力专注业务开发，做更多充满创造力的事情，而不是花几十分钟去搜索这种尝试性的问题。喜欢自己开发框架，但是又写不出好框架的团队是一个差劲的团队。</p>]]></summary>
</entry>

</feed>
