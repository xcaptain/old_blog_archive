<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Joey's blog</title>
    <link href="http://blog.iyue.club/rss.xml" rel="self" />
    <link href="http://blog.iyue.club" />
    <id>http://blog.iyue.club/rss.xml</id>
    <author>
        <name>Joey Xie</name>
        <email>joey.xf@gmail.com</email>
    </author>
    <updated>2017-05-01T00:00:00Z</updated>
    <entry>
    <title>laravel路由与请求处理</title>
    <link href="http://blog.iyue.club/posts/2017-05-01-larave-router-and-requests.html" />
    <id>http://blog.iyue.club/posts/2017-05-01-larave-router-and-requests.html</id>
    <published>2017-05-01T00:00:00Z</published>
    <updated>2017-05-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>把手上的几个项目都从laravel 5.3升级到5.4了，说说在升级过程中遇到的问题。</p>
<h2 id="dingo-api不兼容问题的解决">dingo api不兼容问题的解决</h2>
<p>dingo使用了自己的route service，在最开始的配置中和laravel5.4是不兼容的</p>
<h2 id="jwt-auth的配置以及和dingo的配合使用">jwt-auth的配置以及和dingo的配合使用</h2>
<p>通过配置jwt使得在代码中能够获取到当前登录用户信息，在middleware中能检验登录</p>
<h2 id="通过middleware来记录request和response的log">通过middleware来记录request和response的log</h2>
<p>terminate middleware</p>]]></summary>
</entry>
<entry>
    <title>新入手xps13 9360的体验</title>
    <link href="http://blog.iyue.club/posts/2016-11-19-xps13-9360-first-eye.html" />
    <id>http://blog.iyue.club/posts/2016-11-19-xps13-9360-first-eye.html</id>
    <published>2016-11-19T00:00:00Z</published>
    <updated>2016-11-19T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>双11的时候亚马逊入手了一台xps13 9360，机器配置是i7-7500u，8GB内存，带1920x1080的ips屏。决定删掉默认的win10，全盘安装喜爱的linux</p>
<ol style="list-style-type: decimal">
<li><p>安装系统</p></li>
<li><p>安装软件</p></li>
<li><p>配置软件</p></li>
<li><p>同步数据</p></li>
</ol>]]></summary>
</entry>
<entry>
    <title>php的猴子补丁</title>
    <link href="http://blog.iyue.club/posts/2016-09-30-php-monkey-patch.html" />
    <id>http://blog.iyue.club/posts/2016-09-30-php-monkey-patch.html</id>
    <published>2016-09-30T00:00:00Z</published>
    <updated>2016-09-30T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>ruby和python都有<a href="https://en.wikipedia.org/wiki/Monkey_patch">monkey patch</a>，也就是可以在运行时修改某个对象或类的方法</p>
<p>在过去php是没有这种特性的，如果要给一个对象添加方法只有继承</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">&lt;?php</span>

<span class="kw">class</span> <span class="kw">A</span>
{
    <span class="kw">public</span> <span class="kw">function</span> foo<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="st">&#39;foo&#39;</span><span class="ot">;</span>
    }
}
<span class="kw">$obj</span> = <span class="kw">new</span> <span class="kw">A</span><span class="ot">();</span></code></pre></div>
<p>如果在某个情况下，我们要给<code>$obj</code>对象添加一个方法，这时候该怎么办呢？</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">&lt;?php</span>

<span class="kw">class</span> <span class="kw">B</span> <span class="kw">extends</span> <span class="kw">A</span>
{
    <span class="kw">public</span> <span class="kw">function</span> bar<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="st">&#39;bar&#39;</span><span class="ot">;</span>
    }
}
<span class="kw">$obj</span> = <span class="kw">new</span> <span class="kw">B</span><span class="ot">();</span></code></pre></div>
<p>这样obj对象就有了<code>bar</code>方法，但是这种办法很傻，得新建一个子类，而且这个子类可能很难被用上，如果在另外的情况下要用到另一个新的方法<code>bar2</code>，这时候又该怎么办呢，是再写一个继承？继承A还是B呢？</p>
<p>php7提供了一个新的语法叫做<a href="http://php.net/manual/en/language.oop5.anonymous.php">匿名类</a> 在上面的例子中，要给类A的实例添加方法就不需要新建一个类文件然后去继承，直接</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">&lt;?php</span>

<span class="kw">$obj</span> = <span class="kw">new</span> <span class="kw">class</span> <span class="kw">extends</span> <span class="kw">A</span>
{
    <span class="kw">public</span> <span class="kw">function</span> bar<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="st">&#39;bar&#39;</span><span class="ot">;</span>
    }
}<span class="ot">;</span></code></pre></div>
<p>这样obj也有<code>bar</code>方法，但是却没有创建额外的类文件，毕竟目的只是作为临时补丁修复一下，如果能够确定这个方法会被很多地方用到，那么就得考虑是否把这个方法添加到基类中，还是放到单独的子类。</p>
<p>在测试中这特性非常有用，测试<code>protected</code>方法，构造<code>mock</code>对象而不用改原有代码，第一次在真实场景中见到是在<a href="https://github.com/spatie/laravel-activitylog">activity-log</a>这个项目中<a href="https://github.com/spatie/laravel-activitylog/blob/master/tests/DetectsChangesTest.php" class="uri">https://github.com/spatie/laravel-activitylog/blob/master/tests/DetectsChangesTest.php</a>这里就构造了仅仅用于测试的model对象而没有改写原有的model</p>]]></summary>
</entry>
<entry>
    <title>php多进程处理大任务</title>
    <link href="http://blog.iyue.club/posts/2016-09-09-php-multi-process-task.html" />
    <id>http://blog.iyue.club/posts/2016-09-09-php-multi-process-task.html</id>
    <published>2016-09-09T00:00:00Z</published>
    <updated>2016-09-09T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>在写php脚本的过程中经常会遇到要并行处理大量数据的问题，比如说批量从数据库中处理几万行数据，调用第三方接口处理大数据等等，如果仅仅是循环去处理会导致非常低效，PHP本身是支持多进程的，如果让多个进程同时处理这部分数据就会让性能快很多。</p>
<p>在工作中遇到了一个这样的问题，把它抽象一下作为一个典型的例子记录，方便下次察看。</p>
<h3 id="多进程生成csv文件的php脚本">多进程生成csv文件的PHP脚本</h3>
<p>代码见<a href="https://gist.github.com/xcaptain/57aa46eaf52a1e0233f04caef1f1df66">gist</a></p>
<p>简单的说明：</p>
<ol style="list-style-type: decimal">
<li><p>通过<code>generateData</code>方法生成测试数据，目标是把这部分测试数据写入到一个csv文件中</p></li>
<li><p>通过<code>devideWork</code>方法来分割任务，在初始化过程中定义了工作进程数量，生成每个工作进程的任务量也就是pageSize的值</p></li>
<li><p>在主进程中把csv头部写入文件</p></li>
<li><p>多进程的核心部分是<code>runProcess</code>方法，<code>pcntl_fork</code>生成子进程，让子进程执行写csv的操作<code>writeCsv</code>，<code>pcntl_wexitstatus</code>回收子进程。</p></li>
</ol>
<p><code>writeCsv</code>是很慢的操作，但是<code>pcntl_fork</code>是很快的，如果一个进程一直等待着执行<code>writeCsv</code>就造成了低效，但是均分任务之后就飞快了。</p>
<h3 id="什么任务可以多进程执行">什么任务可以多进程执行</h3>
<p>自己简单总结一下可以分为:</p>
<ol style="list-style-type: decimal">
<li><p>任务可以明确分割，如果任务有很复杂的依赖关系，有严格的执行顺序要求，肯定没法并行</p></li>
<li><p>每一部分任务的结果可以很好的合并，在这里是追加到文件</p></li>
</ol>
<h3 id="对于php多进程模型的一些推测">对于PHP多进程模型的一些推测</h3>
<ol style="list-style-type: decimal">
<li><p><code>pcntl_fork</code>生成的子进程是对父进程的深度拷贝，子进程拥有了父进程中的整个对象，每个对象都复制了一份<code>data</code>属性</p></li>
<li><p>子进程无法改变父进程中的变量，在<code>writeCsv</code>方法中子进程的<code>$this-&gt;counter</code>自增了，但是父进程中的<code>$this-&gt;counter</code>没有变化</p></li>
<li><p>子进程和父进程无法直接通信，必须借助类似文件句柄这样的东西才能共享数据，难怪在unix/linux的设计哲学中文件如此重要</p></li>
</ol>
<h3 id="几个文件相关的实用小命令">几个文件相关的实用小命令</h3>
<ol style="list-style-type: decimal">
<li><p>显示重复行 <code>sort FILE | uniq -cd</code></p></li>
<li><p>删除重复行 <code>awk '!seen[$0]++' filename</code></p></li>
<li><p>删除长度更短的行 <code>awk 'length($0)&gt;3' filename</code></p></li>
</ol>]]></summary>
</entry>
<entry>
    <title>安装和配置elasticsearch</title>
    <link href="http://blog.iyue.club/posts/2016-09-03-install-and-use-elasticsearch.html" />
    <id>http://blog.iyue.club/posts/2016-09-03-install-and-use-elasticsearch.html</id>
    <published>2016-09-03T00:00:00Z</published>
    <updated>2016-09-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://www.elastic.co/products/elasticsearch">elasticsearch</a>是一个非常优秀的搜索工具，比数据库的搜索功能好太多了，以下介绍elasticsearch的配置与应用，以下操作在ubuntu 16.04下进行</p>
<h3 id="安装">安装</h3>
<p>ubuntu 16.04中默认已经使用elasticsearch 5.x的源了，jdk最好使用java8 1. <code>apt install default-jre default-jdk</code> 2. <code>apt install elasticsearch</code></p>
<h3 id="启动">启动</h3>
<p><code>systemctl start elasticsearch.service</code> 如果一切顺利，执行<code>curl 'http://localhost:9200'</code>的时候就可以正常返回一个json</p>
<h3 id="安装中文分词插件ik">安装中文分词插件<a href="https://github.com/medcl/elasticsearch-analysis-ik">ik</a></h3>
<ol style="list-style-type: decimal">
<li>安装mvn <code>apt install maven</code></li>
<li>按照github说明安装插件(elasticsearch对插件版本要求比较严格，有时候要自己改插件编译配置)</li>
<li>把编译好的zip文件复制到<code>/usr/local/share/elasticsearch/plugins/ik</code>中，删除目录中原有的代码，解压zip包，重启es</li>
<li>重启之后要监控es的日志，避免因为更新插件导致启动失败</li>
</ol>
<h3 id="实际应用">实际应用</h3>
<p>在laravel 5.4中已经集成了<a href="https://laravel.com/docs/5.4/scout">laravel-scout</a>，所以就不需要像以前那样使用第三方的包了，不过令人伤心的是在<a href="https://github.com/laravel/scout/tree/2.0">scout v2.0</a>之后，es的支持就被剥离出核心项目了，当然如果想继续使用scout+es，可以使用<a href="https://github.com/ErickTamayo/laravel-scout-elastic">laravel-scout-elastic</a>，这个库代码很少，包含了基本的api，使用很方便。</p>]]></summary>
</entry>
<entry>
    <title>php从mysql中获取真实字段类型</title>
    <link href="http://blog.iyue.club/posts/2016-08-22-php-pdo-results.html" />
    <id>http://blog.iyue.club/posts/2016-08-22-php-pdo-results.html</id>
    <published>2016-08-22T00:00:00Z</published>
    <updated>2016-08-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>刚接触新公司代码不熟悉框架，发现Model层返回的数据都是字符串类型的,这可不能忍，在restapi中字段类型是要固定的，不然接口文档不明确，客户端调用时可能也会出问题。</p>
<p>追查了一下发现这边低层连接mysql是用mysqli扩展连接的，主要查询操作是</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$result</span> = <span class="fu">mysqli_query</span><span class="ot">(</span><span class="kw">$handle</span><span class="ot">,</span> <span class="kw">$sql</span><span class="ot">);</span>
<span class="kw">$row</span> = <span class="fu">mysqli_fetch_assoc</span><span class="ot">(</span><span class="kw">$result</span><span class="ot">);</span>
<span class="fu">mysqli_free_result</span><span class="ot">(</span><span class="kw">$result</span><span class="ot">);</span></code></pre></div>
<p>在这个地方打印 $row变量就是字符串了，导致后续的数据全部都是字符串类型。在php内部使用倒是没什么问题，毕竟php本身是弱类型的语言，字符串数字和纯数字基本没什么区别，但是在接口开发方面就会有很大问题，一个restapi首要就是文档清晰，如果连每个返回值的类型都不能正确给出那么在调用的时候就容易出现不可预测的事情。</p>
<p>在老的代码中总是看到类似<code>$fieldType</code>这样的变量用来存放一个表的名称类型映射，但是这样做比较傻，涉及到数据库字段类型变更的时候还得改model。在pdo-mysql驱动中，底层的mysql驱动是mysqlnd，这个比mysqli先进，能够查询出每一行的元数据(metadata)，由一个PDO选项<code>PDO::ATTR_EMULATE_PREPARES</code>来控制是否返回真实的类型，具体见下面的例子：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$servername</span> = <span class="st">&quot;localhost&quot;</span><span class="ot">;</span>
<span class="kw">$username</span> = <span class="st">&quot;root&quot;</span><span class="ot">;</span>
<span class="kw">$password</span> = <span class="st">&quot;123456&quot;</span><span class="ot">;</span>
<span class="kw">$conn</span> = <span class="kw">new</span> <span class="kw">PDO</span><span class="ot">(</span><span class="st">&quot;mysql:host=</span><span class="kw">$servername</span><span class="st">;dbname=testdb&quot;</span><span class="ot">,</span> <span class="kw">$username</span><span class="ot">,</span> <span class="kw">$password</span><span class="ot">);</span>
<span class="kw">$conn</span>-&gt;setAttribute<span class="ot">(</span><span class="kw">PDO</span>::<span class="kw">ATTR_EMULATE_PREPARES</span><span class="ot">,</span> <span class="kw">false</span><span class="ot">);</span>
<span class="kw">$sql</span> = <span class="st">&quot;select * from test_table where id=1&quot;</span><span class="ot">;</span>
<span class="kw">$sth</span> = <span class="kw">$conn</span>-&gt;prepare<span class="ot">(</span><span class="kw">$sql</span><span class="ot">);</span>
<span class="kw">$sth</span>-&gt;execute<span class="ot">();</span>
<span class="kw">$row</span> = <span class="kw">$sth</span>-&gt;fetch<span class="ot">();</span></code></pre></div>
<p>如果不加<code>$conn-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);</code>这一行，返回值都是字符串类型，加了之后就能正确返回类型了。</p>
<p>laravel的eloquent ORM很强大，看了一下底层连接db的代码，在<a href="https://github.com/laravel/framework/blob/5.3/src/Illuminate/Database/Connectors/Connector.php">framework/src/Illuminate/Database/Connectors/Connector.php</a>设置好的默认选项中就有这个，果然是自己写的代码越少，犯错的机会就越少，框架和软件的设计思想都应该把易用性和可配置性放到第一位，而且要做到把默认值设置为普遍最佳方案，这样开发者才能有更多精力专注业务开发，做更多充满创造力的事情，而不是花几十分钟去搜索这种尝试性的问题。喜欢自己开发框架，但是又写不出好框架的团队是一个差劲的团队。</p>]]></summary>
</entry>
<entry>
    <title>如何不要脸与低三下四</title>
    <link href="http://blog.iyue.club/posts/2016-08-11-github-coupon.html" />
    <id>http://blog.iyue.club/posts/2016-08-11-github-coupon.html</id>
    <published>2016-08-11T00:00:00Z</published>
    <updated>2016-08-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>8月8号的时候github把我的教育网优惠资格给停用了，然后还给我发了一个邮件让我去绑定信用卡，这种事情真是不能忍，我3月底的时候收到一次邮件告诉我说我的教育网资格到期了，然后我就被自动降级为普通用户了，但是5月份之后我发现我还是可以继续用私有仓库的，说明我还是教育网用户，赶紧迁移了几个私有项目到github上面，结果问题就来了，周一又给我取消了，接下来就是连续的不要脸邮件对话，具体内容见下，我以为我踩中了他们系统的bug，要求他们给我补偿，但是他们却一口咬定我是8号正常到期，想我去绑定信用卡，就这样你来我往地回复了几封邮件，最后被额外送3个月优惠期，等于是用21美刀就把我打发了，我还以为至少能送我1年，挺郁闷的，不过github客服还是挺耐心的，到最后估计鄙视死我了哈哈。邮件对话见下，这么蹩脚的英文人家也能听懂，给自己点个赞。</p>
<pre>
Gmail	Joey Xie <joey.xf@gmail.com>
Re: I was an education pack user and now can't use private repository
6 messages
Andrew (GitHub Staff) <support@github.com>	Wed, Aug 10, 2016 at 6:03 PM
To: Joey <joey.xf@gmail.com>
Hey Joey,

Sorry for any confusion! Your account was upgraded to a paid plan when you applied for a coupon a couple of years ago. The coupon covered the whole cost of a Micro plan, but after two years, the coupon expired while the account stayed at the Micro level (now referred to as Unlimited Private Repositories due to a change in our pricing structure).

Our system tried to charge you for the next month of service at the Unlimited Private Repositories rate, but as our other email noted, you don't have a card on file. That email is sent automatically to users with expired coupons of all types (not just education discounts) to let you know you'll need to sort out your payment method.

If you still qualify for a coupon, you can reapply for another educational discount coupon here:

https://education.github.com/discount_requests/new

If you are no longer qualified, you can either add a valid payment method following the link in the earlier email, or downgrade the account to a Free plan following these steps:

https://help.github.com/articles/downgrading-a-user-account-to-free

Hope that clears things up, and please do let us know if you have any other questions.

All the best,
Andrew

Joey Xie <joey.xf@gmail.com>	Thu, Aug 11, 2016 at 1:58 AM
To: "Andrew (GitHub Staff)" <support@github.com>
Dear Andrew,

In Mar 21 2014 you ended my education account and down grade me to free user but after May 11 2016 https://github.com/blog/2164-introducing-unlimited-private-repositories I can again use private repositories, so I migrated several private project to github. Now again you told me that I have no access to my private repository. I feel bad, my personal projects use these repositories. I hope you can be a nice personal since Amazon pay for their wrong orders but not customers.
[Quoted text hidden]
Andrew (GitHub Staff) <support@github.com>	Thu, Aug 11, 2016 at 2:33 AM
To: Joey Xie <joey.xf@gmail.com>
Hey Joey,

The educational discount coupon expired on Mar 20 2016, at which point your account should have locked, and you would've been asked to either downgrade your plan to the free tier, or add a payment method to your account, in order to maintain access to your private repositories.

That process was delayed until this Monday, at which point your account was updated to reflect the expired coupon.

Our announcement regarding unlimited private repositories doesn't change anything in terms of the current situation, as (I'm sure you noted from reading the blog post) only paid accounts can benefit from unlimited private repositories.

I've unlocked your account temporarily, so you can access your private repositories for the time being. If you wish to benefit from another educational discount, you can submit an application here:

https://education.github.com/discount_requests/new

Alternatively, you can update your account with a payment method, as instructed in my last email.

If you have any further questions about this, just let me know - I'm happy to help!

All the best,
Andrew

Joey Xie <joey.xf@gmail.com>	Thu, Aug 11, 2016 at 10:11 AM
To: "Andrew (GitHub Staff)" <support@github.com>
Hi Andrew

I'm sure after Mar 20 I can't access my private repositories, but after this May I again can use private repository, So I think it's your fault that make me migrate my personal work to github, can you please make some compensate for me? I'm a poor programmer in China, I get a low salary have to work long hours everyday, can't afford a car or a house. You are so nice, can't you just give me a surprise thanks.
[Quoted text hidden]
Andrew (GitHub Staff) <support@github.com>	Thu, Aug 11, 2016 at 5:05 PM
To: Joey Xie <joey.xf@gmail.com>
Hi Joey,

The previous coupon you had gave you free private repositories from March 21 2014, right up until last Monday.

I have applied another coupon to your account, to cover the next three months, but after that time, you will need to downgrade to the free plan, or add a payment method to your account.

If you have any further questions, please let me know.

All the best,
Andrew

Joey Xie <joey.xf@gmail.com>	Thu, Aug 11, 2016 at 5:17 PM
To: "Andrew (GitHub Staff)" <support@github.com>
thanks Andrew, you saved me 21 bucks, I thought you would give me at lease another 1 year coupon, but again thanks.
[Quoted text hidden]
</pre>]]></summary>
</entry>
<entry>
    <title>递归地删除数组里面所有多余的空格</title>
    <link href="http://blog.iyue.club/posts/2016-08-07-recursive-remove-space.html" />
    <id>http://blog.iyue.club/posts/2016-08-07-recursive-remove-space.html</id>
    <published>2016-08-07T00:00:00Z</published>
    <updated>2016-08-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>在使用<a href="https://github.com/jdorn/json-editor">jsoneditor</a>的时候遇到一个问题就是总是会把多余的空格写入数据库，如：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$a</span> = <span class="ot">[</span><span class="st">&#39;a&#39;</span> =&gt; <span class="st">&#39; hello&#39;</span><span class="ot">,</span> <span class="st">&#39;b&#39;</span> =&gt; <span class="st">&#39;world &#39;</span><span class="ot">,</span> <span class="st">&#39;c&#39;</span> =&gt; <span class="st">&#39; he &#39;</span><span class="ot">];</span></code></pre></div>
<p>很多情况下我们都不需要开头结尾的空格，有时候空格甚至会带来麻烦，比如说图片地址后面加上空格之后就给前端操作带来麻烦，那么有什么好办法在写入数据库之前先过滤一遍呢？</p>
<p>对于上面这种对象数组处理方式很简单：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$a</span> = <span class="fu">array_map</span><span class="ot">(</span><span class="st">&#39;trim&#39;</span><span class="ot">,</span> <span class="kw">$a</span><span class="ot">);</span></code></pre></div>
<p>但是如果数组结构复杂，比如说是二维数组</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$a</span> = <span class="ot">[</span><span class="st">&#39;a&#39;</span> =&gt; <span class="st">&#39; hello&#39;</span><span class="ot">,</span> <span class="st">&#39;b&#39;</span> =&gt; <span class="st">&#39;world &#39;</span><span class="ot">,</span> <span class="st">&#39;c&#39;</span> =&gt; <span class="st">&#39; he &#39;</span><span class="ot">,</span> <span class="st">&#39;d&#39;</span> =&gt; <span class="ot">[</span><span class="st">&#39;a&#39;</span> =&gt; <span class="st">&#39; hello&#39;</span><span class="ot">,</span> <span class="st">&#39;b&#39;</span> =&gt; <span class="st">&#39;world &#39;</span><span class="ot">,</span> <span class="st">&#39;c&#39;</span> =&gt; <span class="st">&#39; he &#39;</span><span class="ot">]];</span></code></pre></div>
<p>这时候就要有一个机制能够递归的处理每隔元素内部的空格，思路就是递归，代码见下：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$myfunc</span> = <span class="kw">function</span> <span class="ot">(</span>&amp;<span class="kw">$value</span><span class="ot">,</span> <span class="kw">$key</span><span class="ot">)</span> <span class="kw">use</span> <span class="ot">(</span>&amp;<span class="kw">$myfunc</span><span class="ot">)</span> {
    <span class="kw">if</span> <span class="ot">(</span><span class="fu">is_array</span><span class="ot">(</span><span class="kw">$value</span><span class="ot">))</span> {
        <span class="fu">array_walk</span><span class="ot">(</span><span class="kw">$value</span><span class="ot">,</span> <span class="kw">$myfunc</span><span class="ot">);</span>
    } <span class="kw">else</span> {
        <span class="kw">$value</span> = <span class="fu">trim</span><span class="ot">(</span><span class="kw">$value</span><span class="ot">);</span>
    }
}<span class="ot">;</span>
<span class="fu">array_walk</span><span class="ot">(</span><span class="kw">$a</span><span class="ot">,</span> <span class="kw">$myfunc</span><span class="ot">);</span></code></pre></div>
<p>普通函数的递归很好写，但是匿名函数的递归就是第一次写来，竟然需要用use来把当前函数导入进闭包里面，而且必需以传引用的方式，php的语法也是丑得可以。</p>]]></summary>
</entry>
<entry>
    <title>eloquent高级用法</title>
    <link href="http://blog.iyue.club/posts/2016-07-18-delve-into-eloquent.html" />
    <id>http://blog.iyue.club/posts/2016-07-18-delve-into-eloquent.html</id>
    <published>2016-07-18T00:00:00Z</published>
    <updated>2016-07-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>常见的关系模型有1对1,1对多，多对多，在一个model中描述这些关系用<code>hasOne</code>, <code>hasMany</code>, <code>belongsTo</code>, <code>belongsToMany</code>就够了，但是最近遇到一个新的情况要用到更复杂的关系模型，就是polymorphic relation，按照<a href="https://en.wikipedia.org/wiki/Polymorphic_association">wikipedia</a> 的说法，这个概念是在ORM开发中提出来的，<a href="https://laravel.com/docs/5.2/eloquent-relationships">laravel</a>和<a href="http://guides.rubyonrails.org/association_basics.html">rails</a>中很好的实现了多态关系。第一次遇到这个问题的时候没见过，以为能用自带的1对多关系解决，但是在经过一番尝试之后没法优雅的解决我的问题，所以求助了<a href="https://stackoverflow.com/questions/38433109/eloquent-belongsto-determine-relation-table">stackoverflow</a>，很快就有网友提示了正确的思路，避免我在错误的道路上越走越远，今天就来总结一下我的问题吧。</p>
<p>在项目中有一些资源表，如games, news, songs，现在的需求要针对每种资源都能进行评论，所以还有一个评论表，但是在评论表中得区分是对什么资源的评论，所以用<code>commentable_id</code>和<code>commentable_type</code>来标识一个可被评论项实体。最初建表的时候是打算用<code>item_id</code>和<code>item_type</code>这2个字段的，但是按照laravel和ruby官方文档的建议，我还是改为以<code>able</code>结尾的单词了，我的model见下:</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> Game
{
    <span class="kw">public</span> <span class="kw">function</span> comment<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;morphMany<span class="ot">(</span>Comment::<span class="kw">class</span><span class="ot">,</span> <span class="st">&#39;commentable&#39;</span><span class="ot">);</span>
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> News
{
    <span class="kw">public</span> <span class="kw">function</span> comment<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;morphMany<span class="ot">(</span>Comment::<span class="kw">class</span><span class="ot">,</span> <span class="st">&#39;commentable&#39;</span><span class="ot">);</span>
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> Comment
{
    <span class="kw">public</span> <span class="kw">function</span> commentable<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;morphTo<span class="ot">();</span>
    }
    <span class="kw">public</span> <span class="kw">function</span> getCommentableTypeAttribute<span class="ot">(</span><span class="kw">$value</span><span class="ot">)</span>
    {
        <span class="kw">if</span> <span class="ot">(</span><span class="kw">$value</span> == <span class="st">&#39;App\Model\Game&#39;</span><span class="ot">)</span> {
            <span class="kw">return</span> <span class="st">&#39;game&#39;</span><span class="ot">;</span>
        } <span class="kw">else</span> {
            <span class="kw">return</span> <span class="st">&#39;news&#39;</span><span class="ot">;</span>
        }
    }
    <span class="kw">public</span> <span class="kw">function</span> author<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;belongsTo<span class="ot">(</span>User::<span class="kw">class</span><span class="ot">,</span> <span class="st">&#39;author_id&#39;</span><span class="ot">);</span>
    }
}</code></pre></div>
<p>在获取一个用户发布的所有评论时，可以使用</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$comments</span> = Comment::where<span class="ot">(</span><span class="st">&#39;author_id&#39;</span><span class="ot">,</span> <span class="st">&#39;=&#39;</span><span class="ot">,</span> <span class="kw">$id</span><span class="ot">)</span>
    -&gt;with<span class="ot">(</span><span class="st">&#39;commentable&#39;</span><span class="ot">)</span>
    -&gt;paginate<span class="ot">();</span></code></pre></div>
<p>通过打印这行的查询日志发现总共有4条查询语句:</p>
<ol style="list-style-type: decimal">
<li><p>查询用户的总评论数，分页时用到</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="fu">count</span>(*) <span class="kw">as</span> aggregate <span class="kw">from</span> `comments` <span class="kw">where</span> `author_id` = ?</code></pre></div></li>
<li><p>查询评论本身的信息</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> `comments` <span class="kw">where</span> `author_id` = ? <span class="kw">limit</span> <span class="dv">15</span> offset <span class="dv">0</span></code></pre></div></li>
<li><p>查询发布评论的人的信息</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> `users` <span class="kw">where</span> `users`.`id` <span class="kw">in</span> (?)</code></pre></div></li>
<li><p>查询被评论物的详细信息</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> `games` <span class="kw">where</span> `games`.`id` <span class="kw">in</span> (?) <span class="kw">and</span> `status` = ?</code></pre></div></li>
</ol>
<p>一行代码对应4条查询，使用eloquent的优点由此可见，省去了很多自己手写查询的精力。</p>
<p>另一个查询这种数据模型的思路是关联查询，</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> c.id <span class="kw">as</span> comment_id, c.commentable_id, g.name <span class="kw">as</span> title <span class="kw">from</span> comments <span class="kw">as</span> c <span class="kw">left</span> <span class="kw">join</span> games <span class="kw">as</span> g <span class="kw">on</span> c.commentable_id=g.id <span class="kw">where</span> c.commentable_type=<span class="st">&#39;App</span><span class="ch">\\</span><span class="st">Model</span><span class="ch">\\</span><span class="st">Game&#39;</span> <span class="kw">union</span> <span class="kw">select</span> c.id <span class="kw">as</span> comment_id, c.commentable_id, n.title <span class="kw">as</span> title <span class="kw">from</span> comments <span class="kw">as</span> c <span class="kw">left</span> <span class="kw">join</span> news <span class="kw">as</span> n <span class="kw">on</span> c.commentable_id=n.id <span class="kw">where</span> c.commentable_type=<span class="st">&#39;App</span><span class="ch">\\</span><span class="st">Model</span><span class="ch">\\</span><span class="st">News&#39;</span>;</code></pre></div>
<p>开始是打算动态选择如何管理资源表的，后来尝试之后发现只能用union合并2条查询的结果，手写查询还是不如eloquent优雅。</p>]]></summary>
</entry>
<entry>
    <title>laravel密码生成与校验机制</title>
    <link href="http://blog.iyue.club/posts/2016-07-08-laravel-password.html" />
    <id>http://blog.iyue.club/posts/2016-07-08-laravel-password.html</id>
    <published>2016-07-08T00:00:00Z</published>
    <updated>2016-07-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>在irc上听到有人说他们的应用改了.env中的APP_KEY之后就无法登录了，太奇怪了，在本地测试了几个例子都没有复现，决定详细看看这块</p>
<p>在注册的时候生成密码的密文，内置了一个叫做<a href="https://github.com/laravel/framework/blob/5.2/src/Illuminate/Foundation/helpers.php#L180">bcrypt</a>的函数来加密明文密码，实际密码生成是在<a href="https://github.com/laravel/framework/blob/5.2/src/Illuminate/Hashing/BcryptHasher.php#L26">BcryptHasher#make</a>中，使用blowfish算法来生成密文，不带参数使用的cost是10</p>
<p>再看看密码验证这部分 实际校验是在<a href="https://github.com/laravel/framework/blob/5.2/src/Illuminate/Auth/EloquentUserProvider.php#L114">EloquentUserProvider#validateCredentials</a>，调用BcryptHasher#check来校验，关于laravel和php的加密有<a href="https://mnshankar.wordpress.com/2014/03/29/laravel-hash-make-explained/">一篇很好的文章</a>讲述了blowfish这个算法的作用，盐和加密变换次数都存放在密码本身，所以密码的生成和校验完全和APP_KEY无关，别害怕使用<code>php artisan key:generate</code>，这个命令只会让session失效</p>]]></summary>
</entry>

</feed>
