<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Joey's blog</title>
    <link href="http://blog.iyue.club/rss.xml" rel="self" />
    <link href="http://blog.iyue.club" />
    <id>http://blog.iyue.club/rss.xml</id>
    <author>
        <name>Joey Xie</name>
        <email>joey.xf@gmail.com</email>
    </author>
    <updated>2015-12-26T00:00:00Z</updated>
    <entry>
    <title>从prelude切换到spacemacs</title>
    <link href="http://blog.iyue.club/posts/2015-12-26-switch-to-spacemacs.html" />
    <id>http://blog.iyue.club/posts/2015-12-26-switch-to-spacemacs.html</id>
    <published>2015-12-26T00:00:00Z</published>
    <updated>2015-12-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="最初的配置">最初的配置</h2>
<h3 id="基本的配置文件">基本的配置文件</h3>
<p>使用prelude作为基本配置文件，加上自定义的改动</p>
<h3 id="自定义配置文件">自定义配置文件</h3>
<ul>
<li>编辑personal/下面的文件，添加自定义配置</li>
<li>使用customize方法来自动生成配置</li>
</ul>
<h3 id="从elpa或者是melpa上面下载别人贡献的包">从elpa或者是melpa上面下载别人贡献的包</h3>
<h2 id="目前的配置">目前的配置</h2>
<h3 id="spacemacs">spacemacs</h3>
<p>所有配置都使用spacemacs的规则</p>
<h2 id="切换的原因">切换的原因</h2>
<h3 id="设计思想的不同">设计思想的不同</h3>
<p>spacemacs讲究配置文件分层，对于个人的配置文件设置有很严格的要求，便于大家交换配置文件</p>
<h3 id="界面不同">界面不同</h3>
<p>spacemacs的ui也很美观，下面的状态条非常漂亮</p>
<h3 id="社区活跃程度">社区活跃程度</h3>
<p>现在spacemacs社区很活跃，每天都有人提交代码，算是emacs社区目前最活跃的一个项目了</p>
<h3 id="纯粹喜新厌旧">纯粹喜新厌旧</h3>
<p>不折腾就不叫做极客</p>
<h2 id="切换之后的感受">切换之后的感受</h2>
<h3 id="每一次变更都是一个痛苦的经历">每一次变更都是一个痛苦的经历</h3>
<p>切换过来之后很多快捷键都不同了，导致有点痛苦，新的学习曲线</p>
<h3 id="习惯让生活更高效">习惯让生活更高效</h3>
<p>原来使用prelude的快捷键，基本按键都是遵循emacs默认的按键，比如说helm的快捷键也是， 按键设置没有规律，现在spacemacs的快捷键基本都统一格式了，我喜欢一致性</p>
<h3 id="养成一个好习惯很重要">养成一个好习惯很重要</h3>
<p>工具是有好坏之分的，如果不相信这句话而是一味的认为工具不重要，人才是最终要的，这样下去 就会让工作生活效率越来越低下</p>]]></summary>
</entry>
<entry>
    <title>创建自己的composer包</title>
    <link href="http://blog.iyue.club/posts/2015-12-15-create-composer-package.html" />
    <id>http://blog.iyue.club/posts/2015-12-15-create-composer-package.html</id>
    <published>2015-12-15T00:00:00Z</published>
    <updated>2015-12-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>最近在做服务重构与模块化的工作，以前的老代码太多复制粘贴的东西，需要整理一下，否则 将来项目就不可维护了</p>
<p>涉及到的服务有：</p>
<ol style="list-style-type: decimal">
<li>api 主要的接口模块，大部分客户端交互由这个接口完成</li>
<li>image 图片服务，图片上传下载压缩等操作</li>
<li>chat 聊天服务</li>
</ol>
<p>目前的架构就是这样的，等将来还可以继续拆分api接口，独立出更多小功能</p>
<p>在api和image中都会用到mq来与后端的java服务通信，原来的实现是自己封装的mq，同一个功能实现2次， 现在抽象出mq功能作为一个公共库，让这2个服务都能调用同一个mq的库。</p>
<p>主要涉及到的工具是composer，真是一个强大的武器。</p>
<ol style="list-style-type: decimal">
<li>创建库</li>
</ol>
<ul>
<li>新建一个目录，<code>mkdir mqpackage</code></li>
<li>切换进目录执行<code>composer init</code> 根据提示内容创建<code>composer.json</code>文件</li>
<li>按照要求自己编辑这个json文件，比较重要的就是require和autoload这块</li>
<li>然后就是敲代码了</li>
</ul>
<ol start="2" style="list-style-type: decimal">
<li>提交package到git仓库</li>
</ol>
<ul>
<li>因为是在公司里开发的项目，不敢放到github上，推送到内部的git服务器了</li>
</ul>
<ol start="3" style="list-style-type: decimal">
<li>配置项目的composer.json文件，引入刚刚新增的库</li>
</ol>
<ul>
<li>在项目的<code>composer.json</code>文件中的require区域加上上面的包要注意的就是要在repository里面加上这个包的地址，因为默认会从packgist上面拉</li>
</ul>
<ol start="4" style="list-style-type: decimal">
<li>重新测试一遍原有的2个服务的功能</li>
</ol>
<ul>
<li>创建单元测试写测试是很重要的，尤其是写这种公共库，我也是对照这phpunit的文档一点一点的敲测试用例的</li>
</ul>]]></summary>
</entry>
<entry>
    <title>博客从octopress迁移到hakyll</title>
    <link href="http://blog.iyue.club/posts/2015-12-10-switch-to-hakyll.html" />
    <id>http://blog.iyue.club/posts/2015-12-10-switch-to-hakyll.html</id>
    <published>2015-12-10T00:00:00Z</published>
    <updated>2015-12-10T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h3 id="准备完全迁移到hakyll上面了">准备完全迁移到hakyll上面了</h3>
<p>之前的博客是使用octopress搭建的，这个静态站点生成器最大的好处就是简单，不需要自己额外的hack，装好octopress，简单设置好之后就能使用，而且提交，部署都有 现成的工具，主题也有很多，所以一用就用了一年多。从7月份开始就有点厌倦octopress了，因为不喜欢这么傻瓜式的东西，咱们的目标是to be a geeker，当然不能一直 不进步。hakyll算是非常极客的一个工具了，haskell写的，使用pandoc处理文本，而且配置文件完全是haskell代码，想着能用这么geek的语言，玩这么geek的软件，就 非常激动。</p>
<p>使用hakyll也非常简单，步骤是:</p>
<ol style="list-style-type: decimal">
<li><code>cabal install hakyll</code> 安装hakyll，这一步非常耗时，因为自己的笔记本CPU落伍了。</li>
<li><code>hakyll-init blog</code> 会在当前目录下创建一个叫作blog的目录。</li>
<li><code>cd blog</code> 进入这个目录，会发现有一系列文件，这是默认的博客站点。</li>
<li><code>cabal build</code> 默认会build这个haskell站点，生成站点可执行文件。</li>
<li><code>dist/build/site/site build</code> 会编译<code>posts/</code>下面的文件，生成html文件到<code>_site/posts/</code>下面。</li>
<li><code>dist/build/site/site watch</code> 会开启一个web服务器，默认访问地址是http://127.0.0.1:4000/ 点击访问，然后就你发现默认的首页了。</li>
<li>默认站点好了接下来就是迁移原博客的文章，从原来的git仓库中把所有的markdown文件复制到<code>posts/</code>下面。</li>
<li>再次试着build整个站点，这时候可能会有点问题，我这里因为有的文章元数据中categories:熟悉为空报了几个错，改完就好了。</li>
<li>配置博客站点，修改站点外观，添加rss和tag页，我用的是<a href="https://github.com/eakron/variadic.me">variadic</a>的配置，很简单，配置文件改动很小但是 却把我要的功能都实现了，真的很厉害。</li>
<li>再次build，并且watch新的项目，顺利跑通了之后，但是看不到标签，很奇怪，原来老的文章是使用categories作为标签名的，现在使用tags了，自然要改。 <code>sed -i 's/categories\:/tags\:/g'</code> 一行sed命令，批量替换，真不错。</li>
<li>博客在本地搭好了，并且预览过了，接下来就是部署到线上，还是用github-pages。那么我就需要2个分支，一个source分支用来存放静态站点的代码，包括站点 配置，原始markdown格式的博文，这样将来要换到别的机器上，直接clone source分支的代码下来build就行了。还有一个分支是master分支，这个分支存放build之后 的文件，也就是所有的静态文件，html, css, js, 图片等。因为我线上已经有一个博客站点了，所以只需要添加远程github仓库就行。 <code>cd blog</code>进入我的博客根目录，执行<code>git init .</code> 添加版本控制, <code>git add .</code>, <code>git commit -m 'first commit'</code>, <code>git checkout -b source</code>切换到 source分支，然后删掉master分支<code>git branch -d master</code>，因为代码只要保存在source，master只能放生成的静态文件。<code>git remote add origin git@github.com:xcaptain/xcaptain.github.io</code>添加我的远程仓库， 要注意编辑.gitignore文件，把_site, _tmp, _cache都忽略掉。然后是<code>git submodule add git@github.com:xcaptain/xcaptain.github.io.git _site/</code>把 线上的master分支作为我的一个模块，克隆到_site目录下。再执行一下<code>dist/build/site/site build</code>会生成新的静态文件写入_site/目录，当然那些老的文件不会被 删掉，比如说我之前的CNAME文件，favicon文件都还留着，这时候<code>cd _site/</code>然后再提交一下。本地所有的代码都干净之后就是推送部署了。在<code>blog/</code>目录下执行 <code>git push origin source</code>把当前分支推送到origin的source分支，然后再切换到<code>_site/</code>目录，执行<code>git push origin master</code>把生成的静态文件推送到线上的 master分支。访问<a href="http://blog.iyue.club" class="uri">http://blog.iyue.club</a>开测，真不错。</li>
</ol>
<p>虽然说没有了octopress那么多做好的功能，但是通过折腾hakyll学习到了很多知识，等以后优化这个部署流程的时候可以自己写脚本部署，省得总是自己多次写shell命令</p>]]></summary>
</entry>
<entry>
    <title>php使用rabbitmq队列处理数据推送</title>
    <link href="http://blog.iyue.club/posts/2015-09-14-php-use-rabbitmq.html" />
    <id>http://blog.iyue.club/posts/2015-09-14-php-use-rabbitmq.html</id>
    <published>2015-09-14T00:00:00Z</published>
    <updated>2015-09-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="使用rabbitmq作为消息队列软件">使用rabbitmq作为消息队列软件</h2>
<h3 id="为什么使用rabbitmq">为什么使用rabbitmq</h3>
<h3 id="可选的队列软件">可选的队列软件</h3>
<h3 id="安装及配置rabbitmq">安装及配置rabbitmq</h3>
<h2 id="使用eloquent来操作模型">使用Eloquent来操作模型</h2>
<h3 id="为什么使用eloquent">为什么使用Eloquent</h3>
<ol style="list-style-type: decimal">
<li><p>Propel</p></li>
<li><p>Doctrine2</p></li>
<li><p>eloquent</p></li>
</ol>
<h3 id="eloquent处理sharding">eloquent处理sharding</h3>
<h2 id="处理拉取逻辑">处理拉取逻辑</h2>
<h3 id="表结构设计">表结构设计</h3>
<h3 id="如何获得最新的信息流">如何获得最新的信息流</h3>]]></summary>
</entry>
<entry>
    <title>学习使用postgresql</title>
    <link href="http://blog.iyue.club/posts/2015-07-22-use-postgresql.html" />
    <id>http://blog.iyue.club/posts/2015-07-22-use-postgresql.html</id>
    <published>2015-07-22T00:00:00Z</published>
    <updated>2015-07-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>对mysql有点厌倦了，因为用的人多就会导致产品趋于平凡，就算是mariadb也是一样，所以有必要了解一下postgresql。</p>
<p>首先讲讲postgresql的安装配置吧，我是从<a href="https://wiki.debian.org/PostgreSql">debian官方</a>上面找到的wiki， 操作很简单，但是首先就感觉postgresql和mysql的设计哲学有点区别。要让一个用户能够访问pgsql的数据库，首先得在 操作系统上面创建对应的用户，然后用postgres这个默认的超级用户去连接默认的postgres数据库，连接上之后再在服务器 里面创建一个同名的用户，然后是创建一个数据库，然后是分配数据库访问权限，感觉这个过程很繁琐而且有点反人类。像 mysql是不需要在操作系统上面创建用户的，直接create user就可以，然后设置密码，分配数据库访问权限。</p>
<p>接下来就是具体如何操作postgresql了，这部分得慢慢来，毕竟我刚学着用。</p>]]></summary>
</entry>
<entry>
    <title>php编码规范</title>
    <link href="http://blog.iyue.club/posts/2015-07-14-php-coding-style.html" />
    <id>http://blog.iyue.club/posts/2015-07-14-php-coding-style.html</id>
    <published>2015-07-14T00:00:00Z</published>
    <updated>2015-07-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>之前写代码的时候一直不是很在意编码规范的问题，感觉只要把代码功能实现了就OK，但是看到越来越多的优秀开 源项目都给自己的项目制定了编码规范，提交PR必须要满足规范才能合并到主干，而且自己搞php开发也已经有1 年了，得开始走向规范化开发的道路。</p>
<p>首先得介绍一下psr2，目前<a href="http://laravel.com/">laravel</a>项目使用的就是这个风格标准，具体的规定 在<a href="https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md">这里</a> 我以前的习惯大部分符合psr2的标准，但是因为渐渐的使用到了很多高级的php特性，比如说closure, trait, 抽象类等， 所以还是得纠正一点小的习惯。</p>
<p>除了psr2这个标准之外，各大公司也有自己内部使用的标准，比如说symfony, wordpress, squiz等，还是靠拢 国际标准吧，目前我的emacs里面的php-mode的设置就是psr2的标准，自动格式化代码省了点心。</p>
<p>代码写完了之后提交到github上却总是发现过不了持续集成(Continuous Integration)的审核，我自己目前几个个人 项目使用的是<a href="https://styleci.io/">styleci</a>这个在线审核的工具，功能很简单但是很强大，最初几次提交 总是会给我返回很多fail，导致严格要求自己按照编码规范来。</p>
<p>为了避免提交之后被styleci给鄙视，从网上找到了<a href="https://github.com/squizlabs/PHP_CodeSniffer">PHP_CodeSniffer</a>这个 小工具，叫做php嗅探器，它其实包括2个小部件，一个是phpcs(php coding style)，另一个是phpcbf(PHP Code Beautifier and Fixer)， 前者只检查代码的问题，后者还会帮忙纠正代码，如果信不过机器帮忙纠正代码，那么之前一定的记得提交代码。根据官方文档上的 说明修改配置，简单使用，效果很不错。后来我又找了一个叫做<a href="https://github.com/nishimaki10/emacs-phpcbf">emacs-phpcbf</a>的 小工具，这个是一个emacs的插件配置好之后可以集成到php-mode里面，稍加配置就可以在保存php文件的时候自动纠正错误。</p>
<p>后面发现通过phpcbf纠错的代码还是不能通过styleci，找了一下发现styleci用的是一个叫做<a href="https://github.com/FriendsOfPHP/PHP-CS-Fixer">php-cs-fixer</a> 的引擎来审核代码的，又对照着装了一个php-cs-fixer，和phpcbf的功能差不多，但是稍微严格一点，对于额外的空行也会删掉。</p>
<p>码农要往正规化方向走，现在养成一下编码规范的习惯，以后再来培养测试驱动的习惯。</p>]]></summary>
</entry>
<entry>
    <title>迁移一个discuz站点</title>
    <link href="http://blog.iyue.club/posts/2015-06-23-migrate-a-discuz-site.html" />
    <id>http://blog.iyue.club/posts/2015-06-23-migrate-a-discuz-site.html</id>
    <published>2015-06-23T00:00:00Z</published>
    <updated>2015-06-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>周五晚上帮同事迁移了一个网站，原来的<a href="http://www.huizu100.com">网站</a>是搭建在windows2003服务器上的，使用的是apache2 + php5.3 + mysql5.1 的架构，使用的是一个叫作PHPnow的一键安装包来管理服务器的，这种架构对于个人站长来说很方便，只要设置好了配置就可以自己搭建网站，但是扩展性特别差，简直就是没法维护，win2003本来就是老掉牙的技术了，这种服务器长期跑肯定是会有内存问题的，而用PHPnow搭建的网站，数据库，代码，数据都在一个目录里面，这样潜在的问题太大了，首先就是安全性问题，没有数据库本来应该单独放到一个专门的服务器上的。而且所有数据放在一起对于业务分离，备份也很不方便，一下备份一个几十G大的目录是很浪费资源的。</p>
<p>所以在我的建议下，周五晚上对这个网站做了一个迁移，新的架构是LNMP，ubuntu 15.04 server + nginx 1.6 + hhvm 3.7 + mariadb 10.0.20 + redis 3.0，当然因为服务器只有一台，所以没有做负载均衡，没有做数据库读写分离，也没有做hhvm的均衡，因为等我把环境搭建完的时候就已经很稳定了，所以暂时不打算那么做，下面简单的来说说迁移过程。</p>
<ol style="list-style-type: decimal">
<li><p>服务器安装 我给的建议是装ubuntu，因为将来环境稳定下来之后要把权限分给站长，让他自己上去查看管理一些进程，而ubuntu的桌面又是比较简单易用的。本来他们是打算安装ubuntu 15.04 desktop版的，但是因为这个版本没法驱动DELL r710服务器自带的硬Raid，所以最后换成server版了。</p></li>
<li><p>nginx，mariadb，hhvm，redis这些软件的安装都很简单，唯一一个比较特殊的功能就是用了hhvm来替换php，不过暂时没有感到太大的性能提升。LNMP环境搭建是很简单的，很快就完成了。</p></li>
<li><p>接下来是服务器配置 最大的问题就是调整分区结构，服务器上有一块300G的自带硬盘，这款盘其实是由2块一样的硬盘搭建的raid0，自带了数据备份功能，所以这块盘理论上来说是不该保存太多系统以外的东西的。然后是1块1T的绿盘，这块盘的年头比较老了，以前的网站就部署在这块盘上，我打算把这个盘拿来当备份盘，还有一块2T的黑盘，这块盘是一块最新最好的数据盘，所以我打算把网站和数据库都放在这块盘上。首先要把这块2T的盘里面的数据备份了，很重要的资料一定得保存，但是里面用PHPNow的工具全量备份了站点，一个备份40G，备份一周的数据，复制这些内容浪费了好多时间。数据备份完了之后就是给硬盘分区，先分区那块2T的盘，准备分4个区，按照300+300+600+600来分，虽然暂时没有想好具体怎么使用，用<code>fdisk /dev/sdb</code>开始分区，分区之后就是创建文件系统，只用ext4，所以<code>mkfs.ext4 /dev/sdbn</code>。</p></li>
<li><p>部署网站 这步就很简单了，直接复制代码，修改配置，修改权限，有一个比较大的问题是discuz的图片是存放在一个叫做<code>data/attachment</code>的目录下的，这些图片完全可以和代码分离，所以拿一块额外的分区来装就行，我是挂载的那个600G的分区到这个目录的。<code>mount /dev/sdb6 /pathtodata/attachment</code>。</p></li>
</ol>
<p>部署完成之后调试了一下网站就跑起来了，但是还有很多要做的事，discuz的代码结构比较混乱，不好改动，而且原来他的网站语言设置是GBK的，涉及到编码问题又更加复杂了，反正直到周日晚上才把问题全部解决，目前就是陆陆续续做一些服务器的小性能调优。</p>
<p>6月25日更新： 这几天陆陆续续发现了一些bug，有样式错误的，有插件报错的，有缓存不能及时清的等等，突然感觉压力好大，工作日只能下班之后有时间做自己的事，端午节3天假2天加一晚上都折腾那个网站去了，本以为是没什么事了，没想到后续的问题更多更麻烦，早知道就不轻易答应人家了，而且以后坚决不再折腾discuz，继续折腾这个东西只会浪费我更多时间。</p>]]></summary>
</entry>
<entry>
    <title>学习git</title>
    <link href="http://blog.iyue.club/posts/2015-06-01-learn-git.html" />
    <id>http://blog.iyue.club/posts/2015-06-01-learn-git.html</id>
    <published>2015-06-01T00:00:00Z</published>
    <updated>2015-06-01T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>继续学习git，把统计后台的代码从内部git服务器迁移到github上面了，用的是自己的私有仓库。</p>
<p>目前主要用到的功能有：</p>
<ol style="list-style-type: decimal">
<li><p>添加远程仓库 <code>git remote add origin https://github.com/xcaptain/simple-admin.git</code> 这样就能添加一个远程仓库了，等以后把代码push上去就行了，访问远程仓库的方式有2种，一种是ssh，一种是https，上面这种是https的仓库，也是github默认的访问仓库的方法， 因为ssh太不安全了，对于我们这种生活在封锁国度的老百姓来说，很容易被屏蔽。</p></li>
<li><p>往远程仓库里面提交代码 <code>git commit -m 'some comment'</code> 这样就可以提交代码，返回一个hash值标识的版本号，提交之后代码版本还在本地，如果要多方合作开发，那就得把改动保存到一个大家都可以访问的远程仓库， <code>git push origin master</code>，把本地版本推送到远程的master分支。</p></li>
<li><p>建立本地分支 <code>git branch dev</code> 这样就在本地创建了一个叫做dev的分支，并且会自动切换到这个dev分支，如果建了好多个分支，想查看当前自己在哪个分支，直接<code>git branch</code>就会列出，当然如果使用的是zsh或者是 fish这样的shell，一般都会有git的插件，可以显示当前所在分支。</p></li>
<li><p>把本地分支添加到远程仓库 <code>git checkout dev</code>切换到dev分支，然后<code>git push origin dev</code>就可以把代码推送到远程仓库的dev分支了。</p></li>
<li><p>打标签 <code>git tag</code>可以查看当前版本库的所有标签信息，如果要添加标签，那么就是<code>git tag -a v0.2 -m '优化流量统计代码，统一风格'</code>添加一个叫作v0.2的标签，并且提交。如果要把 本地的标签信息提交到远程仓库，那么就是<code>git push --tags</code>，然后去github上查看就能看到对应的v0.2版本了。</p></li>
<li><p>查看提交版本 <code>git log</code>, <code>git diff</code>，我一般喜欢用emacs的magit插件来查看diff和版本。</p></li>
<li><p>把未暂存的文件回滚 <code>git checkout file1</code>，这样会从版本库中检出上一个提交的file1的版本，覆盖掉当前这个未提交的版本。</p></li>
<li><p>回滚版本库 这个操作目前做得比较少，都是<code>git reset --hard HEAD~1</code>，来回到上一个版本的，对于这个操作还不熟悉，至少svn回滚已经是很熟悉的了。</p></li>
</ol>
<p>git的功能很强大也很复杂，但是一定是要掌握的，这样才能成为一个合格的项目经理，以后慢慢积累，有新的体会再来更新这篇博客。</p>]]></summary>
</entry>
<entry>
    <title>php的getter方法</title>
    <link href="http://blog.iyue.club/posts/2015-05-23-php-getter.html" />
    <id>http://blog.iyue.club/posts/2015-05-23-php-getter.html</id>
    <published>2015-05-23T00:00:00Z</published>
    <updated>2015-05-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>这几天做统计后台频繁用到一个叫做<a href="http://carbon.nesbot.com/">Carbon</a>的日期库，用多了发现这个库的接口设计得非常方便，方法非常自然，稍微用几次就知道用法了。比如说好多方法都是静态方法，省去了频繁构造对象的开销。最方便的还是里面的getter方法，<code>$dt-&gt;year</code>就返回了本年，这个year很明显是一个静态方法，因为$dt不是new出来的对象，但是我们看起来就好像是直接访问一个类的属性一样。</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> <span class="kw">A</span> {
    <span class="kw">public</span> <span class="kw">function</span> year<span class="ot">()</span> {
        <span class="kw">return</span> <span class="dv">2015</span><span class="ot">;</span>
    }
    <span class="kw">public</span> <span class="kw">static</span> <span class="kw">function</span> <span class="fu">__get</span><span class="ot">(</span><span class="kw">$var</span><span class="ot">)</span> {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;<span class="kw">$var</span><span class="ot">();</span>
    }
}
a = <span class="kw">new</span> <span class="kw">A</span><span class="ot">;</span>
<span class="fu">echo</span> a-&gt;year<span class="ot">;</span></code></pre></div>
<p>是getter的一种简单写法，挺不错的。</p>]]></summary>
</entry>
<entry>
    <title>mysql基础</title>
    <link href="http://blog.iyue.club/posts/2015-05-03-mysql-basics-1.html" />
    <id>http://blog.iyue.club/posts/2015-05-03-mysql-basics-1.html</id>
    <published>2015-05-03T00:00:00Z</published>
    <updated>2015-05-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>五一第二天泡国图看了一下午关于sql的书，小有所获，才发现以前工作中用到的只是mysql中的一个很小的子集，该好好整理一下了基础知识了，当然对于很基本，已经用得很熟练的知识就不提了。</p>
<h3 id="什么是sql语言">什么是sql语言</h3>
<p>sql语言包括： DDL（数据定义语言）：创建数据库，创建表，创建视图，创建索引等。 DML（数据操作语言）：也就是增删改查操作。 DCL（数据控制语言）：COMMIT，ROLLBACK，GRANT等。</p>
<h3 id="聚合查询">聚合查询</h3>
<p>聚合查询指的是把一张表的内容分组，相关操作包括<code>count</code>, <code>sum</code>, <code>min</code>, <code>max</code>, <code>avg</code>, <code>group by</code>, <code>having</code>，前面5个是聚合函数，从一大串结果中取出我们要的属性。 后面2个是分组的。<code>group by</code>的语法为:</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> &lt;col1&gt;, &lt;col2&gt;, &lt;col3&gt;
    <span class="kw">from</span> &lt;table_name&gt;
[<span class="kw">where</span> ...]
<span class="kw">group</span> <span class="kw">by</span> &lt;col1&gt;, &lt;col2&gt;, &lt;col3&gt;
[<span class="kw">having</span> ...]</code></pre></div>
<p>有一条限制说的是select子句中的每一个字段都必须出现在group by的子句中，但是我在mysql和postgresql中执行的时候结果确不一样，pgsql有这个限制，而mysql则松散得多。在我看来必须得严格才行，不然在有1对多关系的表中，group by之后的结果可能会让人莫名其妙，难怪很多人都说postgresql比mysql要严谨。</p>
<h3 id="事务">事务</h3>
<p>事务指的是把一系列操作封装在一起来执行，要么同时执行这一些列操作，要么一个都不执行。这个以前工作也用到的不多，可能公司是以前写代码的人对于这个也不看中吧，基本上都是直接update，insert了。记得以前用python的<code>MySQLdb</code>的时候，如果有插入操作必须手动调用一下commit方法才能把数据写进数据库，那时候还不理解，感觉多了一步操作实在是太麻烦了，现在看来把所有操作都看作事务来执行，手动提交事务对于数据来说还是很安全的。</p>
<p>事务有4个特性：（ACID）</p>
<ol style="list-style-type: decimal">
<li>原子性（Atomic）：事务是一个整体。</li>
<li>一致性（Consistency）：每个操作都必须满足对应列的约束条件。</li>
<li>隔离性（Isolation）：没一个事务中的数据对另一个事务都是不可见的，在提交操作之前，数据不在表里面。</li>
<li>持久性（Duration）：每个事务完成之后会有日志记录，方便从日志恢复数据。</li>
</ol>
<p>创建事务：</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">start</span> | <span class="kw">begin</span> <span class="kw">transaction</span>
sql1;
sql2;
...
<span class="kw">commit</span></code></pre></div>
<p>现在仔细想想原来看过好多同时更新多张表的代码没有走事务，那些业务真是太危险了，一张表的结构出错可能就导致整个业务逻辑崩溃。</p>
<h3 id="视图">视图</h3>
<p>视图类似与一张表，但是区别是表里面存放着数据，但是视图里面没有数据。可以用</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">create</span> <span class="kw">view</span> &lt;视图名&gt; [&lt;col1&gt;, &lt;col2&gt;]
<span class="kw">as</span>
<span class="kw">select</span> &lt;col1&gt;, &lt;col2&gt; ...
    <span class="kw">from</span>
&lt;表名&gt;</code></pre></div>
<p>来创建一个视图。视图主要是为调用很频繁的sql做的，省得每次都得写一大段sql，视图还可以层叠，也就是cascade，不过这功能又太偏了，单用view就已经很少了。不过不知道在view中执行查询有没有比直接在表中查询快，如果仅仅是为了sql简洁就发明视图这个概念出来那也太浪费了吧。</p>
<p>视图是子查询的基础，子查询可以看作是一个视图。</p>
<h3 id="表的集合操作">表的集合操作</h3>
<p>表在关系代数中其实就是集合，所以可以交集，并集，查集。</p>
<h3 id="表连结">表连结</h3>
<p>以前大学的时候学离散数学，数据库原理都讲了关系代数，但是才刚刚毕业一年就几乎忘光了，到目前只知道内联接外联接，连用形式化语言来描述连接都做不到，实在是辜负大学四年了，不过现在做应用开发，基本的理论知识看起来又有点鸡肋。</p>
<p>连接分为内联接，外联接。 inner join &lt;=&gt; join left outer join &lt;=&gt; left join right outer join &lt;=&gt; right join 尽量避免直接写outer join，这样会使语义模糊。</p>
<h3 id="基本查询惯例">基本查询惯例</h3>
<ol style="list-style-type: decimal">
<li>建表的时候用<code>primary key(id)</code>来创建主键，以前我都是喜欢写在一个列的限制性约束条件后面。</li>
<li>在表明不相等关系的时候使用<code>&lt;&gt;</code>而不是<code>!=</code>，前者才是标准写法。</li>
<li><code>char</code>类型是按照字典顺序来排序的，一直以来我都以为是按照ascii的顺序来排的。</li>
<li>在建表的时候尽量避免使用NULL这个变量，因为在查询中空值比较不好处理，不好比较大小，不好做运算，不好count，我也不打算去研究NULL在各种情况下的意义。判断一个字段是否为NULL用<code>IS NULL</code>来判断。</li>
</ol>]]></summary>
</entry>

</feed>
