<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Joey's blog</title>
    <link href="http://blog.iyue.club/rss.xml" rel="self" />
    <link href="http://blog.iyue.club" />
    <id>http://blog.iyue.club/rss.xml</id>
    <author>
        <name>Joey Xie</name>
        <email>joey.xf@gmail.com</email>
    </author>
    <updated>2016-09-03T00:00:00Z</updated>
    <entry>
    <title>安装和配置elasticsearch</title>
    <link href="http://blog.iyue.club/posts/2016-09-03-install-and-use-elasticsearch.html" />
    <id>http://blog.iyue.club/posts/2016-09-03-install-and-use-elasticsearch.html</id>
    <published>2016-09-03T00:00:00Z</published>
    <updated>2016-09-03T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p><a href="https://www.elastic.co/products/elasticsearch">elasticsearch</a>是一个非常优秀的搜索工具，比数据库的搜索功能好太多了，以下介绍elasticsearch的配置与应用，以下操作在ubuntu 16.04下进行</p>
<h3 id="安装">安装</h3>
<p>默认源安装的是老版本，如果想要用最新版本可以手动添加源</p>
<ol style="list-style-type: decimal">
<li><code>apt install default-jre default-jdk</code></li>
<li><code>wget -qO - https://packages.elastic.co/GPG-KEY-elasticsearch | apt-key add -</code></li>
<li><code>echo &quot;deb http://packages.elastic.co/elasticsearch/2.x/debian stable main&quot; | tee -a /etc/apt/sources.list.d/elasticsearch-2.x.list</code></li>
<li><code>apt install elasticsearch</code></li>
</ol>
<h3 id="启动">启动</h3>
<p><code>service elasticsearch start</code> 如果一切顺利，执行<code>curl 'http://localhost:9200'</code>的时候就可以正常返回一个json</p>
<h3 id="安装中文分词插件ik">安装中文分词插件<a href="https://github.com/medcl/elasticsearch-analysis-ik">ik</a></h3>
<ol style="list-style-type: decimal">
<li>安装mvn <code>apt install maven</code></li>
<li>按照github说明安装插件(elasticsearch对插件版本要求比较严格，有时候要自己改插件编译配置)</li>
</ol>
<h3 id="实际应用">实际应用</h3>
<p>在laravel/lumen中集成elasticsearch很方便，我喜欢的2个库是<a href="https://github.com/elasticquent/elasticquent">elasticquent/elasticquent</a>和<a href="https://github.com/nordsoftware/lumen-elasticsearch">nordsoftware/lumen-elasticsearch</a></p>
<p>elasticquent用来更新索引很方便，model更新的时候通过<a href="https://laravel.com/docs/5.3/eloquent#events">model event</a>来同步更新索引，lumen-elasticsearch主要是方便构造查询语句</p>]]></summary>
</entry>
<entry>
    <title>php从mysql中获取真实字段类型</title>
    <link href="http://blog.iyue.club/posts/2016-08-22-php-pdo-results.html" />
    <id>http://blog.iyue.club/posts/2016-08-22-php-pdo-results.html</id>
    <published>2016-08-22T00:00:00Z</published>
    <updated>2016-08-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>刚接触新公司代码不熟悉框架，发现Model层返回的数据都是字符串类型的,这可不能忍，在restapi中字段类型是要固定的，不然接口文档不明确，客户端调用时可能也会出问题。</p>
<p>追查了一下发现这边低层连接mysql是用mysqli扩展连接的，主要查询操作是</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$result</span> = <span class="fu">mysqli_query</span><span class="ot">(</span><span class="kw">$handle</span><span class="ot">,</span> <span class="kw">$sql</span><span class="ot">);</span>
<span class="kw">$row</span> = <span class="fu">mysqli_fetch_assoc</span><span class="ot">(</span><span class="kw">$result</span><span class="ot">);</span>
<span class="fu">mysqli_free_result</span><span class="ot">(</span><span class="kw">$result</span><span class="ot">);</span></code></pre></div>
<p>在这个地方打印 $row变量就是字符串了，导致后续的数据全部都是字符串类型。在php内部使用倒是没什么问题，毕竟php本身是弱类型的语言，字符串数字和纯数字基本没什么区别，但是在接口开发方面就会有很大问题，一个restapi首要就是文档清晰，如果连每个返回值的类型都不能正确给出那么在调用的时候就容易出现不可预测的事情。</p>
<p>在老的代码中总是看到类似<code>$fieldType</code>这样的变量用来存放一个表的名称类型映射，但是这样做比较傻，涉及到数据库字段类型变更的时候还得改model。在pdo-mysql驱动中，底层的mysql驱动是mysqlnd，这个比mysqli先进，能够查询出每一行的元数据(metadata)，由一个PDO选项<code>PDO::ATTR_EMULATE_PREPARES</code>来控制是否返回真实的类型，具体见下面的例子：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$servername</span> = <span class="st">&quot;localhost&quot;</span><span class="ot">;</span>
<span class="kw">$username</span> = <span class="st">&quot;root&quot;</span><span class="ot">;</span>
<span class="kw">$password</span> = <span class="st">&quot;123456&quot;</span><span class="ot">;</span>
<span class="kw">$conn</span> = <span class="kw">new</span> <span class="kw">PDO</span><span class="ot">(</span><span class="st">&quot;mysql:host=</span><span class="kw">$servername</span><span class="st">;dbname=testdb&quot;</span><span class="ot">,</span> <span class="kw">$username</span><span class="ot">,</span> <span class="kw">$password</span><span class="ot">);</span>
<span class="kw">$conn</span>-&gt;setAttribute<span class="ot">(</span><span class="kw">PDO</span>::<span class="kw">ATTR_EMULATE_PREPARES</span><span class="ot">,</span> <span class="kw">false</span><span class="ot">);</span>
<span class="kw">$sql</span> = <span class="st">&quot;select * from test_table where id=1&quot;</span><span class="ot">;</span>
<span class="kw">$sth</span> = <span class="kw">$conn</span>-&gt;prepare<span class="ot">(</span><span class="kw">$sql</span><span class="ot">);</span>
<span class="kw">$sth</span>-&gt;execute<span class="ot">();</span>
<span class="kw">$row</span> = <span class="kw">$sth</span>-&gt;fetch<span class="ot">();</span></code></pre></div>
<p>如果不加<code>$conn-&gt;setAttribute(PDO::ATTR_EMULATE_PREPARES, false);</code>这一行，返回值都是字符串类型，加了之后就能正确返回类型了。</p>
<p>laravel的eloquent ORM很强大，看了一下底层连接db的代码，在<a href="https://github.com/laravel/framework/blob/5.3/src/Illuminate/Database/Connectors/Connector.php">framework/src/Illuminate/Database/Connectors/Connector.php</a>设置好的默认选项中就有这个，果然是自己写的代码越少，犯错的机会就越少，框架和软件的设计思想都应该把易用性和可配置性放到第一位，而且要做到把默认值设置为普遍最佳方案，这样开发者才能有更多精力专注业务开发，做更多充满创造力的事情，而不是花几十分钟去搜索这种尝试性的问题。喜欢自己开发框架，但是又写不出好框架的团队是一个差劲的团队。</p>]]></summary>
</entry>
<entry>
    <title>如何不要脸与低三下四</title>
    <link href="http://blog.iyue.club/posts/2016-08-11-github-coupon.html" />
    <id>http://blog.iyue.club/posts/2016-08-11-github-coupon.html</id>
    <published>2016-08-11T00:00:00Z</published>
    <updated>2016-08-11T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>8月8号的时候github把我的教育网优惠资格给停用了，然后还给我发了一个邮件让我去绑定信用卡，这种事情真是不能忍，我3月底的时候收到一次邮件告诉我说我的教育网资格到期了，然后我就被自动降级为普通用户了，但是5月份之后我发现我还是可以继续用私有仓库的，说明我还是教育网用户，赶紧迁移了几个私有项目到github上面，结果问题就来了，周一又给我取消了，接下来就是连续的不要脸邮件对话，具体内容见下，我以为我踩中了他们系统的bug，要求他们给我补偿，但是他们却一口咬定我是8号正常到期，想我去绑定信用卡，就这样你来我往地回复了几封邮件，最后被额外送3个月优惠期，等于是用21美刀就把我打发了，我还以为至少能送我1年，挺郁闷的，不过github客服还是挺耐心的，到最后估计鄙视死我了哈哈。邮件对话见下，这么蹩脚的英文人家也能听懂，给自己点个赞。</p>
<pre>
Gmail	Joey Xie <joey.xf@gmail.com>
Re: I was an education pack user and now can't use private repository
6 messages
Andrew (GitHub Staff) <support@github.com>	Wed, Aug 10, 2016 at 6:03 PM
To: Joey <joey.xf@gmail.com>
Hey Joey,

Sorry for any confusion! Your account was upgraded to a paid plan when you applied for a coupon a couple of years ago. The coupon covered the whole cost of a Micro plan, but after two years, the coupon expired while the account stayed at the Micro level (now referred to as Unlimited Private Repositories due to a change in our pricing structure).

Our system tried to charge you for the next month of service at the Unlimited Private Repositories rate, but as our other email noted, you don't have a card on file. That email is sent automatically to users with expired coupons of all types (not just education discounts) to let you know you'll need to sort out your payment method.

If you still qualify for a coupon, you can reapply for another educational discount coupon here:

https://education.github.com/discount_requests/new

If you are no longer qualified, you can either add a valid payment method following the link in the earlier email, or downgrade the account to a Free plan following these steps:

https://help.github.com/articles/downgrading-a-user-account-to-free

Hope that clears things up, and please do let us know if you have any other questions.

All the best,
Andrew

Joey Xie <joey.xf@gmail.com>	Thu, Aug 11, 2016 at 1:58 AM
To: "Andrew (GitHub Staff)" <support@github.com>
Dear Andrew,

In Mar 21 2014 you ended my education account and down grade me to free user but after May 11 2016 https://github.com/blog/2164-introducing-unlimited-private-repositories I can again use private repositories, so I migrated several private project to github. Now again you told me that I have no access to my private repository. I feel bad, my personal projects use these repositories. I hope you can be a nice personal since Amazon pay for their wrong orders but not customers.
[Quoted text hidden]
Andrew (GitHub Staff) <support@github.com>	Thu, Aug 11, 2016 at 2:33 AM
To: Joey Xie <joey.xf@gmail.com>
Hey Joey,

The educational discount coupon expired on Mar 20 2016, at which point your account should have locked, and you would've been asked to either downgrade your plan to the free tier, or add a payment method to your account, in order to maintain access to your private repositories.

That process was delayed until this Monday, at which point your account was updated to reflect the expired coupon.

Our announcement regarding unlimited private repositories doesn't change anything in terms of the current situation, as (I'm sure you noted from reading the blog post) only paid accounts can benefit from unlimited private repositories.

I've unlocked your account temporarily, so you can access your private repositories for the time being. If you wish to benefit from another educational discount, you can submit an application here:

https://education.github.com/discount_requests/new

Alternatively, you can update your account with a payment method, as instructed in my last email.

If you have any further questions about this, just let me know - I'm happy to help!

All the best,
Andrew

Joey Xie <joey.xf@gmail.com>	Thu, Aug 11, 2016 at 10:11 AM
To: "Andrew (GitHub Staff)" <support@github.com>
Hi Andrew

I'm sure after Mar 20 I can't access my private repositories, but after this May I again can use private repository, So I think it's your fault that make me migrate my personal work to github, can you please make some compensate for me? I'm a poor programmer in China, I get a low salary have to work long hours everyday, can't afford a car or a house. You are so nice, can't you just give me a surprise thanks.
[Quoted text hidden]
Andrew (GitHub Staff) <support@github.com>	Thu, Aug 11, 2016 at 5:05 PM
To: Joey Xie <joey.xf@gmail.com>
Hi Joey,

The previous coupon you had gave you free private repositories from March 21 2014, right up until last Monday.

I have applied another coupon to your account, to cover the next three months, but after that time, you will need to downgrade to the free plan, or add a payment method to your account.

If you have any further questions, please let me know.

All the best,
Andrew

Joey Xie <joey.xf@gmail.com>	Thu, Aug 11, 2016 at 5:17 PM
To: "Andrew (GitHub Staff)" <support@github.com>
thanks Andrew, you saved me 21 bucks, I thought you would give me at lease another 1 year coupon, but again thanks.
[Quoted text hidden]
</pre>]]></summary>
</entry>
<entry>
    <title>递归地删除数组里面所有多余的空格</title>
    <link href="http://blog.iyue.club/posts/2016-08-07-recursive-remove-space.html" />
    <id>http://blog.iyue.club/posts/2016-08-07-recursive-remove-space.html</id>
    <published>2016-08-07T00:00:00Z</published>
    <updated>2016-08-07T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>在使用<a href="https://github.com/jdorn/json-editor">jsoneditor</a>的时候遇到一个问题就是总是会把多余的空格写入数据库，如：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$a</span> = <span class="ot">[</span><span class="st">&#39;a&#39;</span> =&gt; <span class="st">&#39; hello&#39;</span><span class="ot">,</span> <span class="st">&#39;b&#39;</span> =&gt; <span class="st">&#39;world &#39;</span><span class="ot">,</span> <span class="st">&#39;c&#39;</span> =&gt; <span class="st">&#39; he &#39;</span><span class="ot">];</span></code></pre></div>
<p>很多情况下我们都不需要开头结尾的空格，有时候空格甚至会带来麻烦，比如说图片地址后面加上空格之后就给前端操作带来麻烦，那么有什么好办法在写入数据库之前先过滤一遍呢？</p>
<p>对于上面这种对象数组处理方式很简单：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$a</span> = <span class="fu">array_map</span><span class="ot">(</span><span class="st">&#39;trim&#39;</span><span class="ot">,</span> <span class="kw">$a</span><span class="ot">);</span></code></pre></div>
<p>但是如果数组结构复杂，比如说是二维数组</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$a</span> = <span class="ot">[</span><span class="st">&#39;a&#39;</span> =&gt; <span class="st">&#39; hello&#39;</span><span class="ot">,</span> <span class="st">&#39;b&#39;</span> =&gt; <span class="st">&#39;world &#39;</span><span class="ot">,</span> <span class="st">&#39;c&#39;</span> =&gt; <span class="st">&#39; he &#39;</span><span class="ot">,</span> <span class="st">&#39;d&#39;</span> =&gt; <span class="ot">[</span><span class="st">&#39;a&#39;</span> =&gt; <span class="st">&#39; hello&#39;</span><span class="ot">,</span> <span class="st">&#39;b&#39;</span> =&gt; <span class="st">&#39;world &#39;</span><span class="ot">,</span> <span class="st">&#39;c&#39;</span> =&gt; <span class="st">&#39; he &#39;</span><span class="ot">]];</span></code></pre></div>
<p>这时候就要有一个机制能够递归的处理每隔元素内部的空格，思路就是递归，代码见下：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$myfunc</span> = <span class="kw">function</span> <span class="ot">(</span>&amp;<span class="kw">$value</span><span class="ot">,</span> <span class="kw">$key</span><span class="ot">)</span> <span class="kw">use</span> <span class="ot">(</span>&amp;<span class="kw">$myfunc</span><span class="ot">)</span> {
    <span class="kw">if</span> <span class="ot">(</span><span class="fu">is_array</span><span class="ot">(</span><span class="kw">$value</span><span class="ot">))</span> {
        <span class="fu">array_walk</span><span class="ot">(</span><span class="kw">$value</span><span class="ot">,</span> <span class="kw">$myfunc</span><span class="ot">);</span>
    } <span class="kw">else</span> {
        <span class="kw">$value</span> = <span class="fu">trim</span><span class="ot">(</span><span class="kw">$value</span><span class="ot">);</span>
    }
}<span class="ot">;</span>
<span class="fu">array_walk</span><span class="ot">(</span><span class="kw">$a</span><span class="ot">,</span> <span class="kw">$myfunc</span><span class="ot">);</span></code></pre></div>
<p>普通函数的递归很好写，但是匿名函数的递归就是第一次写来，竟然需要用use来把当前函数导入进闭包里面，而且必需以传引用的方式，php的语法也是丑得可以。</p>]]></summary>
</entry>
<entry>
    <title>eloquent高级用法</title>
    <link href="http://blog.iyue.club/posts/2016-07-18-delve-into-eloquent.html" />
    <id>http://blog.iyue.club/posts/2016-07-18-delve-into-eloquent.html</id>
    <published>2016-07-18T00:00:00Z</published>
    <updated>2016-07-18T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>常见的关系模型有1对1,1对多，多对多，在一个model中描述这些关系用<code>hasOne</code>, <code>hasMany</code>, <code>belongsTo</code>, <code>belongsToMany</code>就够了，但是最近遇到一个新的情况要用到更复杂的关系模型，就是polymorphic relation，按照<a href="https://en.wikipedia.org/wiki/Polymorphic_association">wikipedia</a> 的说法，这个概念是在ORM开发中提出来的，<a href="https://laravel.com/docs/5.2/eloquent-relationships">laravel</a>和<a href="http://guides.rubyonrails.org/association_basics.html">rails</a>中很好的实现了多态关系。第一次遇到这个问题的时候没见过，以为能用自带的1对多关系解决，但是在经过一番尝试之后没法优雅的解决我的问题，所以求助了<a href="https://stackoverflow.com/questions/38433109/eloquent-belongsto-determine-relation-table">stackoverflow</a>，很快就有网友提示了正确的思路，避免我在错误的道路上越走越远，今天就来总结一下我的问题吧。</p>
<p>在项目中有一些资源表，如games, news, songs，现在的需求要针对每种资源都能进行评论，所以还有一个评论表，但是在评论表中得区分是对什么资源的评论，所以用<code>commentable_id</code>和<code>commentable_type</code>来标识一个可被评论项实体。最初建表的时候是打算用<code>item_id</code>和<code>item_type</code>这2个字段的，但是按照laravel和ruby官方文档的建议，我还是改为以<code>able</code>结尾的单词了，我的model见下:</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> Game
{
    <span class="kw">public</span> <span class="kw">function</span> comment<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;morphMany<span class="ot">(</span>Comment::<span class="kw">class</span><span class="ot">,</span> <span class="st">&#39;commentable&#39;</span><span class="ot">);</span>
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> News
{
    <span class="kw">public</span> <span class="kw">function</span> comment<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;morphMany<span class="ot">(</span>Comment::<span class="kw">class</span><span class="ot">,</span> <span class="st">&#39;commentable&#39;</span><span class="ot">);</span>
    }
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">class</span> Comment
{
    <span class="kw">public</span> <span class="kw">function</span> commentable<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;morphTo<span class="ot">();</span>
    }
    <span class="kw">public</span> <span class="kw">function</span> getCommentableTypeAttribute<span class="ot">(</span><span class="kw">$value</span><span class="ot">)</span>
    {
        <span class="kw">if</span> <span class="ot">(</span><span class="kw">$value</span> == <span class="st">&#39;App\Model\Game&#39;</span><span class="ot">)</span> {
            <span class="kw">return</span> <span class="st">&#39;game&#39;</span><span class="ot">;</span>
        } <span class="kw">else</span> {
            <span class="kw">return</span> <span class="st">&#39;news&#39;</span><span class="ot">;</span>
        }
    }
    <span class="kw">public</span> <span class="kw">function</span> author<span class="ot">()</span>
    {
        <span class="kw">return</span> <span class="kw">$this</span>-&gt;belongsTo<span class="ot">(</span>User::<span class="kw">class</span><span class="ot">,</span> <span class="st">&#39;author_id&#39;</span><span class="ot">);</span>
    }
}</code></pre></div>
<p>在获取一个用户发布的所有评论时，可以使用</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$comments</span> = Comment::where<span class="ot">(</span><span class="st">&#39;author_id&#39;</span><span class="ot">,</span> <span class="st">&#39;=&#39;</span><span class="ot">,</span> <span class="kw">$id</span><span class="ot">)</span>
    -&gt;with<span class="ot">(</span><span class="st">&#39;commentable&#39;</span><span class="ot">)</span>
    -&gt;paginate<span class="ot">();</span></code></pre></div>
<p>通过打印这行的查询日志发现总共有4条查询语句:</p>
<ol style="list-style-type: decimal">
<li><p>查询用户的总评论数，分页时用到</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> <span class="fu">count</span>(*) <span class="kw">as</span> aggregate <span class="kw">from</span> `comments` <span class="kw">where</span> `author_id` = ?</code></pre></div></li>
<li><p>查询评论本身的信息</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> `comments` <span class="kw">where</span> `author_id` = ? <span class="kw">limit</span> <span class="dv">15</span> offset <span class="dv">0</span></code></pre></div></li>
<li><p>查询发布评论的人的信息</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> `users` <span class="kw">where</span> `users`.`id` <span class="kw">in</span> (?)</code></pre></div></li>
<li><p>查询被评论物的详细信息</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> * <span class="kw">from</span> `games` <span class="kw">where</span> `games`.`id` <span class="kw">in</span> (?) <span class="kw">and</span> `status` = ?</code></pre></div></li>
</ol>
<p>一行代码对应4条查询，使用eloquent的优点由此可见，省去了很多自己手写查询的精力。</p>
<p>另一个查询这种数据模型的思路是关联查询，</p>
<div class="sourceCode"><pre class="sourceCode sql"><code class="sourceCode sql"><span class="kw">select</span> c.id <span class="kw">as</span> comment_id, c.commentable_id, g.name <span class="kw">as</span> title <span class="kw">from</span> comments <span class="kw">as</span> c <span class="kw">left</span> <span class="kw">join</span> games <span class="kw">as</span> g <span class="kw">on</span> c.commentable_id=g.id <span class="kw">where</span> c.commentable_type=<span class="st">&#39;App</span><span class="ch">\\</span><span class="st">Model</span><span class="ch">\\</span><span class="st">Game&#39;</span> <span class="kw">union</span> <span class="kw">select</span> c.id <span class="kw">as</span> comment_id, c.commentable_id, n.title <span class="kw">as</span> title <span class="kw">from</span> comments <span class="kw">as</span> c <span class="kw">left</span> <span class="kw">join</span> news <span class="kw">as</span> n <span class="kw">on</span> c.commentable_id=n.id <span class="kw">where</span> c.commentable_type=<span class="st">&#39;App</span><span class="ch">\\</span><span class="st">Model</span><span class="ch">\\</span><span class="st">News&#39;</span>;</code></pre></div>
<p>开始是打算动态选择如何管理资源表的，后来尝试之后发现只能用union合并2条查询的结果，手写查询还是不如eloquent优雅。</p>]]></summary>
</entry>
<entry>
    <title>laravel密码生成与校验机制</title>
    <link href="http://blog.iyue.club/posts/2016-07-08-laravel-password.html" />
    <id>http://blog.iyue.club/posts/2016-07-08-laravel-password.html</id>
    <published>2016-07-08T00:00:00Z</published>
    <updated>2016-07-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>在irc上听到有人说他们的应用改了.env中的APP_KEY之后就无法登录了，太奇怪了，在本地测试了几个例子都没有复现，决定详细看看这块</p>
<p>在注册的时候生成密码的密文，内置了一个叫做<a href="https://github.com/laravel/framework/blob/5.2/src/Illuminate/Foundation/helpers.php#L180">bcrypt</a>的函数来加密明文密码，实际密码生成是在<a href="https://github.com/laravel/framework/blob/5.2/src/Illuminate/Hashing/BcryptHasher.php#L26">BcryptHasher#make</a>中，使用blowfish算法来生成密文，不带参数使用的cost是10</p>
<p>再看看密码验证这部分 实际校验是在<a href="https://github.com/laravel/framework/blob/5.2/src/Illuminate/Auth/EloquentUserProvider.php#L114">EloquentUserProvider#validateCredentials</a>，调用BcryptHasher#check来校验，关于laravel和php的加密有<a href="https://mnshankar.wordpress.com/2014/03/29/laravel-hash-make-explained/">一篇很好的文章</a>讲述了blowfish这个算法的作用，盐和加密变换次数都存放在密码本身，所以密码的生成和校验完全和APP_KEY无关，别害怕使用<code>php artisan key:generate</code>，这个命令只会让session失效</p>]]></summary>
</entry>
<entry>
    <title>点赞收藏存储设计</title>
    <link href="http://blog.iyue.club/posts/2016-06-06-like-favorite-design.html" />
    <id>http://blog.iyue.club/posts/2016-06-06-like-favorite-design.html</id>
    <published>2016-06-06T00:00:00Z</published>
    <updated>2016-06-06T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>前段时间给自己的业余项目写代码的时候遇到了一个问题就是如何设计点赞，评论，收藏的存储结构。这3个功能是社交软件必不可少的组成部份，但是设计起来确一点都不简单。</p>
<p>先说评论</p>
<p>之前在7k做zeze社区的时候我就发现了评论的复杂性，最大的问题是数据量大，以前做社区的时候一个楼层下可以有几万个评论，一个贴子可以有几百个楼层，一个论坛可以有好多贴子，数据增长很快。但是现在app的评论系统都比较简洁，不会像网页那么复杂，如果不支持嵌套回复的话，那就简单多了，表结构设计如下：</p>
<pre class="plain"><code>id: 评论id，自增主键
item_id: 被评论项目的id，int
author_id: 作者id，int
comment: 评论内容，varchar</code></pre>
<p>这个模型没有解决大数据扩展的问题，但是已经算是非常简洁了，对于未来分表的设想是在中间加一张索引表，映射某一个范围的item_id,某个author_id的所有评论到一个分片中，这样按父id，和发布人id来索引评论的时候都简单。</p>
<p>其次是点赞</p>
<p>这个问题的难度在于用户可以反复点击，所以要求接口响应足够快，占用资源足够少，不然同时多个用户连续点赞取消赞就会给服务器带来很大的压力了。最初我的设想是把点赞设计为用户和帖子的一个关系，如果用户点赞了某一个帖子，用户就和这个贴子有关系，如果取消了点赞这个关系就断开了。那么点赞表就是一个多对多的关系表了，按帖子和用户查询都可以很快。这种实现的坏处是如果用户反复点击赞接口时，都会有一个查询去判断用户是否赞过这个帖子了，因为所有的产品都是要求用户 不能反复点赞同一个帖子，需要程序自己来维护点赞操作的幂等性，也就是每次写库之前先find一次，如果有就更新时间，如果没有就插入。毫无疑问这个接口会很慢而且占用很多资源，所以要找另一个更优化的方案。我后来决定使用redis的zset来存储点赞信息，以帖子id作为key，以点赞用户的uid作为value，score是点赞时间，由于集合自身是不允许出现重复的value的，所以每次都可以直接zadd把点赞用户更新进去，不需要人工维护数据唯一，太省事了，不过如果还要按用户索引被点赞过的帖子，那就得再新增一个key，以uid作为key，以帖子id作为value，不能支持多字段查询是redis的设计导致的，不过更新2个redis的key可比更新1行mysql快多了，最好使用multi保证原子操作。</p>
<p>取消赞，收藏，取消收藏我都是用同样的方式做的，只要确保redis服务器不挂，不丢数据就行。</p>]]></summary>
</entry>
<entry>
    <title>我的chromebook</title>
    <link href="http://blog.iyue.club/posts/2016-06-05-my-chromebook.html" />
    <id>http://blog.iyue.club/posts/2016-06-05-my-chromebook.html</id>
    <published>2016-06-05T00:00:00Z</published>
    <updated>2016-06-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>今年2月份附近入手的一台二手chromebook，到目前为止已经用了很长一段时间了，打算写一篇文章来总结一下使用体验。</p>
<p>先来看看我的屏幕截图，目前看起来还觉得挺geek的 <img src="../images/chromebook-htop.png" alt="终端" /> <img src="../images/chromebook-myadmin.png" alt="myadmin" /></p>
<p>终端模拟器是用的chrome的一个插件叫做crosh window</p>
<p>linux虚拟机是用crouton安装的ubuntu16.04 core,可惜是共享内核的，所以ubuntu的内核也是3.10.18的</p>
<p>一些常用工具包括：</p>
<ol style="list-style-type: decimal">
<li>fish，我最喜欢的shell</li>
<li>tmux，终端复用软件，可以开启多个会话</li>
<li>ss，用来上网的，开启之后chromebook也可以共享上网，真不错</li>
<li>emacs，我最爱的编辑器，之前crouton遇到最大的问题是中文输入法，有了emacs之后我可以用自带的pyim来输入中文了，没必要使用chromebook自带的输入法</li>
<li>开发环境，nginx, mysql, php7, python, rvm等等之类的</li>
<li>数据库连接是用一个叫做myadmin的chrome扩展实现的</li>
</ol>
<p>遇到的问题：</p>
<ol style="list-style-type: decimal">
<li><p>cpu性能太差劲，我的lenovon21用的cpu是intel n2840的，一款低功耗的arm架构双核cpu，在打开多个浏览器标签时资源使用率总是达到100%，我在编译代码的时候就更费劲了，昨晚编译hakyll花了1个多小时，用公司的thinkpad t440s编译大概10分钟能搞定</p></li>
<li><p>显示器太渣，现在应该没有720p的笔记本显示器了吧，看着觉得很糢糊</p></li>
<li><p>机身是黑色塑料的，看起来很廉价，没有chromebook pixel和mac book pro那么银光闪闪</p></li>
<li><p>还是cpu太差劲，平时敲代码打字都有明显的卡顿了</p></li>
</ol>
<p>总结一下：</p>
<ol style="list-style-type: decimal">
<li><p>google是一家非常伟大的公司，感谢他们发明了chromebook这么伟大的产品</p></li>
<li><p>联想是美帝良心企业，在国内就买不到chromebook，国内的thinkpad价格也要比美帝高出一截</p></li>
<li><p>n21还算是一款性价比非常好的本子，就是性能有点弱，17年再换一个16年出的二手chromebook玩玩</p></li>
</ol>]]></summary>
</entry>
<entry>
    <title>php使用guzzle发送http请求</title>
    <link href="http://blog.iyue.club/posts/2016-04-28-php-guzzle-http.html" />
    <id>http://blog.iyue.club/posts/2016-04-28-php-guzzle-http.html</id>
    <published>2016-04-28T00:00:00Z</published>
    <updated>2016-04-28T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>最原始的发送http请求的方法是调用原生的curl扩展，这就需要在php.ini中允许 <code>extension=curl.so</code>，使用方式也很简单，下面是几个发送基本GET, POST请求的例子。</p>
<ol style="list-style-type: decimal">
<li><p>curl 发送GET请求:</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$ch</span> = <span class="fu">curl_init</span><span class="ot">(</span><span class="kw">$url</span><span class="ot">)</span> <span class="ot">;</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_HEADER</span><span class="ot">,</span> <span class="dv">0</span><span class="ot">);</span> <span class="co">// 不返回http头</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_RETURNTRANSFER</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">)</span> <span class="ot">;</span> <span class="co">// 按字符串返回而不是输出到屏幕上</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_TIMEOUT</span><span class="ot">,</span> <span class="dv">3</span><span class="ot">);</span> <span class="co">// 设置连接超时时间</span>
<span class="kw">$result</span> = <span class="fu">curl_exec</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">)</span> <span class="ot">;</span>
<span class="fu">curl_close</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">);</span></code></pre></div></li>
<li><p>curl 发送POST请求:</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$ch</span> = <span class="fu">curl_init</span><span class="ot">(</span><span class="kw">$url</span><span class="ot">);</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_POST</span><span class="ot">,</span><span class="dv">1</span><span class="ot">);</span> <span class="co">// 表明是发送post请求</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_POSTFIELDS</span><span class="ot">,</span> <span class="kw">$jsonString</span><span class="ot">);</span> <span class="co">// post的数据，支持json字符串和http_build_query之后的参数</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_RETURNTRANSFER</span><span class="ot">,</span> <span class="kw">true</span><span class="ot">);</span>
<span class="kw">$result</span> = <span class="fu">curl_exec</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">)</span> <span class="ot">;</span>
<span class="fu">curl_close</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">);</span></code></pre></div></li>
<li><p>curl上传文件: 也是一个post请求，例子见下面</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$ch</span> = <span class="fu">curl_init</span><span class="ot">(</span><span class="kw">$url</span><span class="ot">);</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_POST</span><span class="ot">,</span><span class="dv">1</span><span class="ot">);</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_POSTFIELDS</span><span class="ot">,</span> <span class="ot">[</span>
<span class="st">&#39;file&#39;</span> =&gt; <span class="kw">new</span> \CurlFile<span class="ot">(</span><span class="kw">$fullFileName</span><span class="ot">,</span> <span class="kw">$mimeType</span><span class="ot">,</span> <span class="kw">$filename</span><span class="ot">);</span>
<span class="st">&#39;param1&#39;</span> =&gt; <span class="kw">$value1</span><span class="ot">,</span>
<span class="st">&#39;param2&#39;</span> =&gt; <span class="kw">$value2</span><span class="ot">,</span>
<span class="ot">]);</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_RETURNTRANSFER</span><span class="ot">,</span> <span class="dv">1</span><span class="ot">);</span>
<span class="fu">curl_setopt</span><span class="ot">(</span><span class="kw">$ch</span><span class="ot">,</span> <span class="kw">CURLOPT_HTTPHEADER</span><span class="ot">,</span> <span class="ot">[</span>
<span class="st">&#39;Content-type: multipart/form-data;&#39;</span>
<span class="ot">]);</span>
<span class="kw">$result</span>=<span class="fu">curl_exec</span> <span class="ot">(</span><span class="kw">$ch</span><span class="ot">);</span>
<span class="fu">curl_close</span> <span class="ot">(</span><span class="kw">$ch</span><span class="ot">);</span></code></pre></div></li>
</ol>
<p>第一次使用curl上传文件的时候还遇到了一点小问题，网上大部分写法都是用<code>'file' =&gt; @&quot;$fullFileName&quot;</code>来加载文件的，我用这种写法反复测试了很久都不能获取到真是的文件，后来才发现<a href="https://secure.php.net/manual/en/class.curlfile.php">CurlFile</a>这个类，按照文档下面评论的说法，php发送multipart请求的时候会有问题，解决办法有2个，1：允许<code>CURLOPT_SAFE_UPLOAD</code>， 2：使用CURLFile 而不是 “@”</p>
<p>我偏好的http请求库 <a href="https://github.com/guzzle/guzzle">guzzle</a> 作为一个应用开发者而言，更多的封装往往是更好的，curl太原始了，接口太少，选项太多，如果要发一个post请求，得先去查一下如何设置数据，如何设置请求头，返回值说明什么意思，如何表示20x, 30x, 40x, 50x的状态码，但是作为一个http库选择就更少了，我们只要知道如何创建请求对象，如何发送请求，响应对象，异常是什么就够了，知道了这几个概念如果要发送一种特殊请求只需要修改请求对象就行了</p>
<p>请求对象:</p>
<p>一个简单的GET请求的对象</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$request</span> = <span class="kw">new</span> \GuzzleHttp\Psr7\Request<span class="ot">(</span><span class="st">&#39;GET&#39;</span><span class="ot">,</span> <span class="st">&#39;http://httpbin.org&#39;</span><span class="ot">);</span></code></pre></div>
<p>一个简单的POST请求的对象</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$request</span> = <span class="kw">new</span> \GuzzleHttp\Psr7\Request<span class="ot">(</span><span class="st">&#39;POST&#39;</span><span class="ot">,</span> <span class="st">&#39;http://httpbin.org&#39;</span><span class="ot">);</span></code></pre></div>
<p>一个简单的发送multipart/form-data请求上传文件的例子</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$r</span> = <span class="kw">$client</span>-&gt;request<span class="ot">(</span><span class="st">&#39;POST&#39;</span><span class="ot">,</span> <span class="kw">$url</span><span class="ot">,</span> <span class="ot">[</span>
    <span class="st">&#39;multipart&#39;</span> =&gt; <span class="ot">[</span>
        <span class="ot">[</span><span class="st">&#39;name&#39;</span> =&gt; <span class="st">&#39;file&#39;</span><span class="ot">,</span><span class="st">&#39;contents&#39;</span> =&gt; <span class="kw">$body</span><span class="ot">],</span>
        <span class="ot">[</span><span class="st">&#39;name&#39;</span> =&gt; <span class="st">&#39;user_id&#39;</span><span class="ot">,</span> <span class="st">&#39;contents&#39;</span> =&gt; <span class="dv">1</span><span class="ot">],</span>
    <span class="ot">],</span>
<span class="ot">]);</span></code></pre></div>
<p>发送请求： 首先要有一个客户端对象，这个对象能够发送一个请求对象，然后获得响应</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$client</span> = <span class="kw">new</span> Client<span class="ot">();</span></code></pre></div>
<p>发送请求：</p>
<div class="sourceCode"><pre class="sourceCode php"><code class="sourceCode php"><span class="kw">$client</span>-&gt;send<span class="ot">(</span><span class="kw">$request</span><span class="ot">);</span></code></pre></div>
<p>在调试curl发请求的时候还发现了一个小技巧抓包，用<code>nc -l -p 8888</code>开启一个监听端口，然后把curl的请求地址设置为<code>http://127.0.0.1:8888</code>，这样就能抓到php发送http请求的数据了，总之guzzle比curl强大太多，能用就多用。</p>]]></summary>
</entry>
<entry>
    <title>从prelude切换到spacemacs</title>
    <link href="http://blog.iyue.club/posts/2015-12-26-switch-to-spacemacs.html" />
    <id>http://blog.iyue.club/posts/2015-12-26-switch-to-spacemacs.html</id>
    <published>2015-12-26T00:00:00Z</published>
    <updated>2015-12-26T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h2 id="最初的配置">最初的配置</h2>
<h3 id="基本的配置文件">基本的配置文件</h3>
<p>使用prelude作为基本配置文件，加上自定义的改动</p>
<h3 id="自定义配置文件">自定义配置文件</h3>
<ul>
<li>编辑personal/下面的文件，添加自定义配置</li>
<li>使用customize方法来自动生成配置</li>
</ul>
<h3 id="从elpa或者是melpa上面下载别人贡献的包">从elpa或者是melpa上面下载别人贡献的包</h3>
<h2 id="目前的配置">目前的配置</h2>
<h3 id="spacemacs">spacemacs</h3>
<p>所有配置都使用spacemacs的规则</p>
<h2 id="切换的原因">切换的原因</h2>
<h3 id="设计思想的不同">设计思想的不同</h3>
<p>spacemacs讲究配置文件分层，对于个人的配置文件设置有很严格的要求，便于大家交换配置文件</p>
<h3 id="界面不同">界面不同</h3>
<p>spacemacs的ui也很美观，下面的状态条非常漂亮</p>
<h3 id="社区活跃程度">社区活跃程度</h3>
<p>现在spacemacs社区很活跃，每天都有人提交代码，算是emacs社区目前最活跃的一个项目了</p>
<h3 id="纯粹喜新厌旧">纯粹喜新厌旧</h3>
<p>不折腾就不叫做极客</p>
<h2 id="切换之后的感受">切换之后的感受</h2>
<h3 id="每一次变更都是一个痛苦的经历">每一次变更都是一个痛苦的经历</h3>
<p>切换过来之后很多快捷键都不同了，导致有点痛苦，新的学习曲线</p>
<h3 id="习惯让生活更高效">习惯让生活更高效</h3>
<p>原来使用prelude的快捷键，基本按键都是遵循emacs默认的按键，比如说helm的快捷键也是， 按键设置没有规律，现在spacemacs的快捷键基本都统一格式了，我喜欢一致性</p>
<h3 id="养成一个好习惯很重要">养成一个好习惯很重要</h3>
<p>工具是有好坏之分的，如果不相信这句话而是一味的认为工具不重要，人才是最终要的，这样下去 就会让工作生活效率越来越低下</p>]]></summary>
</entry>

</feed>
