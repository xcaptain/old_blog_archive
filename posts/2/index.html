<!DOCTYPE html>
<html class="no-js" lang="en">
<head>
  <meta charset="utf-8">
  <title>Joey's Blog</title>
  <meta name="author" content="joey">

  
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://blog.iyue.club/posts/2">
  <link href="/favicon.png" type="image/png" rel="icon">
  <link href="/atom.xml" rel="alternate" title="Joey's Blog" type="application/atom+xml">

  <!-- http://opengraphprotocol.org/ -->
  <meta name="twitter:card" content="summary_large_image">
  <meta property="og:type" content="website">
  <meta property="og:url" content="http://blog.iyue.club/posts/2">
  <meta property="og:title" content="Joey's Blog">
  <meta property="og:description" content="不甘平凡">

  <script src="/javascripts/libs/jquery/jquery-2.0.3.min.js"></script>

<link href="/assets/bootstrap/dist/css/bootstrap.min.css" rel="stylesheet" type="text/css">
<link href="/assets/bootstrap/dist/css/bootstrap-theme.min.css" rel="stylesheet" type="text/css">


  
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">

  

</head>

  <body   >
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <div id="wrap">
      <header role="banner">
        <nav class="navbar navbar-default" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">Joey's Blog</a>
        </div>

        <div class="navbar-collapse collapse">
            <ul class="nav navbar-nav">
                <li class="active">
                    <a rel="index" href="/">Blog</a>
                </li>
                <li >
                    <a href="/blog/archives">Archives</a>
                </li>
                <li >
                    <a  href="/blog/categories/linux">Linux</a>
                </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <form class="search navbar-form navbar-right" action="https://www.google.com/search" method="GET">
                            <input type="hidden" name="q" value="site:blog.iyue.club">
                            <div class="form-group">
                                <input class="form-control" type="text" name="q" placeholder="Search">
                            </div>
                        </form>
                    </li>
                
                <li>
                    <a class="subscribe-rss" href="/atom.xml" title="subscribe via RSS">
                        <span class="visible-xs">RSS</span>
                        <img class="hidden-xs" src="/images/rss.png" alt="RSS">
                    </a>
                </li>
                
            </ul>
        </div>
    </div>
</nav>


      </header>
      <div id="main" role="main" class="container">
        <div id="content">
          <div class="row">
  <div class="page-content col-md-9">
    <div class="blog-index" itemscope itemtype="http://schema.org/Blog">
    <meta itemprop="name" content="Joey's Blog" />
    <meta itemprop="description" content="不甘平凡" />
    <meta itemprop="url" content="http://blog.iyue.club" />
      
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2015-01-04T07:16:58+08:00"  data-updated="true" itemprop="datePublished dateCreated">2015-01-04</time>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/blog/2015/01/04/debug-shadowsocks/" itemprop="url">调试shadowsocks</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><p>昨天把在东京的虚拟机搬到加州去了，感觉这次搬家还是很值得的，传输稳定了很多，原来在东京的时候看个youtube经常卡，但是现在看youtube很流畅，不过每月多给2美元，让我帐号里的钱花得更快了。原来装的是freebsd10的系统，现在我把系统换成ubuntu14.04了，因为bsd的软件还是比较老的，而ubuntu就新多了，而且docker和container等都得在linux才能跑。</p>

<p>系统安装完之后肯定是要部署shadowsocks的，操作很简单就不多说了，一点问题都没有，但是今天早上起床开机就发现没法翻墙了，这时候问题就出现了，耽误我一整天时间。</p>

<p>笔记本没法翻墙是什么问题呢？试了一下手机，用fqrouter是没问题的，那就说明服务器端是没问题的，好吧，在客户端上找原因。</p>

<p>之前安装的客户端是nodejs版的，一直都这么用感觉没什么问题，现在我就打算换个客户端版本，试试python的。安装也很简单，但是就是上不了网，真是郁闷。没办法了，慢慢来调试找问题吧。我在服务器端和客户端都开启了-v参数，用来详细输出日志。</p>

<ol>
<li><p>用fqrouter访问的时候，服务器端输出：
 <pre>
 2015-01-03 08:48:07 INFO: accept a connection.
 2015-01-03 08:48:07 INFO: connect to: 106.162.216.94:443
 2015-01-03 08:48:07 INFO: asyncns resolved.
 2015-01-03 08:48:07 INFO: remote connected.
 </pre>
 看来这是正常连接，返回数据也正常。</p></li>
<li><p>本地用firefox访问google，服务器端输出：
 <pre>
 2015-01-03 08:49:56 INFO: accept a connection.
 2015-01-03 08:49:56 INFO: connect to: plus.google.com:443
 2015-01-03 08:50:16 INFO: asyncns resolved.
 2015-01-03 08:50:16 ERROR: getaddrinfo: Operation now in progress
 2015-01-03 08:50:16 INFO: current server connection: 2
 </pre>
 这就是失败的连接在服务器的日志了，只看到一行错误，搞不懂原因。</p></li>
<li><p>在服务器端执行<code>netstat -naltp | grep 8388</code>的输出：
 <pre>
 tcp        0      0 111.222.231.123:8388    0.0.0.0:*               LISTEN      1738/ss-server
 tcp        0      0 111.222.231.123:8388    152.42.49.117:29403     ESTABLISHED 1738/ss-server
 tcp        0      0 111.222.231.123:8388    152.42.49.117:29406     ESTABLISHED 1738/ss-server
 tcp        0      0 111.222.231.123:8388    152.42.49.117:29402     TIME_WAIT   -
 tcp        0      0 111.222.231.123:8388    152.42.49.117:29400     TIME_WAIT   -
 tcp        0      0 111.222.231.123:8388    152.42.49.117:29401     TIME_WAIT   -
 </pre>
 本地可以连接服务器的端口，那为什么没有数据返回呢？</p></li>
<li><p>在本地执行<code>netstat -naltp | grep 1080</code>的输出：
 <pre>
 tcp        0      0 127.0.0.1:1080          0.0.0.0:*               LISTEN      732/python
 tcp        0      0 127.0.0.1:45312         127.0.0.1:1080          ESTABLISHED 744/firefox
 tcp        0      0 127.0.0.1:1080          127.0.0.1:45312         ESTABLISHED 732/python
 tcp        0      0 127.0.0.1:1080          127.0.0.1:45307         TIME_WAIT   -
 tcp        0      0 127.0.0.1:1080          127.0.0.1:45309         TIME_WAIT   -
 </pre>
 看来浏览器和本地端口之间也是通的。</p></li>
</ol>


<p>本地应用可以连接本地的端口，本地的端口可以连接服务器，为什么就是没有数据呢？不会调试web程序，不会抓包，这时候只能乱猜原因，一下午都没有想通问题，就在我想要发帖求助的时候，想了一下为什么用fqrouter的时候服务器端接收到的是一个ip，而本地客户端连接服务器的时候就是一个域名，也许dns出问题了，试了一下<code>ping www.google.com</code>，果然不通，问题找到了，虚拟机提供商这个机房的dns昨晚出问题了，导致解析失败，添加一个第三方的dns，问题解决。</p>

<p><code>vi /etc/resolvconf/resolv.conf.d/base</code>添加下面2行</p>

<pre>
nameserver 8.8.8.8
nameserver 8.8.4.4
</pre>


<p>然后执行<code>resolvconf -u</code>刷新dns，这样就能使用google的dns了。</p>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2015-01-03T08:43:43+08:00"  data-updated="true" itemprop="datePublished dateCreated">2015-01-03</time>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/blog/2015/01/03/deploy-email-service/" itemprop="url">部署邮件服务</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><p>今天打算研究一下搭建自己的mail server用来收发邮件，不过后来发现在自己服务器上部署邮件服务太麻烦了，没有那么高性能的服务器，而且额外开放的服务可能会被黑客利用，那么就采用第三方的邮件服务吧。</p>

<h4>首先确定一下发件服务。</h4>

<p>根据网上的推荐，我用的是<a href="https://mandrillapp.com/">mandril</a>，这家公司为免费帐号提供每月发12000封邮件，对于个人玩来说足够了。接下来就是注册帐号，注册完成之后会有一个向导引导着去配置发件服务。填好之后配置都会出现在<a href="https://mandrillapp.com/settings">这里</a>，这些配置包括发件服务器的域名，端口，smtp用户名，以及密码，密码是网站生成的，要好好保存。</p>

<h4>然后就是配置收件服务</h4>

<p>同样也是根据网上的推荐，收件服务用的是国内一家公司的，叫做<a href="https://www.zoho.com/">zoho</a>，这家公司为每个免费帐号提供一个代收域名，15个免费邮箱，每个免费邮箱提供5G存储空间，对于个人玩来说也是足够了的，因为可以把邮件下载到本地，然后删除服务器上的邮件存档，所以这5G的空间可以永远也用不完。好像这家公司就在中关村，真想去参观一下。用zoho的原因是它提供邮件代收服务，我有一个域名<code>joxy.org</code>，我想注册一些邮箱以<code>@joxy.org</code>结尾，zoho就提供这种功能。过程也是很简单，需要先去注册帐号，注册帐号的时候要验证你是否对这个域名有所有权，所以还需要去<a href="https://mya.godaddy.com/">godaddy</a>上面验证一下，我是通过cname的形式来验证的。注册完成之后还得配置一下godaddy，因为在注册域名的时候默认设置了2个收件商，现在我不想用那2个厂商的收件服务了，所以要改改dns设置，找到mx这条配置，删掉额外的2个厂商的配置，然后加上一条mx记录，Host是@,表示joxy.org自身，Points to填mx2.zohomail.com，剩下的随便填就行了。这样当有人往<code>user@joxy.org</code>发邮件的时候，发件服务器通过dns查询的时候就知道要发给zoho，zoho就可以帮忙代收。</p>

<h4>发件服务和收件服务都配置好了，接下来就是测试一下是否能收发邮件了。</h4>

<p>用thunderbird可以很方便的写邮件收邮件。把我刚刚创建的xiefei@joxy.org这个帐号创建了，手动配置好这个帐号发送邮件和接收邮件的设置，就可以开始测试了。在配置smtp发件的时候需要输入密码验证用户是否有权限来发邮件，所以一定要记得填smtp的密码。我测试了一下和我的gamil邮箱互发邮件，一点问题都没有，而且邮件也没有进入垃圾箱。这真是太好了，图形界面的客户端可以收发邮件，真想看看通过php,ruby脚本能不能发邮件。</p>

<p>以上的配置参考了youtube上的<a href="https://www.youtube.com/watch?v=ndIflJOGSww">一个视频</a>，真感谢作者分享这么好的东西，省去了我翻资料学习的过程。</p>

<p>刚刚测试discourse的时候已经把邮件功能加上了，可以发送，真是神奇啊。</p>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2015-01-01T19:35:23+08:00"  data-updated="true" itemprop="datePublished dateCreated">2015-01-01</time>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/blog/2015/01/01/arch-pacman-broken/" itemprop="url">解决pacman依赖关系破裂问题</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><p>今天准备更新一下系统，执行<code>sudo pacman -Syu</code>的时候，竟然没法同步软件源了，报告说依赖错误。</p>

<pre>
packagekit: requires pacman<4.2.0
package-query: requires pacman<4.2.0
</pre>


<p>但是我查看了一下pacman的版本,<code>pacman --version</code>发现是4.1的满足需求啊，为什么会有这样的提示呢？我想用<code>sudo pacman -S pacman</code>重装pacman也不行，真是费解，这么重要的软件可千万不能出错啊。后来上网搜了一下，发现有人也遇到这种情况，都是直接<code>sudo pacman -R packagekit python-packagekit yaourt package-query</code>，然后再<code>sudo pacman-db-upgrade</code>升级一下数据库，然后再<code>sudo pacman -Syu</code>，ok问题解决。</p>

<p>还有一点是关于virtualbox的，今天我又用了一下vagrant，发现每次<code>vagrant up</code>都会提示：</p>

<pre>
VirtualBox is complaining that the kernel module is not loaded. Please
run `VBoxManage --version` or open the VirtualBox GUI to see the error
message which should contain instructions on how to fix this error.
</pre>


<p>用最简单的方法<code>sudo modprobe vboxdrv</code>然后<code>lsmod | grep vbox</code>发现加载进了</p>

<pre>
vboxdrv               348377  3 vboxnetadp,vboxnetflt,vboxpci`
</pre>


<p>但是这时候还是会报错说找不到网卡驱动，后来我执行<code>sudo vboxreload</code>显示：</p>

<pre>
vboxpci                23139  0
vboxnetflt             27412  0
vboxnetadp             25443  0
vboxdrv               348377  3 vboxnetadp,vboxnetflt,vboxpci
</pre>


<p>这时候才算是真正的把所有的驱动都加进来了。</p>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2015-01-01T00:10:28+08:00"  data-updated="true" itemprop="datePublished dateCreated">2015-01-01</time>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/blog/2015/01/01/try-hhvm/" itemprop="url">尝试hhvm</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><p>今天听到一个新闻说维基百科把他的php引擎由zend全面转到hhvm了，详情见<a href="https://www.mediawiki.org/wiki/HHVM">这里</a>。其实之前对于这东西是闻所未闻的，太不关注php的发展了，后来详细搜了一下，才稍微了解了一点php代码的执行过程。</p>

<p>对于动态语言来说，都是首先通过代码解析来生成字节码，然后通过解释器来执行这些字节码，php用的解释器叫作zend。看来和python差不多，程序在执行的时候也会先生成字节码，然后用python解释器去执行这些字节码。不过解释器的使用也导致了程序运行缓慢。所以现在facebook就做了一个叫作hhvm的东西，当通过hhvm来执行php程序的时候，会先生成一种中间码(intermediat byte code)也叫作HHBC(hhvm byte code)，然后hhvm会通过一种即时编译(just in time)的技术，将这种中间码编译为本地可执行的x86-64机器码，最后执行代码的时候等于是本地执行一个可执行程序，效率自然比解释器高了很多。不知道有没有什么方式能够把hhvm的这些步骤分离出来分析，真想看看php的字节码长什么样，生成的二进制程序长什么样。</p>

<p>我在本地立刻部署了一下HHVM的环境，很简单<code>sudo pacman -S hhvm</code>直接就安装hhvm了，测试一下效果，随便写一个php文件，然后<code>hhvm test.php</code>如果安装成功的话就可以得到像执行<code>php test.php</code>一样的效果，现在还没想好写个怎样的测试用例来比较hhvm和原生php的速度。</p>

<p>hhvm装好了之后当然不能只是用它来执行脚本，最重要的还是在服务器端编程上，当nginx接收到了一个请求的文件之后，并且把这个请求交个php的fastcgi处理后，在这里就不能用原生的php来执行文件里的php了，必须通过hhvm来执行，简单，就是不要启动php-fpm嘛，我看了一下安装hhvm的时候竟然自动连systemd的配置文件也生成了，所以我只要执行<code>sudo systemctl start hhvm.service</code>就能开启hhvm的监听程序了，类似php-fpm，hhvm服务器的配置文件存在<code>/etc/hhvm/server.ini</code>，在我这里配置文件写的是监听9000端口，那么<code>netstat -naltp | grep 9000</code>真的看到了一个监听的进程。然后就是确保nginx的配置文件中<code>fastcgi_pass</code>的值是<code>127.0.0.1:9000</code>，这样所有进入9000端口的数据都会被hhvm所处理。随便写了一个简单的数据库查询示例，暂时没发现hhvm和原生php的性能区别，也许是测试代码写得不好。</p>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-12-31T07:49:40+08:00"  data-updated="true" itemprop="datePublished dateCreated">2014-12-31</time>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/blog/2014/12/31/web-crawl-again/" itemprop="url">采集一个论坛的帖子来进行数据分析</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><p>今天接到一个小小的需求，又是和采集相关的，我都要烦死了，采集这东西写得都要腻了。</p>

<p>不过和以前的那些采集有点区别，不再是采集文章了，而是开始采集论坛的帖子。说实话我觉得采集论坛比较简单，因为论坛都是php的页面，页面组织布局一般不会怎么变，而新闻站基本都是cms系统生成的html静态页，静态的页面就有太多可能性了，而且不排除有的编辑太敬业把每个页面都做得不一样。</p>

<p>采集源站是<a href="http://qq.100bt.com">http://qq.100bt.com</a>，和我最近做的<a href="http://www.zeze.com">zeze</a>是同一类型的东西，而且突然发现zeze竟然借鉴了很多这个网站的元素。废话不多说，这次采集主要是为了了解哪些资讯比较受欢迎，然后我们就可以有针对性的来推广我们的内容，看起来像是在收集竞争对手的信息而实现知己知彼百战不殆，这样的活我喜欢。这个叫作百田圈圈的网站似乎运营得不错，里面积累了差不多百万的帖子，用户似乎也很活跃。</p>

<p>其实要获得的信息不多，在我设计的数据库结构中包含以下字段：</p>

<pre>
tid: 帖子的id，用来作为表的主键
url: 帖子的url，便于访问
subject: 帖子标题
author_name: 楼主名，有这个东西可以用来分析哪些用户比较活跃
replies: 帖子的回复数，这个字段是用来衡量一个帖子的受欢迎程度的最重要指标
view: 帖子被查看的次数
pubdate: 发帖时间
maxpage: 帖子页数，因为有的帖子是回复楼层的，所以如果一个帖子分了很多页说明这个帖子内容丰富
category: 帖子所属分类，用来来分析哪些大类的话题比较火
</pre>


<p>没有数据库直接操作真是麻烦，上面这些数据都得分析网页去获取，而且不是在同一个页面，需求挺麻烦的但是不难。</p>

<p>代码传到<a href="https://github.com/xcaptain/BeautifulSoup_Instance/tree/master/btqq">github</a>上面了，以前写的那些采集都是用脚本的形式来实现的，这回尝试了一下自己构造一个采集类，这时候才发现对于python的面向对象特性用的太少了，在设计类的结构，接口上面都很不熟练，现在的代码设计在python大牛严重肯定是很小儿科的，以后要多学习OOP的编程思想，不能总是一个函数一个函数这样顺序的执行下来。</p>

<p>写这么一个简单的任务竟然还花了我一天的时间，看来编码能力还是有待加强，经过总结之后发现问题主要存在三方面：</p>

<ol>
<li>对mysql的查询语句不熟悉，因为我把tid设置为了主键，所以不能重复插入，我想要实现<code>insert into on duplicate key continue</code>的功能，找了半天只看到了<code>insert into on duplicate key update</code>的语法，但是后者不是我想要的，因为使用的是python的<code>MySQLdb</code>来驱动mysql的，这东西对于原生的sql语句支持不是很好，不过幸好最后我找到了<code>insert ignore into</code>这种语句，一下解决了问题，虽然<code>MySQLdb</code>在<code>execute</code>的时候会有警告，但是毕竟实现了功能。</li>
<li><code>MySQLdb</code>这个库的使用不熟悉，在用它来执行sql语句的时候出现了很多问题，看来有时间得专门总结一下python驱动mysql的方法。</li>
</ol>


<p>今晚下班回的路上突然发现代码少写了很多异常检测，比如说没有判断网络链接失败，页面匹配为空等，真希望程序能够按照我设想的执行，等明天早上到了公司6张表都给我装得满满的，明天到了公司 再去修改代码了。</p>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-12-27T05:54:57+08:00"  data-updated="true" itemprop="datePublished dateCreated">2014-12-27</time>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/blog/2014/12/27/install-coreos-with-vagrant/" itemprop="url">通过vagrant安装coreos</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><p>昨晚学习了一下vagrant的用法，今天开始试着用vagrant来在本地虚拟化一个coreos的系统，等熟悉coreos的基本操作之后就可以把我现在vps的freebsd10换成coreos了。</p>

<p>按照<a href="https://coreos.com/docs/running-coreos/platforms/vagrant/">官方的教程</a>一步一步来。</p>

<ol>
<li><code>git clone https://github.com/coreos/coreos-vagrant.git</code> 会在当前目录创建一个叫做<code>coreos-vagrant</code>的目录，里面包含coreos的基本配置以及vagrant的配置。</li>
<li><p>更改配置。vagrant的配置文件就是<code>Vagrantfile</code>，这是一个ruby的文件，里面定义了2个配置文件</p>

<p> CLOUD_CONFIG_PATH = File.join(File.dirname(<strong>FILE</strong>), &ldquo;user-data&rdquo;)
 CONFIG = File.join(File.dirname(<strong>FILE</strong>), &ldquo;config.rb&rdquo;)</p></li>
</ol>


<p>一个是当前目录下的<code>user-data</code>文件，一个是当前目录下的<code>config.rb</code>文件</p>

<pre>
VirtualBox is complaining that the kernel module is not loaded. Please
run `VBoxManage --version` or open the VirtualBox GUI to see the error
message which should contain instructions on how to fix this error.
</pre>


<p>根据Vagrantfile里面 提供的url下载系统的时候，可能是url被屏蔽了，所以需要使用点小手段<code>proxychains vagrant up</code></p>

<p>但是等下载都完成之后却出现下面这段错误信息</p>

<pre>
Command: ["hostonlyif", "create"]

Stderr: 0%...
Progress state: NS_ERROR_FAILURE
VBoxManage: error: Failed to create the host-only adapter
VBoxManage: error: VBoxNetAdpCtl: Error while adding new interface: failed to open /dev/vboxnetctl: No such file or directory
VBoxManage: error: Details: code NS_ERROR_FAILURE (0x80004005), component HostNetworkInterface, interface IHostNetworkInterface
VBoxManage: error: Context: "int handleCreate(HandlerArg*, int, int*)" at line 66 of file VBoxManageHostonly.cpp
</pre>


<p>听起来是virtualbox的网卡驱动没有加载进来，在网上搜到一个很简单的方法，<code>sudo vboxreload</code></p>

<p>virtualbox的驱动问题解决之后，还是执行<code>proxychains vagrant up</code>但是这回却报错了</p>

<pre>
Bringing machine 'core-01' up with 'virtualbox' provider...
Bringing machine 'core-02' up with 'virtualbox' provider...
Bringing machine 'core-03' up with 'virtualbox' provider...
==> core-01: Checking if box 'coreos-stable' is up to date...
==> core-01: Fixed port collision for 22 => 2222. Now on port 2250.
==> core-01: Clearing any previously set network interfaces...
==> core-01: Preparing network interfaces based on configuration...
    core-01: Adapter 1: nat
    core-01: Adapter 2: hostonly
==> core-01: Forwarding ports...
    core-01: 22 => 2250 (adapter 1)
==> core-01: Running 'pre-boot' VM customizations...
==> core-01: Booting VM...
==> core-01: Waiting for machine to boot. This may take a few minutes...
    core-01: SSH address: 127.0.0.1:2250
    core-01: SSH username: core
    core-01: SSH auth method: private key
    core-01: Warning: Remote connection disconnect. Retrying...
    core-01: Warning: Remote connection disconnect. Retrying...
</pre>


<p>翻墙之后127.0.0.1是vps的内部loop地址，不是本机的，所以怎么也ssh不上去，既然东西都下载完了那就不需要代理了，直接<code>vagrant up</code>就有了下面的信息，太好了，这是在自动装系统呢。</p>

<pre>
Bringing machine 'core-01' up with 'virtualbox' provider...
Bringing machine 'core-02' up with 'virtualbox' provider...
Bringing machine 'core-03' up with 'virtualbox' provider...
==> core-01: Checking if box 'coreos-stable' is up to date...
==> core-01: There was a problem while downloading the metadata for your box
==> core-01: to check for updates. This is not an error, since it is usually due
==> core-01: to temporary network problems. This is just a warning. The problem
==> core-01: encountered was:
==> core-01:
==> core-01: Failed to connect to 2404:6800:4008:c00::80: Network is unreachable
==> core-01:
==> core-01: If you want to check for box updates, verify your network connection
==> core-01: is valid and try again.
==> core-01: VirtualBox VM is already running.
==> core-02: Importing base box 'coreos-stable'...
==> core-02: Matching MAC address for NAT networking...
==> core-02: Checking if box 'coreos-stable' is up to date...
</pre>


<p>3台虚拟机全部安装ok，我有一个集群了，哈哈哈哈。查看一下集群的运行状态。</p>

<pre>
Current machine states:

core-01                   running (virtualbox)
core-02                   running (virtualbox)
core-03                   running (virtualbox)

This environment represents multiple VMs. The VMs are all listed
above with their current state. For more information about a specific
VM, run `vagrant status NAME`.
</pre>


<p>查看一下virtualbox的运行状态，有3个进程分别运行着3个虚拟机。</p>

<pre>
joey     10033  1.1  0.2 163232  9492 ?        Sl   22:33   0:08 /usr/lib/virtualbox/VBoxXPCOMIPCD
joey     10040  2.6  0.4 707156 19324 ?        Sl   22:33   0:20 /usr/lib/virtualbox/VBoxSVC --auto-shutdown
joey     11184  3.8  1.9 1497696 74992 ?       Sl   22:33   0:28 /usr/lib/virtualbox/VBoxHeadless --comment coreos-vagrant_core-01_1419632903871_39166 --startvm 29a5b99b-dfa8-48e6-b18f-d63b01696df2 --vrde config
joey     11204  0.0  0.2 154828  9228 ?        S    22:33   0:00 /usr/lib/virtualbox/VBoxNetDHCP --ip-address 192.168.56.100 --lower-ip 192.168.56.101 --mac-address 08:00:27:AA:0D:77 --netmask 255.255.255.0 --network HostInterfaceNetworking-vboxnet0 --trunk-name vboxnet0 --trunk-type netflt --upper-ip 192.168.56.254
joey     27124 10.2  1.9 1527828 76788 ?       Sl   22:40   0:32 /usr/lib/virtualbox/VBoxHeadless --comment coreos-vagrant_core-02_1419633622663_70678 --startvm 07c05704-61e7-4e61-bebd-723978180348 --vrde config
joey     28280 17.8  2.0 1523732 81576 ?       Sl   22:43   0:28 /usr/lib/virtualbox/VBoxHeadless --comment coreos-vagrant_core-03_1419633784764_52573 --startvm f614df63-7556-45ac-a4ca-3654d6039d3d --vrde config
joey     29297  0.0  0.0  12384  2400 pts/2    R+   22:45   0:00 grep --color=auto -i virtualbox
</pre>


<p>再看一下我的<code>VirtualBox VMs</code>目录：</p>

<pre>
coreos-vagrant_core-01_1419632903871_39166/  coreos-vagrant_core-03_1419633784764_52573/
coreos-vagrant_core-02_1419633622663_70678/  Public_default_1419540157403_62624/
</pre>


<p>昨天还只有<code>Public_default_1419540157403_62624/</code>一个目录，今天就多了3个了，算上昨天的那个ubuntu12.04，我是不是有4个虚拟系统了？</p>

<p>进入到我的<code>Vagrantfile</code>所在的目录，执行<code>vagrant ssh core-01</code>，就登陆进我的第一个虚拟机了。</p>

<p>剩下的就是学习如何使用coreos在上面部署开发环境了，有vagrant这么方便的工具来管理虚拟机，我都不想去研究docker了，我这样一个菜鸟竟然也能管理4台机器，科技真是使人懒惰。</p>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-12-26T04:27:01+08:00"  data-updated="true" itemprop="datePublished dateCreated">2014-12-26</time>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/blog/2014/12/26/learn-virtualization-1/" itemprop="url">第一次接触虚拟化</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><p>之前在我的vps上部署了一个<a href="http://f.joxy.org">php论坛</a>，但是后来这个框架的<a href="https://github.com/esotalk/">创始人</a>突然在github上宣布重构了<a href="https://github.com/esotalk/esoTalk">esotalk</a>的代码做了一个新的论坛框架<a href="https://github.com/flarum/core">Flarum</a>，搞得我很伤心，后来在<a href="https://en.wikipedia.org/wiki/Comparison_of_Internet_forum_software">wiki</a>上看到介绍discourse，它的作者<a href="http://www.codinghorror.com/blog">Jeff Atwood</a>说discourse是未来十年互联网论坛发展的趋势，那就搭一个来看看呗，反正以前也学过一阵子ruby on rails.</p>

<p>按照原来部署<a href="http://f.joxy.org">http://f.joxy.org</a>的模式打算先在本地部署好环境，然后提交到git server然后在线上拷贝一份代码到服务器上。但是看discourse的官方安装文档的时候发现默认是不支持在实体机上安装系统的，官方的文档只支持通过docker来部署discourse，docker久仰大名了但是就是没有用过，那好，就去见识见识呗。</p>

<p>搜索了一下发现现在比较流行的服务器环境配置，服务器管理都是通过container也就是容器来进行的，最老土的服务器管理方式是通过ssh连接上服务器，然后手动编译或者包管理的形式安装软件。但是这种方式有很大的局限性，不易把所有的机器都统一配置，因为所有配置文件都要由手动编辑，然后手动更新，必然有的机器版本早，有的机器版本晚，对于管理一个服务器集群来说这是很不方便的。而且服务器多了软件更新就是一个麻烦事，不可能一台机器一台机器的去更新。</p>

<p>目前找到了3个比较有名的虚拟化技术：</p>

<ol>
<li>docker， 更类似于chroot</li>
<li>vagrant，用来管理virtualbox虚拟机</li>
<li>rocket，暂时没什么太多了解</li>
</ol>


<p>早上出门的时候在youtube上看了一个通过docker来安装coreos的视频，但是感觉要学习yaml语法配置，比较繁琐，那就先来看看vagrant吧。</p>

<p>在vagrant的<a href="http://docs.vagrantup.com/v2/getting-started/index.html">官方文档</a>上找到了简单的使用方法，其实说白了就是一个自动安装运行virtualbox的脚本。首先得安装vagrant，<code>sudo pacman -S vagrant</code>，然后得安装virtualbox，<code>sudo pacman -S virtualbox</code>，然后还得安装一大堆的依赖，<code>sudo pacman -S virtualbox-host-modules</code>是用来安装virtualbox用来和宿主机通信的模块，如果这个软件太老了就会无法正常使用vagrant，那么一个补救措施就是<code>sudo pacman -S virtualbox-host-dkms</code>，virtualbox安装好了之后还得解决一些内核的驱动，最简单的就是<code>sudo dkms autoinstall</code>，这个命令会自动搜索<code>linux-headers</code>然后编译对应的驱动，如果系统上没有装<code>linux-header</code>那么还是会报错的，那就得<code>sudo pacman -S linux-headers</code>。需要安装的软件，驱动，都装好了之后就是在内核加载virtualbox的驱动了，很简单<code>sudo modprobe vboxdrv</code>，这时候就大功告成了。</p>

<p>对照着教程在自己的笔记本上一步一步的做，先<code>vagrant init hashicorp/precise32</code>，这回在当前的目录下创建一个叫作<code>Vagrantfile</code>的文件，这里面包含了一大堆虚拟机的配置信息。然后<code>vagrant up</code>就会启动虚拟机，这时候<code>ps aux | grep -i virtualbox</code>就会发现virtualbox已经自动在运行了，在家目录的<code>VirtualBox\ VMs/</code>目录下也会创建对应虚拟机的目录，但是没有启动那个讨厌的图形界面这很不错。因为vagrant主要是用来配置服务器的，所以不需要图形界面，等系统下载安装好了之后就可以执行<code>vagrant up</code>来启动虚拟机了，这个操作会检测是否有<code>Vagrantfile</code>里面写的系统，如果没有就会自动从网上下载。系统下完之后<code>vagrant ssh</code>可以远程连接上虚拟机，发现虚拟机上面有一个网卡ip是<code>10.0.2.15</code>，好奇怪的东西，联网方式是NAT还是bridge呢？有一个自动安装系统的脚本，叫作<code>postinstall.sh</code>，以root身份执行它会自动安装系统，等最后跑完的时候吓我一大跳</p>

<pre><code>++ rm -f '/home/vagrant/*.iso' /home/vagrant/postinstall.sh
++ dd if=/dev/zero of=/EMPTY bs=1M
dd: writing `/EMPTY': No space left on device
78697+0 records in
78696+0 records out
82518818816 bytes (83 GB) copied, 207.558 s, 398 MB/s
++ rm -f /EMPTY
++ exit
</code></pre>

<p>一下dd我83G的硬盘，这可是我整个宿主机所有的空间了，不会影响到我吧，后来<code>df -h</code>了一下才发现虚拟机没有使用多少硬盘空间，而且宿主机也没有消耗掉很多硬盘空间。这样就有了一台虚拟机了，这可比直接用virtualbox方便多了，没有预先问我分配多少颗CPU，没有问我分配多少RAM，没有问我分配多少硬盘就把系统装好了，我喜欢。</p>

<p>vagrant有一个共享目录就是宿主机的<code>Vagrantfile</code>所在的那个目录，也是虚拟机的<code>/vagrant</code>目录，这个目录双方都可以读写，想想真是有点小激动，要是以后我虚拟一个windows出来在上面跑一个qq，然后今天志军通过qq传给我的《刺杀金正恩》就不用在windows上跑着vlc服务器给我的arch笔记本供源了，不知道有没有人为vagrant做windows的box。</p>

<p>不过vagrant毕竟是建立在virtualbox之上的，虽然说虚拟机占用宿主机的资源少了，但是还可以做得更好，要让机器资源更加充分的利用就得学习docker了，加油。</p>

<p>另外今天和小青谈了一下学习方式的问题，他说我三天打鱼两天晒网没有持之以恒的做一件事，想想也确实是这样，从工作开始学习和使用php来干活，python是原来就会的所以也就没有怎么学，但是又学了几个礼拜ruby，学了几个礼拜haskell，工作在二次开发discuz，但是业余时间却自己搭了一个esotalk的论坛，现在又在研究虚拟化技术。虽然我一直认为身为一个互联网从业者就得把握住互联网的发展方向，不断学习最新的技术，我们生活在一个很开放的社会，最新最热的技术都是开源的有详细的文档，如果不去学习不去研究而是抱着把会的东西研究透彻的话，我有种辜负了这个时代的感觉。希望时代别辜负了我。</p>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-12-20T19:44:35+08:00"  data-updated="true" itemprop="datePublished dateCreated">2014-12-20</time>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/blog/2014/12/20/how-to-use-emacs/" itemprop="url">如何使用emacs</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><p>今天闲着没事，又上我们的<a href="https://github.com/ncuopen">ncuopen</a>上面看了一下，发现小组现在活动极其不频繁，首页和wiki都没有怎么更新，然后上irc上看了一下，发现也没有人在线。</p>

<blockquote><p>一个开源社区最大的悲哀就是没有活跃的用户，没有一个持续贡献的志愿者团队。</p></blockquote>

<p>加入小组这么久了都没有做什么贡献真是惭愧，今天想了一下我可以整理一下我对于emacs使用的一点小小的心得。以下将会简单的说说我平时使用emacs来干什么。</p>

<ol>
<li>写代码，这是最基本的功能。</li>
<li>上网，在emacs24之前的版本必须使用一个叫做<code>emacs-w3m</code>的第三方扩展才能在emacs里面上网，但是现在emacs自己做了一个基于elisp写的文本浏览器<code>eww</code>，使用方式也很简单，直接<code>M-x eww</code>然后输入要搜索的内容或者是要打开的url就行，现在<code>eww</code>默认的搜索引擎是<code>duckduckgo</code>。</li>
<li>聊天，今天上<code>#ncuopen</code>上看了一下，发现聊天室里面没人在，突然比较一下那些比较火的聊天室，如<code>ubuntu</code>, <code>debian</code>每天上去都会有一大堆人在线，随便说一句话就会被别人刷屏，差距真的很大。如果要在emacs里面使用irc聊天，可以使用<code>erc</code>来连接服务器。</li>
<li>看pdf，emacs内建是可以打开pdf文件的，如果习惯了emacs的快捷键，而且不喜欢在<code>evince</code>，<code>okular</code>下面必须使用鼠标的操作，那么可以试试用emacs看pdf。</li>
<li>写博客，我自己也在github上面搭了一个octopress的博客，在本地就是用emacs编辑的博客，因为emacs支持<code>markdown</code>语法，编辑的时候可以直接看到语法高亮，保存后可以在本地预览。</li>
<li>执行shell命令，要么是使用<code>M-x shell</code>来打开一个shell或者是<code>M-x eshell</code>来使用emacs自带的终端模拟器，我喜欢用后者，然后就可以运行任何的shell命令了。不过我用eshell用得少，平时都是在<code>urxvt</code>里面执行命令的。</li>
<li>执行解释器，很动语言都内建了一个elpa的解释器，如ruby, python, php, haskell，sml等，如果想尝试一下某个表达式或者是某个代码段又不想写一个测试文件，那么在解释器里运行是最方便的了，执行<code>M-x run-python</code>, <code>M-x run-haskell</code>，会打开对应语言的解释器，就像在终端执行一样。如果想获得更多语言的支持，可以去<a href="http://elpa.gnu.org/packages/">elpa</a>或者是<a href="http://melpa.org/">melpa</a>上面找找。</li>
<li>使用git，emacs有个扩展叫做<code>magit</code>，用它来提交代码，查看差异，查看版本比在终端使用git命令方便。</li>
<li>看图，这个功能估计很少人会用，<code>display</code>和<code>feh</code>已经做得很棒了。</li>
</ol>


<p>如果要使用上面的功能，最好使用<a href="https://github.com/bbatsov/prelude">prelude-emacs</a>上面的配置，省去很多配置的麻烦。</p>

<p>另外我发现现在小组没有一个好的交流的地方，在github上面提issue总是不太方便，找到了一个开源项目<a href="https://github.com/esotalk/esoTalk">esotalk</a>可以很方便的用来搭建论坛，不知道有没有小伙伴愿意贡献一下。</p>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-12-08T06:25:45+08:00"  data-updated="true" itemprop="datePublished dateCreated">2014-12-08</time>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/blog/2014/12/08/learn-beautifulsoup/" itemprop="url">又是一个采集</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><p>前几天看到有个同事在采集<a href="https://yande.re">这个</a>站，要把上面的图片都搞下来。看他很得意的样子，似乎采集是个什么很复杂东西，其实简单得很，没什么技术含量在里面。他用的是一个叫做scrapy的采集框架，这个框架我没用过，但是自己写采集也简单。</p>

<p>之前采集过多玩和178的一些文章，需求还比较复杂，需要把ajax的接口也给搞定掉，还得把所有图片都本地化，那时候用的是urllib2+beautifulsoup这个东西采集的。</p>

<p>今天闲着没事，打算再来搞个采集玩玩，<a href="https://yande.re">yande</a>上面的图片质量还是比较高的。还是使用老一套，不过这回我不打算使用urllib2了，这东西太弱了，编码问题总是会出现，搞得我莫名其妙的，实在是打算放弃urllib2了，上网搜一下，找到了一个叫做<code>requests</code>的网络库，这个东西目前开发还是蛮活跃的，而且口气比较大，直接在官网说urllib2的api很混乱，那就是它了。页面分析的库还是用回beautifulsoup，这么久了仍然是很不喜欢写正则，所以拿这个库来解析html还是比较顺手。至于信息入库，我用的是<code>MySQLdb</code>这个库来驱动mysql，似乎这个库也比较弱，反正我是遇到很多很简单的sql语句都报错的情况了，在网上搜了一下，发现别的第三方的mysql库也很多，但是还没有下定决心换。</p>

<p>代码的思路很简单，和以前写的采集脚本差不多，都是先采集列表页，获得文章页的url，然后在文章页中采集想要的信息。信息采集完了就是入库，到这里采集过程就结束了。</p>

<p>代码很简单，已经提交到<a href="https://github.com/xcaptain/yande">github</a>了，和之前写的脚本比起来，多增加了一些东西：
1. 模糊匹配，比如说<code>soup.find(href=re.compile('user\/show'))</code>这样的东西。
2. 断点续踩，程序在跑的时候如果按下<code>Ctrl-C</code>来终止它的话，会把当前采集到的页码写入到一个叫做<code>config.py</code>的文件。
3. 异常处理，以前写的几个采集使用了很多if语句，很多嵌套的判断，就是为了人为规避异常，尽量让程序跑的时候都不遇到异常，这种写法真是太折磨人了，看到三四层嵌套判断我的头都要大了。这回尝试了一下直接在<code>try</code>里面执行代码段，如果遇到可能会有的异常就直接<code>except</code>上处理了它，真是省了很多心呀。</p>
</div>
  
  


        </article>
      
      
        <article class="post" itemprop="blogPost" itemscope itemtype="http://schema.org/BlogPosting">
          
  <header class="page-header">
    
      <p class="meta text-muted text-uppercase">
        












<span class="glyphicon glyphicon-calendar"></span> <time datetime="2014-11-24T05:09:30+08:00"  data-updated="true" itemprop="datePublished dateCreated">2014-11-24</time>
        
      </p>
    
    
      <h2 class="entry-title" itemprop="name headline"><a href="/blog/2014/11/24/got-an-old-pc/" itemprop="url">入手一台二手PC</a></h2>
    
  </header>


  <div class="entry-content clearfix" itemprop="articleBody description"><p>今天下午在58上面看到一条消息，说的是190出售双核电脑，立即就心动了。作为一个linux，总是忍不住手痒想重装系统，或者是自定义系统，但是因为现在自己手头上只有一台笔记本，实在是不敢轻举妄动，不然把这电脑弄崩溃了，或者是丢失数据了那就损失惨重了。如果有一台空闲的机器那就好了，我可以随便在那台机器上面装系统，可以随意定制。而且有一台局域网内部的PC当作服务器，拿来当测试机很不错，在这里测试过代码之后再上传到线上vps上去。</p>

<p>说干就干，反正190也不贵，现在出去随便找个饭店吃个稍微好点的饭都不止190.给卖家打了电话先问了一下基本的情况，大致确定了消息的真实性，然后就是出发去验货了。那个卖家在东城区，好远啊，看了一下时间都已经3点半了，赶紧出发。又是转公交又是转地铁，终于到了东四北大街，来到了卖家的家里。太震惊了，卖家竟然是一个50多岁的老头，家里很简陋，胡同里很老的房子，但是里面堆满了电脑主机，估计有2,3百台。我要买的那台电脑正开着呢，装着win7系统，正在通过pptv看视频呢。cpu是amd的，1.9GHZ，ddr2内存1G大，网卡是100M的螃蟹卡，这种网卡对于*unix来说几乎都是免驱动的了，使用的太广泛了。剩下的就没什么说了，反正是打算拿来当服务器的，对于显卡没什么要求。</p>

<p>成交之后就抱着这主机又穿过了大半个北京回到了住的地方，累死我了。</p>

<p>回来之后打算装系统，问了一下群里的几个朋友，他们都说要装系统的话必须要有显示器才行。伤心，我还以为有一键安装系统的脚本呢，看来系统是得下周拿到公司去装了。真搞不懂，如果服务器装机也像普通桌面电脑一样的话，那些大公司的运维该多惨，几百台机器得装。</p>

<p>接下来就是得好好想想服务器装什么系统好了，现在vps上跑的是freebsd10,已经连续运行3个多月了，稳定性还可以。但是我自己桌面装的是archlinux，相对来说arch的用法还是比freebsd要简单得多。说到这里又想到这几天debian多位核心开发者离职，好像就是因为debian8要采用systemd的原因。arch很早就用了systemd来管理系统启动进程，导致现在用arch几乎都是傻瓜式了，开启某个软件，安装某个软件，检测某个进程运行状态，都可以通过systemctl来实现。对于*inux的哲学来说还是一个软件只干一件事，对于这种想把什么事都干掉的软件，freebsd是很抵制的。</p>

<p>真搞不懂到底哪种才是对的。</p>

<p>昨天在公司加班终于把zeze的代码部署到git上了。</p>

<p>之前用的版本管理是svn，但是我不太喜欢svn，因为emacs不支持它。我喜欢git，因为emacs对git的支持很好，通过magit我可以很轻松的看到每个版本之间的改动，可以任意提交代码。其实我也不是很熟悉git，但是得慢慢来学，以后git肯定是会取代svn的。</p>

<p>我把svn里面的代码复制到内网测试机之后，<code>git init</code>了这个目录，然后执行初始化提交，然后在本地执行<code>git clone user@host:/project/ ./project</code>把代码拷到了本地，打算在本地改了之后up到服务器上。但是后来我发现我想多了，git不是svn，用svn的这种思路是行不通的，线上的代码和本地的代码是毫无关系的2个分支，本地改了之后提交执行<code>git push</code>是会报错的。</p>

<p>那么什么才是正确的git方式呢？查看了一下git的文档，发现上面说git有一个版本库，克隆这个版本库就能获得最新的版本。</p>

<ol>
<li>先把代码复制到本地，<code>scp -r online_code local_code</code></li>
<li>把本地代码初始化成一个git仓库，<code>git init</code></li>
<li>把本地代码都加入到git版本中，<code>git add .</code></li>
<li>第一次提交代码，<code>git commit -m 'init commit'</code></li>
<li>把本地仓库推送到远程服务器上，<code>git remote add gituser@gitserver:/local_code.git</code>，在执行这步的时候必须确保git服务器上面已经存在local_code.git这个目录，如果不存在的话就得<code>mkdir local_code.git</code></li>
<li>把本地仓库保存的版本都推送到服务器上，<code>git push origin master</code></li>
<li>ssh上git服务器看看，找到local_code.git这个目录，发现里面的文件竟然和本地代码里面<code>local_code/.git/</code>下的内容一模一样</li>
<li>把仓库里的代码克隆到对外访问的环境，因为我是在本地做的测试，所以代码仓库和web服务器是在同一台机器上的，直接执行<code>git clone local_code.git /srv/http/online_code</code>就把版本库里面记录的代码复制出来放到服务器目录了。</li>
</ol>


<p>之前我直接在服务器上写代码，提交代码的时候真是落后，得通过命令行来提交代码，magit没法判断远程服务器上的代码的版本。现在这样就好了，我可以用magit随时commit,随时push，然后只要到<code>/srv/http/online_code/</code>下面<code>git pull</code>就行了。</p>
</div>
  
  


        </article>
      
    </div>

    <ul class="pager">
      
        <li class="previous"><a href="/posts/3">&larr;&nbsp;Older</a></li>
      
      <li><a href="/blog/archives">Blog Archives</a></li>
      
        <li class="next"><a href="/index.html">Newer&nbsp;&rarr;</a></li>
      
    </ul>
  </div>

  
    <aside class="sidebar col-md-3">
      
        <section class="panel panel-default">
  <div class="panel-heading">
    <h3 class="panel-title">Recent Posts</h3>
  </div>
  
  <div id="recent_posts" class="list-group">
    
    <a class="list-group-item " href="/blog/2015/05/20/learn-laravel-1/">简单使用laravel</a>
    
    <a class="list-group-item " href="/blog/2015/05/03/mysql-basics-1/">Mysql基础</a>
    
    <a class="list-group-item " href="/blog/2015/04/17/php-meta-programming-1/">一个简单的元编程的例子</a>
    
    <a class="list-group-item " href="/blog/2015/03/26/btrfs-crash/">Btrfs损坏之后的一系列麻烦</a>
    
    <a class="list-group-item " href="/blog/2015/03/15/use-orgmode/">Use-orgmode</a>
    
  </div>
</section>
<section class="panel panel-default">
  <div class="panel-heading">
    <h3 class="panel-title">Categories</h3>
  </div>
  <div class="list-group">
    
    
    <a class="list-group-item " href="/blog/categories/octopress/index.html">
      <span class="badge">1</span>
      octopress
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/web/index.html">
      <span class="badge">5</span>
      web
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/php/index.html">
      <span class="badge">4</span>
      php
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/unix/index.html">
      <span class="badge">1</span>
      unix
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/linux/index.html">
      <span class="badge">11</span>
      linux
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/shell/index.html">
      <span class="badge">1</span>
      shell
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/haskell/index.html">
      <span class="badge">2</span>
      haskell
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/fun/index.html">
      <span class="badge">3</span>
      fun
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/python/index.html">
      <span class="badge">3</span>
      python
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/emacs/index.html">
      <span class="badge">2</span>
      emacs
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/virtualization/index.html">
      <span class="badge">2</span>
      virtualization
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/git/index.html">
      <span class="badge">1</span>
      git
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/docker/index.html">
      <span class="badge">1</span>
      docker
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/vagrant/index.html">
      <span class="badge">1</span>
      vagrant
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/tips/index.html">
      <span class="badge">1</span>
      tips
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/emacs,fish/index.html">
      <span class="badge">1</span>
      emacs,fish
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/emacs,/index.html">
      <span class="badge">1</span>
      emacs,
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/orgmode/index.html">
      <span class="badge">1</span>
      orgmode
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/sql,mysql,postgresql/index.html">
      <span class="badge">1</span>
      sql,mysql,postgresql
    </a>
    
    
    <a class="list-group-item " href="/blog/categories/php,laravel,web/index.html">
      <span class="badge">1</span>
      php,laravel,web
    </a>
    
  </div>
</section>

      
    </aside>
  
</div>

        </div>
      </div>
    </div>
    <footer role="contentinfo"><div class="container">
    <p class="text-muted credits">
  Copyright &copy; 2015 - joey<br>
  <small>
      <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>,
      <span class="credit">customized with <a href="https://github.com/kAworu/octostrap3">octostrap3</a></span>.
  </small>
</p>

</div>
</footer>
    





  <script type="text/javascript">
    (function() {
      var script = document.createElement('script'); script.type = 'text/javascript'; script.async = true;
      script.src = 'https://apis.google.com/js/plusone.js';
      var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(script, s);
    })();
  </script>



  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = '//platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>


<script src="/assets/bootstrap/dist/js/bootstrap.min.js"></script>
<script src="/javascripts/modernizr-2.0.js"></script>


  </body>
</html>
